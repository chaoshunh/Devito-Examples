{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Devito-Examples Documentation for the seismic modeling and inversion examples developed at Georgia Institute of Technology with contribution from the rest of the Devito team at Imperial College London (in particular F. Luporini, R. Nelson and G. Bismas). Overview This repository contains a set of examples and tutorials for seismic modeling and inversion using Devito . These examples use four different wave equations, namely The acoustic isotropic wave equation in seismic/acoustic The TTI pseudo-acoustic wave equation in seismic/tti The elastic isotropic wave equation in seismic/elastic The viscoelastic isotropic wave equation in seismic/elastic Currently, the acoustic isotropic wave equation solver also contains the propagator associated with the adjoint and linearized (Born) wave-equation solution and the gradient of the FWI objective (application of the Jacobian to data residual) Disclaimer A good part of these examples can also be found in the Devito examples directory as a fork of this one. These examples for seismic applications have been developed and implemented by Mathias Louboutin at Georgian Institute of Technology. Some extra examples are also included over there, such as tutorials on the Devito compiler as these examples have been developed primarily at Imperial College London. Installation To install this set of examples with its dependencies run in your terminal (OSX, Ubuntu): git clone https://github.com/slimgroup/Devito-Examples cd Devito-Examples pip install -e . This command will install all dependencies including Devito and will allow you to run the examples. To verify your installation you can run: python seismic/acoustic/acoustic_example.py -nd 1 Some of the examples require velocity models such as the marmousi-ii model. These models can be downloaded at devito-data to be used in the tutorials. Related literature Some of these examples are described in the following papers: Devito's symbolic API \\ TTI imaging \\ Mathias Louboutin's thesis More advanced geophysical application can be found in the JUDI repository. JUDI is a linear algebra DSL built on top of Devito for large scale inverse problems and includes abstractions for source/receivers and handles large SEG-Y datasets with SegyIO . A complete description of JUDI and the related seismic inversion application can be found in Philipp Witte's thesis .","title":"Home"},{"location":"#devito-examples","text":"Documentation for the seismic modeling and inversion examples developed at Georgia Institute of Technology with contribution from the rest of the Devito team at Imperial College London (in particular F. Luporini, R. Nelson and G. Bismas).","title":"Devito-Examples"},{"location":"#overview","text":"This repository contains a set of examples and tutorials for seismic modeling and inversion using Devito . These examples use four different wave equations, namely The acoustic isotropic wave equation in seismic/acoustic The TTI pseudo-acoustic wave equation in seismic/tti The elastic isotropic wave equation in seismic/elastic The viscoelastic isotropic wave equation in seismic/elastic Currently, the acoustic isotropic wave equation solver also contains the propagator associated with the adjoint and linearized (Born) wave-equation solution and the gradient of the FWI objective (application of the Jacobian to data residual)","title":"Overview"},{"location":"#disclaimer","text":"A good part of these examples can also be found in the Devito examples directory as a fork of this one. These examples for seismic applications have been developed and implemented by Mathias Louboutin at Georgian Institute of Technology. Some extra examples are also included over there, such as tutorials on the Devito compiler as these examples have been developed primarily at Imperial College London.","title":"Disclaimer"},{"location":"#installation","text":"To install this set of examples with its dependencies run in your terminal (OSX, Ubuntu): git clone https://github.com/slimgroup/Devito-Examples cd Devito-Examples pip install -e . This command will install all dependencies including Devito and will allow you to run the examples. To verify your installation you can run: python seismic/acoustic/acoustic_example.py -nd 1 Some of the examples require velocity models such as the marmousi-ii model. These models can be downloaded at devito-data to be used in the tutorials.","title":"Installation"},{"location":"#related-literature","text":"Some of these examples are described in the following papers: Devito's symbolic API \\ TTI imaging \\ Mathias Louboutin's thesis More advanced geophysical application can be found in the JUDI repository. JUDI is a linear algebra DSL built on top of Devito for large scale inverse problems and includes abstractions for source/receivers and handles large SEG-Y datasets with SegyIO . A complete description of JUDI and the related seismic inversion application can be found in Philipp Witte's thesis .","title":"Related literature"},{"location":"tutorials/01_modelling/","text":"01 - Introduction to seismic modelling This notebook is the first in a series of tutorials highlighting various aspects of seismic inversion based on Devito operators. In this first example we aim to highlight the core ideas behind seismic modelling, where we create a numerical model that captures the processes involved in a seismic survey. This forward model will then form the basis for further tutorials on the implementation of inversion processes using Devito operators. Modelling workflow The core process we are aiming to model is a seismic survey, which consists of two main components: Source - A source is positioned at a single or a few physical locations where artificial pressure is injected into the domain we want to model. In the case of land survey, it is usually dynamite blowing up at a given location, or a vibroseis (a vibrating engine generating continuous sound waves). For a marine survey, the source is an air gun sending a bubble of compressed air into the water that will expand and generate a seismic wave. Receiver - A set of microphones or hydrophones are used to measure the resulting wave and create a set of measurements called a Shot Record . These measurements are recorded at multiple locations, and usually at the surface of the domain or at the bottom of the ocean in some marine cases. In order to create a numerical model of a seismic survey, we need to solve the wave equation and implement source and receiver interpolation to inject the source and record the seismic wave at sparse point locations in the grid. The acoustic seismic wave equation The acoustic wave equation for the square slowness m m , defined as m=\\frac{1}{c^2} m=\\frac{1}{c^2} , where c c is the speed of sound in the given physical media, and a source q q is given by: \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) = q \\ \\text{in } \\Omega \\\\ &u(.,t=0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) = q \\ \\text{in } \\Omega \\\\ &u(.,t=0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} with the zero initial conditions to guarantee unicity of the solution. The boundary conditions are Dirichlet conditions: \\begin{equation} u(x,t)|_\\delta\\Omega = 0 \\end{equation} where \\delta\\Omega \\delta\\Omega is the surface of the boundary of the model \\Omega \\Omega . Finite domains The last piece of the puzzle is the computational limitation. In the field, the seismic wave propagates in every direction to an \"infinite\" distance. However, solving the wave equation in a mathematically/discrete infinite domain is not feasible. In order to compensate, Absorbing Boundary Conditions (ABC) or Perfectly Matched Layers (PML) are required to mimic an infinite domain. These two methods allow to approximate an infinite media by damping and absorbing the waves at the limit of the domain to avoid reflections. The simplest of these methods is the absorbing damping mask. The core idea is to extend the physical domain and to add a Sponge mask in this extension that will absorb the incident waves. The acoustic wave equation with this damping mask can be rewritten as: \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) + \\eta \\frac{d u(x,t)}{dt}=q \\ \\text{in } \\Omega \\\\ &u(.,0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) + \\eta \\frac{d u(x,t)}{dt}=q \\ \\text{in } \\Omega \\\\ &u(.,0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} where \\eta \\eta is the damping mask equal to 0 0 inside the physical domain and increasing inside the sponge layer. Multiple choice of profile can be chosen for \\eta \\eta from linear to exponential. Seismic modelling with devito We describe here a step by step setup of seismic modelling with Devito in a simple 2D case. We will create a physical model of our domain and define a single source and an according set of receivers to model for the forward model. But first, we initialize some basic utilities. import numpy as np % matplotlib inline Define the physical problem The first step is to define the physical model: What are the physical dimensions of interest What is the velocity profile of this physical domain We will create a simple velocity model here by hand for demonstration purposes. This model essentially consists of two layers, each with a different velocity: 1.5km/s 1.5km/s in the top layer and 2.5km/s 2.5km/s in the bottom layer. We will use this simple model a lot in the following tutorials, so we will rely on a utility function to create it again later. #NBVAL_IGNORE_OUTPUT from seismic import Model , plot_velocity # Define a physical size shape = ( 101 , 101 ) # Number of grid point (nx, nz) spacing = ( 10. , 10. ) # Grid spacing in m. The domain size is now 1km by 1km origin = ( 0. , 0. ) # What is the location of the top left corner. This is necessary to define # the absolute location of the source and receivers # Define a velocity profile. The velocity is in km/s v = np . empty ( shape , dtype = np . float32 ) v [:, : 51 ] = 1.5 v [:, 51 :] = 2.5 # With the velocity and model size defined, we can create the seismic model that # encapsulates this properties. We also define the size of the absorbing layer as 10 grid points model = Model ( vp = v , origin = origin , shape = shape , spacing = spacing , space_order = 2 , nbl = 10 ) plot_velocity ( model ) Operator `initdamp` run in 0.03 s Operator `padfunc` run in 0.01 s Acquisition geometry To fully define our problem setup we also need to define the source that injects the wave to model and the set of receiver locations at which to sample the wavefield. The source time signature will be modelled using a Ricker wavelet defined as \\begin{equation} q(t) = (1-2\\pi^2 f_0^2 (t - \\frac{1}{f_0})^2 )e^{- \\pi^2 f_0^2 (t - \\frac{1}{f_0})} \\end{equation} \\begin{equation} q(t) = (1-2\\pi^2 f_0^2 (t - \\frac{1}{f_0})^2 )e^{- \\pi^2 f_0^2 (t - \\frac{1}{f_0})} \\end{equation} To fully define the source signature we first need to define the time duration for our model and the timestep size, which is dictated by the CFL condition and our grid spacing. Luckily, our Model utility provides us with the critical timestep size, so we can fully discretize our model time axis as an array: from seismic import TimeAxis t0 = 0. # Simulation starts a t=0 tn = 1000. # Simulation last 1 second (1000 ms) dt = model . critical_dt # Time step from model grid spacing time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) The source is positioned at a 20m 20m depth and at the middle of the x x axis ( x_{src}=500m x_{src}=500m ), with a peak wavelet frequency of 10Hz 10Hz . #NBVAL_IGNORE_OUTPUT from seismic import RickerSource f0 = 0.010 # Source peak frequency is 10Hz (0.010 kHz) src = RickerSource ( name = 'src' , grid = model . grid , f0 = f0 , npoint = 1 , time_range = time_range ) # First, position source centrally in all dimensions, then set depth src . coordinates . data [ 0 , :] = np . array ( model . domain_size ) * . 5 src . coordinates . data [ 0 , - 1 ] = 20. # Depth is 20m # We can plot the time signature to see the wavelet src . show () Similarly to our source object, we can now define our receiver geometry as a symbol of type Receiver . It is worth noting here that both utility classes, RickerSource and Receiver are thin wrappers around the Devito's SparseTimeFunction type, which encapsulates sparse point data and allows us to inject and interpolate values into and out of the computational grid. As we have already seen, both types provide a .coordinates property to define the position within the domain of all points encapsulated by that symbol. In this example we will position receivers at the same depth as the source, every 10m 10m along the x axis. The rec.data property will be initialized, but left empty, as we will compute the receiver readings during the simulation. #NBVAL_IGNORE_OUTPUT from seismic import Receiver # Create symbol for 101 receivers rec = Receiver ( name = 'rec' , grid = model . grid , npoint = 101 , time_range = time_range ) # Prescribe even spacing for receivers along the x-axis rec . coordinates . data [:, 0 ] = np . linspace ( 0 , model . domain_size [ 0 ], num = 101 ) rec . coordinates . data [:, 1 ] = 20. # Depth is 20m # We can now show the source and receivers within our domain: # Red dot: Source location # Green dots: Receiver locations (every 4th point) plot_velocity ( model , source = src . coordinates . data , receiver = rec . coordinates . data [:: 4 , :]) Finite-difference discretization Devito is a finite-difference DSL that solves the discretized wave-equation on a Cartesian grid. The finite-difference approximation is derived from Taylor expansions of the continuous field after removing the error term. Time discretization We only consider the second order time discretization for now. From the Taylor expansion, the second order discrete approximation of the second order time derivative is: \\begin{equation} \\begin{aligned} \\frac{d^2 u(x,t)}{dt^2} = \\frac{\\mathbf{u}(\\mathbf{x},\\mathbf{t+\\Delta t}) - 2 \\mathbf{u}(\\mathbf{x},\\mathbf{t}) + \\mathbf{u}(\\mathbf{x},\\mathbf{t-\\Delta t})}{\\mathbf{\\Delta t}^2} + O(\\mathbf{\\Delta t}^2). \\end{aligned} \\end{equation} where \\mathbf{u} \\mathbf{u} is the discrete wavefield, \\mathbf{\\Delta t} \\mathbf{\\Delta t} is the discrete time-step (distance between two consecutive discrete time points) and O(\\mathbf{\\Delta t}^2) O(\\mathbf{\\Delta t}^2) is the discretization error term. The discretized approximation of the second order time derivative is then given by dropping the error term. This derivative is represented in Devito by u.dt2 where u is a TimeFunction object. Spatial discretization We define the discrete Laplacian as the sum of the second order spatial derivatives in the three dimensions: \\begin{equation} \\begin{aligned} \\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t})= \\sum_{j=1}^{j=\\frac{k}{2}} \\Bigg[\\alpha_j \\Bigg(& \\mathbf{u}(\\mathbf{x+jdx},\\mathbf{y},\\mathbf{z},\\mathbf{t})+\\mathbf{u}(\\mathbf{x-jdx},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\\\ &\\mathbf{u}(\\mathbf{x},\\mathbf{y+jdy},\\mathbf{z},\\mathbf{t})+\\mathbf{u}(\\mathbf{x},\\mathbf{y-jdy},\\mathbf{z}\\mathbf{t}) + \\\\ &\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z+jdz},\\mathbf{t})+\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z-jdz},\\mathbf{t})\\Bigg) \\Bigg] + \\\\ &3\\alpha_0 \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}). \\end{aligned} \\end{equation} This derivative is represented in Devito by u.laplace where u is a TimeFunction object. Wave equation With the space and time discretization defined, we can fully discretize the wave-equation with the combination of time and space discretizations and obtain the following second order in time and k^{th} k^{th} order in space discrete stencil to update one grid point at position \\mathbf{x}, \\mathbf{y},\\mathbf{z} \\mathbf{x}, \\mathbf{y},\\mathbf{z} at time \\mathbf{t} \\mathbf{t} , i.e. \\begin{equation} \\begin{aligned} \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t+\\Delta t}) = &2\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) - \\mathbf{u}(\\mathbf{x},\\mathbf{y}, \\mathbf{z},\\mathbf{t-\\Delta t}) +\\\\ & \\frac{\\mathbf{\\Delta t}^2}{\\mathbf{m(\\mathbf{x},\\mathbf{y},\\mathbf{z})}} \\Big(\\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\mathbf{q}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) \\Big). \\end{aligned} \\end{equation} # In order to represent the wavefield u and the square slowness we need symbolic objects # corresponding to time-space-varying field (u, TimeFunction) and # space-varying field (m, Function) from devito import TimeFunction # Define the wavefield with the size of the model and the time dimension u = TimeFunction ( name = \"u\" , grid = model . grid , time_order = 2 , space_order = 2 ) # We can now write the PDE pde = model . m * u . dt2 - u . laplace + model . damp * u . dt # The PDE representation is as on paper pde \\displaystyle \\operatorname{damp}{\\left(x,y \\right)} \\frac{\\partial}{\\partial t} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial x^{2}} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial y^{2}} u{\\left(t,x,y \\right)} + \\frac{\\frac{\\partial^{2}}{\\partial t^{2}} u{\\left(t,x,y \\right)}}{\\operatorname{vp}^{2}{\\left(x,y \\right)}} \\displaystyle \\operatorname{damp}{\\left(x,y \\right)} \\frac{\\partial}{\\partial t} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial x^{2}} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial y^{2}} u{\\left(t,x,y \\right)} + \\frac{\\frac{\\partial^{2}}{\\partial t^{2}} u{\\left(t,x,y \\right)}}{\\operatorname{vp}^{2}{\\left(x,y \\right)}} # This discrete PDE can be solved in a time-marching way updating u(t+dt) from the previous time step # Devito as a shortcut for u(t+dt) which is u.forward. We can then rewrite the PDE as # a time marching updating equation known as a stencil using customized SymPy functions from devito import Eq , solve stencil = Eq ( u . forward , solve ( pde , u . forward )) Source injection and receiver interpolation With a numerical scheme to solve the homogenous wave equation, we need to add the source to introduce seismic waves and to implement the measurement operator, and interpolation operator. This operation is linked to the discrete scheme and needs to be done at the proper time step. The semi-discretized in time wave equation with a source reads: \\begin{equation} \\begin{aligned} \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t+\\Delta t}) = &2\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) - \\mathbf{u}(\\mathbf{x},\\mathbf{y}, \\mathbf{z},\\mathbf{t-\\Delta t}) +\\\\ & \\frac{\\mathbf{\\Delta t}^2}{\\mathbf{m(\\mathbf{x},\\mathbf{y},\\mathbf{z})}} \\Big(\\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\mathbf{q}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) \\Big). \\end{aligned} \\end{equation} \\begin{equation} \\begin{aligned} \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t+\\Delta t}) = &2\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) - \\mathbf{u}(\\mathbf{x},\\mathbf{y}, \\mathbf{z},\\mathbf{t-\\Delta t}) +\\\\ & \\frac{\\mathbf{\\Delta t}^2}{\\mathbf{m(\\mathbf{x},\\mathbf{y},\\mathbf{z})}} \\Big(\\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\mathbf{q}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) \\Big). \\end{aligned} \\end{equation} It shows that in order to update \\mathbf{u} \\mathbf{u} at time \\mathbf{t+\\Delta t} \\mathbf{t+\\Delta t} we have to inject the value of the source term \\mathbf{q} \\mathbf{q} of time \\mathbf{t} \\mathbf{t} . In Devito, it corresponds the update of u u at index t+1 t+1 (t = time implicitly) with the source of time t t . On the receiver side, the problem is either as it only requires to record the data at the given time step t t for the receiver at time time=t time=t . # Finally we define the source injection and receiver read function to generate the corresponding code src_term = src . inject ( field = u . forward , expr = src * dt ** 2 / model . m ) # Create interpolation expression for receivers rec_term = rec . interpolate ( expr = u . forward ) Devito operator and solve After constructing all the necessary expressions for updating the wavefield, injecting the source term and interpolating onto the receiver points, we can now create the Devito operator that will generate the C code at runtime. When creating the operator, Devito's two optimization engines will log which performance optimizations have been performed: * DSE: The Devito Symbolics Engine will attempt to reduce the number of operations required by the kernel. * DLE: The Devito Loop Engine will perform various loop-level optimizations to improve runtime performance. Note : The argument subs=model.spacing_map causes the operator to substitute values for our current grid spacing into the expressions before code generation. This reduces the number of floating point operations executed by the kernel by pre-evaluating certain coefficients. #NBVAL_IGNORE_OUTPUT from devito import Operator op = Operator ([ stencil ] + src_term + rec_term , subs = model . spacing_map ) Now we can execute the create operator for a number of timesteps. We specify the number of timesteps to compute with the keyword time and the timestep size with dt . #NBVAL_IGNORE_OUTPUT op ( time = time_range . num - 1 , dt = model . critical_dt ) Operator `Kernel` run in 0.02 s After running our operator kernel, the data associated with the receiver symbol rec.data has now been populated due to the interpolation expression we inserted into the operator. This allows us the visualize the shot record: #NBVAL_IGNORE_OUTPUT from seismic import plot_shotrecord plot_shotrecord ( rec . data , model , t0 , tn ) assert np . isclose ( np . linalg . norm ( rec . data ), 450 , rtol = 10 )","title":"Acoustic modeling"},{"location":"tutorials/01_modelling/#01-introduction-to-seismic-modelling","text":"This notebook is the first in a series of tutorials highlighting various aspects of seismic inversion based on Devito operators. In this first example we aim to highlight the core ideas behind seismic modelling, where we create a numerical model that captures the processes involved in a seismic survey. This forward model will then form the basis for further tutorials on the implementation of inversion processes using Devito operators.","title":"01 - Introduction to seismic modelling"},{"location":"tutorials/01_modelling/#modelling-workflow","text":"The core process we are aiming to model is a seismic survey, which consists of two main components: Source - A source is positioned at a single or a few physical locations where artificial pressure is injected into the domain we want to model. In the case of land survey, it is usually dynamite blowing up at a given location, or a vibroseis (a vibrating engine generating continuous sound waves). For a marine survey, the source is an air gun sending a bubble of compressed air into the water that will expand and generate a seismic wave. Receiver - A set of microphones or hydrophones are used to measure the resulting wave and create a set of measurements called a Shot Record . These measurements are recorded at multiple locations, and usually at the surface of the domain or at the bottom of the ocean in some marine cases. In order to create a numerical model of a seismic survey, we need to solve the wave equation and implement source and receiver interpolation to inject the source and record the seismic wave at sparse point locations in the grid.","title":"Modelling workflow"},{"location":"tutorials/01_modelling/#the-acoustic-seismic-wave-equation","text":"The acoustic wave equation for the square slowness m m , defined as m=\\frac{1}{c^2} m=\\frac{1}{c^2} , where c c is the speed of sound in the given physical media, and a source q q is given by: \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) = q \\ \\text{in } \\Omega \\\\ &u(.,t=0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) = q \\ \\text{in } \\Omega \\\\ &u(.,t=0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} with the zero initial conditions to guarantee unicity of the solution. The boundary conditions are Dirichlet conditions: \\begin{equation} u(x,t)|_\\delta\\Omega = 0 \\end{equation} where \\delta\\Omega \\delta\\Omega is the surface of the boundary of the model \\Omega \\Omega .","title":"The acoustic seismic wave equation"},{"location":"tutorials/01_modelling/#finite-domains","text":"The last piece of the puzzle is the computational limitation. In the field, the seismic wave propagates in every direction to an \"infinite\" distance. However, solving the wave equation in a mathematically/discrete infinite domain is not feasible. In order to compensate, Absorbing Boundary Conditions (ABC) or Perfectly Matched Layers (PML) are required to mimic an infinite domain. These two methods allow to approximate an infinite media by damping and absorbing the waves at the limit of the domain to avoid reflections. The simplest of these methods is the absorbing damping mask. The core idea is to extend the physical domain and to add a Sponge mask in this extension that will absorb the incident waves. The acoustic wave equation with this damping mask can be rewritten as: \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) + \\eta \\frac{d u(x,t)}{dt}=q \\ \\text{in } \\Omega \\\\ &u(.,0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) + \\eta \\frac{d u(x,t)}{dt}=q \\ \\text{in } \\Omega \\\\ &u(.,0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} where \\eta \\eta is the damping mask equal to 0 0 inside the physical domain and increasing inside the sponge layer. Multiple choice of profile can be chosen for \\eta \\eta from linear to exponential.","title":"Finite domains"},{"location":"tutorials/01_modelling/#seismic-modelling-with-devito","text":"We describe here a step by step setup of seismic modelling with Devito in a simple 2D case. We will create a physical model of our domain and define a single source and an according set of receivers to model for the forward model. But first, we initialize some basic utilities. import numpy as np % matplotlib inline","title":"Seismic modelling with devito"},{"location":"tutorials/01_modelling/#define-the-physical-problem","text":"The first step is to define the physical model: What are the physical dimensions of interest What is the velocity profile of this physical domain We will create a simple velocity model here by hand for demonstration purposes. This model essentially consists of two layers, each with a different velocity: 1.5km/s 1.5km/s in the top layer and 2.5km/s 2.5km/s in the bottom layer. We will use this simple model a lot in the following tutorials, so we will rely on a utility function to create it again later. #NBVAL_IGNORE_OUTPUT from seismic import Model , plot_velocity # Define a physical size shape = ( 101 , 101 ) # Number of grid point (nx, nz) spacing = ( 10. , 10. ) # Grid spacing in m. The domain size is now 1km by 1km origin = ( 0. , 0. ) # What is the location of the top left corner. This is necessary to define # the absolute location of the source and receivers # Define a velocity profile. The velocity is in km/s v = np . empty ( shape , dtype = np . float32 ) v [:, : 51 ] = 1.5 v [:, 51 :] = 2.5 # With the velocity and model size defined, we can create the seismic model that # encapsulates this properties. We also define the size of the absorbing layer as 10 grid points model = Model ( vp = v , origin = origin , shape = shape , spacing = spacing , space_order = 2 , nbl = 10 ) plot_velocity ( model ) Operator `initdamp` run in 0.03 s Operator `padfunc` run in 0.01 s","title":"Define the physical problem"},{"location":"tutorials/01_modelling/#acquisition-geometry","text":"To fully define our problem setup we also need to define the source that injects the wave to model and the set of receiver locations at which to sample the wavefield. The source time signature will be modelled using a Ricker wavelet defined as \\begin{equation} q(t) = (1-2\\pi^2 f_0^2 (t - \\frac{1}{f_0})^2 )e^{- \\pi^2 f_0^2 (t - \\frac{1}{f_0})} \\end{equation} \\begin{equation} q(t) = (1-2\\pi^2 f_0^2 (t - \\frac{1}{f_0})^2 )e^{- \\pi^2 f_0^2 (t - \\frac{1}{f_0})} \\end{equation} To fully define the source signature we first need to define the time duration for our model and the timestep size, which is dictated by the CFL condition and our grid spacing. Luckily, our Model utility provides us with the critical timestep size, so we can fully discretize our model time axis as an array: from seismic import TimeAxis t0 = 0. # Simulation starts a t=0 tn = 1000. # Simulation last 1 second (1000 ms) dt = model . critical_dt # Time step from model grid spacing time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) The source is positioned at a 20m 20m depth and at the middle of the x x axis ( x_{src}=500m x_{src}=500m ), with a peak wavelet frequency of 10Hz 10Hz . #NBVAL_IGNORE_OUTPUT from seismic import RickerSource f0 = 0.010 # Source peak frequency is 10Hz (0.010 kHz) src = RickerSource ( name = 'src' , grid = model . grid , f0 = f0 , npoint = 1 , time_range = time_range ) # First, position source centrally in all dimensions, then set depth src . coordinates . data [ 0 , :] = np . array ( model . domain_size ) * . 5 src . coordinates . data [ 0 , - 1 ] = 20. # Depth is 20m # We can plot the time signature to see the wavelet src . show () Similarly to our source object, we can now define our receiver geometry as a symbol of type Receiver . It is worth noting here that both utility classes, RickerSource and Receiver are thin wrappers around the Devito's SparseTimeFunction type, which encapsulates sparse point data and allows us to inject and interpolate values into and out of the computational grid. As we have already seen, both types provide a .coordinates property to define the position within the domain of all points encapsulated by that symbol. In this example we will position receivers at the same depth as the source, every 10m 10m along the x axis. The rec.data property will be initialized, but left empty, as we will compute the receiver readings during the simulation. #NBVAL_IGNORE_OUTPUT from seismic import Receiver # Create symbol for 101 receivers rec = Receiver ( name = 'rec' , grid = model . grid , npoint = 101 , time_range = time_range ) # Prescribe even spacing for receivers along the x-axis rec . coordinates . data [:, 0 ] = np . linspace ( 0 , model . domain_size [ 0 ], num = 101 ) rec . coordinates . data [:, 1 ] = 20. # Depth is 20m # We can now show the source and receivers within our domain: # Red dot: Source location # Green dots: Receiver locations (every 4th point) plot_velocity ( model , source = src . coordinates . data , receiver = rec . coordinates . data [:: 4 , :])","title":"Acquisition geometry"},{"location":"tutorials/01_modelling/#finite-difference-discretization","text":"Devito is a finite-difference DSL that solves the discretized wave-equation on a Cartesian grid. The finite-difference approximation is derived from Taylor expansions of the continuous field after removing the error term.","title":"Finite-difference discretization"},{"location":"tutorials/01_modelling/#time-discretization","text":"We only consider the second order time discretization for now. From the Taylor expansion, the second order discrete approximation of the second order time derivative is: \\begin{equation} \\begin{aligned} \\frac{d^2 u(x,t)}{dt^2} = \\frac{\\mathbf{u}(\\mathbf{x},\\mathbf{t+\\Delta t}) - 2 \\mathbf{u}(\\mathbf{x},\\mathbf{t}) + \\mathbf{u}(\\mathbf{x},\\mathbf{t-\\Delta t})}{\\mathbf{\\Delta t}^2} + O(\\mathbf{\\Delta t}^2). \\end{aligned} \\end{equation} where \\mathbf{u} \\mathbf{u} is the discrete wavefield, \\mathbf{\\Delta t} \\mathbf{\\Delta t} is the discrete time-step (distance between two consecutive discrete time points) and O(\\mathbf{\\Delta t}^2) O(\\mathbf{\\Delta t}^2) is the discretization error term. The discretized approximation of the second order time derivative is then given by dropping the error term. This derivative is represented in Devito by u.dt2 where u is a TimeFunction object.","title":"Time discretization"},{"location":"tutorials/01_modelling/#spatial-discretization","text":"We define the discrete Laplacian as the sum of the second order spatial derivatives in the three dimensions: \\begin{equation} \\begin{aligned} \\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t})= \\sum_{j=1}^{j=\\frac{k}{2}} \\Bigg[\\alpha_j \\Bigg(& \\mathbf{u}(\\mathbf{x+jdx},\\mathbf{y},\\mathbf{z},\\mathbf{t})+\\mathbf{u}(\\mathbf{x-jdx},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\\\ &\\mathbf{u}(\\mathbf{x},\\mathbf{y+jdy},\\mathbf{z},\\mathbf{t})+\\mathbf{u}(\\mathbf{x},\\mathbf{y-jdy},\\mathbf{z}\\mathbf{t}) + \\\\ &\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z+jdz},\\mathbf{t})+\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z-jdz},\\mathbf{t})\\Bigg) \\Bigg] + \\\\ &3\\alpha_0 \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}). \\end{aligned} \\end{equation} This derivative is represented in Devito by u.laplace where u is a TimeFunction object.","title":"Spatial discretization"},{"location":"tutorials/01_modelling/#wave-equation","text":"With the space and time discretization defined, we can fully discretize the wave-equation with the combination of time and space discretizations and obtain the following second order in time and k^{th} k^{th} order in space discrete stencil to update one grid point at position \\mathbf{x}, \\mathbf{y},\\mathbf{z} \\mathbf{x}, \\mathbf{y},\\mathbf{z} at time \\mathbf{t} \\mathbf{t} , i.e. \\begin{equation} \\begin{aligned} \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t+\\Delta t}) = &2\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) - \\mathbf{u}(\\mathbf{x},\\mathbf{y}, \\mathbf{z},\\mathbf{t-\\Delta t}) +\\\\ & \\frac{\\mathbf{\\Delta t}^2}{\\mathbf{m(\\mathbf{x},\\mathbf{y},\\mathbf{z})}} \\Big(\\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\mathbf{q}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) \\Big). \\end{aligned} \\end{equation} # In order to represent the wavefield u and the square slowness we need symbolic objects # corresponding to time-space-varying field (u, TimeFunction) and # space-varying field (m, Function) from devito import TimeFunction # Define the wavefield with the size of the model and the time dimension u = TimeFunction ( name = \"u\" , grid = model . grid , time_order = 2 , space_order = 2 ) # We can now write the PDE pde = model . m * u . dt2 - u . laplace + model . damp * u . dt # The PDE representation is as on paper pde \\displaystyle \\operatorname{damp}{\\left(x,y \\right)} \\frac{\\partial}{\\partial t} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial x^{2}} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial y^{2}} u{\\left(t,x,y \\right)} + \\frac{\\frac{\\partial^{2}}{\\partial t^{2}} u{\\left(t,x,y \\right)}}{\\operatorname{vp}^{2}{\\left(x,y \\right)}} \\displaystyle \\operatorname{damp}{\\left(x,y \\right)} \\frac{\\partial}{\\partial t} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial x^{2}} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial y^{2}} u{\\left(t,x,y \\right)} + \\frac{\\frac{\\partial^{2}}{\\partial t^{2}} u{\\left(t,x,y \\right)}}{\\operatorname{vp}^{2}{\\left(x,y \\right)}} # This discrete PDE can be solved in a time-marching way updating u(t+dt) from the previous time step # Devito as a shortcut for u(t+dt) which is u.forward. We can then rewrite the PDE as # a time marching updating equation known as a stencil using customized SymPy functions from devito import Eq , solve stencil = Eq ( u . forward , solve ( pde , u . forward ))","title":"Wave equation"},{"location":"tutorials/01_modelling/#source-injection-and-receiver-interpolation","text":"With a numerical scheme to solve the homogenous wave equation, we need to add the source to introduce seismic waves and to implement the measurement operator, and interpolation operator. This operation is linked to the discrete scheme and needs to be done at the proper time step. The semi-discretized in time wave equation with a source reads: \\begin{equation} \\begin{aligned} \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t+\\Delta t}) = &2\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) - \\mathbf{u}(\\mathbf{x},\\mathbf{y}, \\mathbf{z},\\mathbf{t-\\Delta t}) +\\\\ & \\frac{\\mathbf{\\Delta t}^2}{\\mathbf{m(\\mathbf{x},\\mathbf{y},\\mathbf{z})}} \\Big(\\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\mathbf{q}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) \\Big). \\end{aligned} \\end{equation} \\begin{equation} \\begin{aligned} \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t+\\Delta t}) = &2\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) - \\mathbf{u}(\\mathbf{x},\\mathbf{y}, \\mathbf{z},\\mathbf{t-\\Delta t}) +\\\\ & \\frac{\\mathbf{\\Delta t}^2}{\\mathbf{m(\\mathbf{x},\\mathbf{y},\\mathbf{z})}} \\Big(\\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\mathbf{q}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) \\Big). \\end{aligned} \\end{equation} It shows that in order to update \\mathbf{u} \\mathbf{u} at time \\mathbf{t+\\Delta t} \\mathbf{t+\\Delta t} we have to inject the value of the source term \\mathbf{q} \\mathbf{q} of time \\mathbf{t} \\mathbf{t} . In Devito, it corresponds the update of u u at index t+1 t+1 (t = time implicitly) with the source of time t t . On the receiver side, the problem is either as it only requires to record the data at the given time step t t for the receiver at time time=t time=t . # Finally we define the source injection and receiver read function to generate the corresponding code src_term = src . inject ( field = u . forward , expr = src * dt ** 2 / model . m ) # Create interpolation expression for receivers rec_term = rec . interpolate ( expr = u . forward )","title":"Source injection and receiver interpolation"},{"location":"tutorials/01_modelling/#devito-operator-and-solve","text":"After constructing all the necessary expressions for updating the wavefield, injecting the source term and interpolating onto the receiver points, we can now create the Devito operator that will generate the C code at runtime. When creating the operator, Devito's two optimization engines will log which performance optimizations have been performed: * DSE: The Devito Symbolics Engine will attempt to reduce the number of operations required by the kernel. * DLE: The Devito Loop Engine will perform various loop-level optimizations to improve runtime performance. Note : The argument subs=model.spacing_map causes the operator to substitute values for our current grid spacing into the expressions before code generation. This reduces the number of floating point operations executed by the kernel by pre-evaluating certain coefficients. #NBVAL_IGNORE_OUTPUT from devito import Operator op = Operator ([ stencil ] + src_term + rec_term , subs = model . spacing_map ) Now we can execute the create operator for a number of timesteps. We specify the number of timesteps to compute with the keyword time and the timestep size with dt . #NBVAL_IGNORE_OUTPUT op ( time = time_range . num - 1 , dt = model . critical_dt ) Operator `Kernel` run in 0.02 s After running our operator kernel, the data associated with the receiver symbol rec.data has now been populated due to the interpolation expression we inserted into the operator. This allows us the visualize the shot record: #NBVAL_IGNORE_OUTPUT from seismic import plot_shotrecord plot_shotrecord ( rec . data , model , t0 , tn ) assert np . isclose ( np . linalg . norm ( rec . data ), 450 , rtol = 10 )","title":"Devito operator and solve"},{"location":"tutorials/02_rtm/","text":"02 - Reverse Time Migration This notebook is the second in a series of tutorial highlighting various aspects of seismic inversion based on Devito operators. In this second example we aim to highlight the core ideas behind seismic inversion, where we create an image of the subsurface from field recorded data. This tutorial follows on the modelling tutorial and will reuse the modelling operator and velocity model. Imaging requirement Seismic imaging relies on two known parameters: Field data - or also called recorded data . This is a shot record corresponding to the true velocity model. In practice this data is acquired as described in the first tutorial. In order to simplify this tutorial we will generate synthetic field data by modelling it with the true velocity model . Background velocity model . This is a velocity model that has been obtained by processing and inverting the field data. We will look at this methods in the following tutorial as it relies on the method we are describing here. This velocity model is usually a smooth version of the true velocity model. Imaging computational setup In this tutorial, we will introduce the back-propagation operator. This operator simulates the adjoint wave-equation, that is a wave-equation solved in a reversed time order. This time reversal led to the naming of the method we present here, called Reverse Time Migration. The notion of adjoint in exploration geophysics is fundamental as most of the wave-equation based imaging and inversion methods rely on adjoint based optimization methods. Notes on the operators As we have already described the creation of a forward modelling operator, we will use a thin wrapper function instead. This wrapper is provided by a utility class called AcousticWaveSolver , which provides all the necessary operators for seismic modeling, imaging and inversion. The AcousticWaveSolver provides a more concise API for common wave propagation operators and caches the Devito Operator objects to avoid unnecessary recompilation. Operators introduced for the first time in this tutorial will be properly described. As before we initialize printing and import some utilities. We also raise the Devito log level to avoid excessive logging for repeated operator invocations. import numpy as np % matplotlib inline from devito import configuration configuration [ 'log-level' ] = 'WARNING' Computational considerations Seismic inversion algorithms are generally very computationally demanding and require a large amount of memory to store the forward wavefield. In order to keep this tutorial as lightweight as possible we are using a very simple velocity model that requires low temporal and spatial resolution. For a more realistic model, a second set of preset parameters for a reduced version of the 2D Marmousi data set [1] is provided below in comments. This can be run to create some more realistic subsurface images. However, this second preset is more computationally demanding and requires a slightly more powerful workstation. # Configure model presets from seismic import demo_model # Enable model presets here: preset = 'layers-isotropic' # A simple but cheap model (recommended) # preset = 'marmousi2d-isotropic' # A larger more realistic model # Standard preset with a simple two-layer model if preset == 'layers-isotropic' : def create_model ( grid = None ): return demo_model ( 'layers-isotropic' , origin = ( 0. , 0. ), shape = ( 101 , 101 ), spacing = ( 10. , 10. ), nbl = 20 , grid = grid , nlayers = 4 ) filter_sigma = ( 1 , 1 ) nshots = 21 nreceivers = 101 t0 = 0. tn = 1000. # Simulation last 1 second (1000 ms) f0 = 0.010 # Source peak frequency is 10Hz (0.010 kHz) # A more computationally demanding preset based on the 2D Marmousi model if preset == 'marmousi2d-isotropic' : def create_model ( grid = None ): return demo_model ( 'marmousi2d-isotropic' , data_path = '../../../../data/' , grid = grid , nbl = 20 ) filter_sigma = ( 6 , 6 ) nshots = 301 # Need good covergae in shots, one every two grid points nreceivers = 601 # One recevier every grid point t0 = 0. tn = 3500. # Simulation last 3.5 second (3500 ms) f0 = 0.025 # Source peak frequency is 25Hz (0.025 kHz) True and smooth velocity models First, we create the model data for the \"true\" model from a given demonstration preset. This model represents the subsurface topology for the purposes of this example and we will later use it to generate our synthetic data readings. We also generate a second model and apply a smoothing filter to it, which represents our initial model for the imaging algorithm. The perturbation between these two models can be thought of as the image we are trying to recover. #NBVAL_IGNORE_OUTPUT from seismic import plot_velocity , plot_perturbation from scipy import ndimage # Create true model from a preset model = create_model () # Create initial model and smooth the boundaries model0 = create_model ( grid = model . grid ) model0 . vp = ndimage . gaussian_filter ( model0 . vp . data , sigma = filter_sigma , order = 0 ) # Plot the true and initial model and the perturbation between them plot_velocity ( model ) plot_velocity ( model0 ) plot_perturbation ( model0 , model ) Acquisition geometry Next we define the positioning and the wave signal of our source, as well as the location of our receivers. To generate the wavelet for our source we require the discretized values of time that we are going to use to model a single \"shot\", which again depends on the grid spacing used in our model. For consistency this initial setup will look exactly as in the previous modelling tutorial, although we will vary the position of our source later on during the actual imaging algorithm. #NBVAL_IGNORE_OUTPUT # Define acquisition geometry: source from seismic import AcquisitionGeometry # First, position source centrally in all dimensions, then set depth src_coordinates = np . empty (( 1 , 2 )) src_coordinates [ 0 , :] = np . array ( model . domain_size ) * . 5 src_coordinates [ 0 , - 1 ] = 20. # Depth is 20m # Define acquisition geometry: receivers # Initialize receivers for synthetic and imaging data rec_coordinates = np . empty (( nreceivers , 2 )) rec_coordinates [:, 0 ] = np . linspace ( 0 , model . domain_size [ 0 ], num = nreceivers ) rec_coordinates [:, 1 ] = 30. # Geometry geometry = AcquisitionGeometry ( model , rec_coordinates , src_coordinates , t0 , tn , f0 =. 015 , src_type = 'Ricker' ) # We can plot the time signature to see the wavelet geometry . src . show () True and smooth data We can now generate the shot record (receiver readings) corresponding to our true and initial models. The difference between these two records will be the basis of the imaging procedure. For this purpose we will use the same forward modelling operator that was introduced in the previous tutorial, provided by the AcousticWaveSolver utility class. This object instantiates a set of pre-defined operators according to an initial definition of the acquisition geometry, consisting of source and receiver symbols. The solver objects caches the individual operators and provides a slightly more high-level API that allows us to invoke the modelling modelling operators from the initial tutorial in a single line. In the following cells we use this to generate shot data by only specifying the respective model symbol m to use, and the solver will create and return a new Receiver object the represents the readings at the previously defined receiver coordinates. # Compute synthetic data with forward operator from seismic.acoustic import AcousticWaveSolver solver = AcousticWaveSolver ( model , geometry , space_order = 4 ) true_d , _ , _ = solver . forward ( vp = model . vp ) # Compute initial data with forward operator smooth_d , _ , _ = solver . forward ( vp = model0 . vp ) #NBVAL_IGNORE_OUTPUT # Plot shot record for true and smooth velocity model and the difference from seismic import plot_shotrecord plot_shotrecord ( true_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data - true_d . data , model , t0 , tn ) Imaging with back-propagation As explained in the introduction of this tutorial, this method is based on back-propagation. Adjoint wave equation If we go back to the modelling part, we can rewrite the simulation as a linear system solve: \\begin{equation} \\mathbf{A}(\\mathbf{m}) \\mathbf{u} = \\mathbf{q} \\end{equation} \\begin{equation} \\mathbf{A}(\\mathbf{m}) \\mathbf{u} = \\mathbf{q} \\end{equation} where \\mathbf{m} \\mathbf{m} is the discretized square slowness, \\mathbf{q} \\mathbf{q} is the discretized source and \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) is the discretized wave-equation. The discretized wave-equation matricial representation is a lower triangular matrix that can be solve with forward substitution. The pointwise writing or the forward substitution leads to the time-stepping stencil. On a small problem one could form the matrix explicitly and transpose it to obtain the adjoint discrete wave-equation: \\begin{equation} \\mathbf{A}(\\mathbf{m})^T \\mathbf{v} = \\delta \\mathbf{d} \\end{equation} \\begin{equation} \\mathbf{A}(\\mathbf{m})^T \\mathbf{v} = \\delta \\mathbf{d} \\end{equation} where \\mathbf{v} \\mathbf{v} is the discrete adjoint wavefield and \\delta \\mathbf{d} \\delta \\mathbf{d} is the data residual defined as the difference between the field/observed data and the synthetic data \\mathbf{d}_s = \\mathbf{P}_r \\mathbf{u} \\mathbf{d}_s = \\mathbf{P}_r \\mathbf{u} . In our case we derive the discrete adjoint wave-equation from the discrete forward wave-equation to get its stencil. Imaging Wave-equation based imaging relies on one simple concept: If the background velocity model is cinematically correct, the forward wavefield \\mathbf{u} \\mathbf{u} and the adjoint wavefield \\mathbf{v} \\mathbf{v} meet at the reflectors position at zero time offset. The sum over time of the zero time-offset correlation of these two fields then creates an image of the subsurface. Mathematically this leads to the simple imaging condition: \\begin{equation} \\text{Image} = \\sum_{t=1}^{n_t} \\mathbf{u}[t] \\mathbf{v}[t] \\end{equation} \\begin{equation} \\text{Image} = \\sum_{t=1}^{n_t} \\mathbf{u}[t] \\mathbf{v}[t] \\end{equation} In the following tutorials we will describe a more advanced imaging condition that produces shaper and more accurate results. Operator We will now define the imaging operator that computes the adjoint wavefield \\mathbf{v} \\mathbf{v} and correlates it with the forward wavefield \\mathbf{u} \\mathbf{u} . This operator essentially consists of three components: * Stencil update of the adjoint wavefield v * Injection of the data residual at the adjoint source (forward receiver) location * Correlation of u and v to compute the image contribution at each timestep # Define gradient operator for imaging from devito import TimeFunction , Operator , Eq , solve from seismic import PointSource def ImagingOperator ( model , image ): # Define the wavefield with the size of the model and the time dimension v = TimeFunction ( name = 'v' , grid = model . grid , time_order = 2 , space_order = 4 ) u = TimeFunction ( name = 'u' , grid = model . grid , time_order = 2 , space_order = 4 , save = geometry . nt ) # Define the wave equation, but with a negated damping term eqn = model . m * v . dt2 - v . laplace + model . damp * v . dt . T # Use `solve` to rearrange the equation into a stencil expression stencil = Eq ( v . backward , solve ( eqn , v . backward )) # Define residual injection at the location of the forward receivers dt = model . critical_dt residual = PointSource ( name = 'residual' , grid = model . grid , time_range = geometry . time_axis , coordinates = geometry . rec_positions ) res_term = residual . inject ( field = v . backward , expr = residual * dt ** 2 / model . m ) # Correlate u and v for the current time step and add it to the image image_update = Eq ( image , image - u * v ) return Operator ([ stencil ] + res_term + [ image_update ], subs = model . spacing_map ) Implementation of the imaging loop As just explained, the forward wave-equation is solved forward in time while the adjoint wave-equation is solved in a reversed time order. Therefore, the correlation of these two fields over time requires to store one of the two fields. The computational procedure for imaging follows: Simulate the forward wave-equation with the background velocity model to get the synthetic data and save the full wavefield \\mathbf{u} \\mathbf{u} Compute the data residual Back-propagate the data residual and compute on the fly the image contribution at each time step. This procedure is applied to multiple source positions (shots) and summed to obtain the full image of the subsurface. We can first visualize the varying locations of the sources that we will use. #NBVAL_IGNORE_OUTPUT # Prepare the varying source locations source_locations = np . empty (( nshots , 2 ), dtype = np . float32 ) source_locations [:, 0 ] = np . linspace ( 0. , 1000 , num = nshots ) source_locations [:, 1 ] = 30. plot_velocity ( model , source = source_locations ) # Run imaging loop over shots from devito import Function # Create image symbol and instantiate the previously defined imaging operator image = Function ( name = 'image' , grid = model . grid ) op_imaging = ImagingOperator ( model , image ) for i in range ( nshots ): print ( 'Imaging source %d out of %d ' % ( i + 1 , nshots )) # Update source location geometry . src_positions [ 0 , :] = source_locations [ i , :] # Generate synthetic data from true model true_d , _ , _ = solver . forward ( vp = model . vp ) # Compute smooth data and full forward wavefield u0 smooth_d , u0 , _ = solver . forward ( vp = model0 . vp , save = True ) # Compute gradient from the data residual v = TimeFunction ( name = 'v' , grid = model . grid , time_order = 2 , space_order = 4 ) residual = smooth_d . data - true_d . data op_imaging ( u = u0 , v = v , vp = model0 . vp , dt = model0 . critical_dt , residual = residual ) Imaging source 1 out of 21 Imaging source 2 out of 21 Imaging source 3 out of 21 Imaging source 4 out of 21 Imaging source 5 out of 21 Imaging source 6 out of 21 Imaging source 7 out of 21 Imaging source 8 out of 21 Imaging source 9 out of 21 Imaging source 10 out of 21 Imaging source 11 out of 21 Imaging source 12 out of 21 Imaging source 13 out of 21 Imaging source 14 out of 21 Imaging source 15 out of 21 Imaging source 16 out of 21 Imaging source 17 out of 21 Imaging source 18 out of 21 Imaging source 19 out of 21 Imaging source 20 out of 21 Imaging source 21 out of 21 #NBVAL_IGNORE_OUTPUT from seismic import plot_image # Plot the inverted image plot_image ( image , diff = True , depth_scaling = True ) from devito import norm assert np . isclose ( norm ( image ), 1e7 , rtol = 1e1 ) And we have an image of the subsurface with a strong reflector at the original location. References [1] Versteeg, R.J. & Grau, G. (eds.) (1991): The Marmousi experience. Proc. EAGE workshop on Practical Aspects of Seismic Data Inversion (Copenhagen, 1990), Eur. Assoc. Explor. Geophysicists, Zeist.","title":"Acosutic RTM"},{"location":"tutorials/02_rtm/#02-reverse-time-migration","text":"This notebook is the second in a series of tutorial highlighting various aspects of seismic inversion based on Devito operators. In this second example we aim to highlight the core ideas behind seismic inversion, where we create an image of the subsurface from field recorded data. This tutorial follows on the modelling tutorial and will reuse the modelling operator and velocity model.","title":"02 - Reverse Time Migration"},{"location":"tutorials/02_rtm/#imaging-requirement","text":"Seismic imaging relies on two known parameters: Field data - or also called recorded data . This is a shot record corresponding to the true velocity model. In practice this data is acquired as described in the first tutorial. In order to simplify this tutorial we will generate synthetic field data by modelling it with the true velocity model . Background velocity model . This is a velocity model that has been obtained by processing and inverting the field data. We will look at this methods in the following tutorial as it relies on the method we are describing here. This velocity model is usually a smooth version of the true velocity model.","title":"Imaging requirement"},{"location":"tutorials/02_rtm/#imaging-computational-setup","text":"In this tutorial, we will introduce the back-propagation operator. This operator simulates the adjoint wave-equation, that is a wave-equation solved in a reversed time order. This time reversal led to the naming of the method we present here, called Reverse Time Migration. The notion of adjoint in exploration geophysics is fundamental as most of the wave-equation based imaging and inversion methods rely on adjoint based optimization methods. Notes on the operators As we have already described the creation of a forward modelling operator, we will use a thin wrapper function instead. This wrapper is provided by a utility class called AcousticWaveSolver , which provides all the necessary operators for seismic modeling, imaging and inversion. The AcousticWaveSolver provides a more concise API for common wave propagation operators and caches the Devito Operator objects to avoid unnecessary recompilation. Operators introduced for the first time in this tutorial will be properly described. As before we initialize printing and import some utilities. We also raise the Devito log level to avoid excessive logging for repeated operator invocations. import numpy as np % matplotlib inline from devito import configuration configuration [ 'log-level' ] = 'WARNING'","title":"Imaging computational setup"},{"location":"tutorials/02_rtm/#computational-considerations","text":"Seismic inversion algorithms are generally very computationally demanding and require a large amount of memory to store the forward wavefield. In order to keep this tutorial as lightweight as possible we are using a very simple velocity model that requires low temporal and spatial resolution. For a more realistic model, a second set of preset parameters for a reduced version of the 2D Marmousi data set [1] is provided below in comments. This can be run to create some more realistic subsurface images. However, this second preset is more computationally demanding and requires a slightly more powerful workstation. # Configure model presets from seismic import demo_model # Enable model presets here: preset = 'layers-isotropic' # A simple but cheap model (recommended) # preset = 'marmousi2d-isotropic' # A larger more realistic model # Standard preset with a simple two-layer model if preset == 'layers-isotropic' : def create_model ( grid = None ): return demo_model ( 'layers-isotropic' , origin = ( 0. , 0. ), shape = ( 101 , 101 ), spacing = ( 10. , 10. ), nbl = 20 , grid = grid , nlayers = 4 ) filter_sigma = ( 1 , 1 ) nshots = 21 nreceivers = 101 t0 = 0. tn = 1000. # Simulation last 1 second (1000 ms) f0 = 0.010 # Source peak frequency is 10Hz (0.010 kHz) # A more computationally demanding preset based on the 2D Marmousi model if preset == 'marmousi2d-isotropic' : def create_model ( grid = None ): return demo_model ( 'marmousi2d-isotropic' , data_path = '../../../../data/' , grid = grid , nbl = 20 ) filter_sigma = ( 6 , 6 ) nshots = 301 # Need good covergae in shots, one every two grid points nreceivers = 601 # One recevier every grid point t0 = 0. tn = 3500. # Simulation last 3.5 second (3500 ms) f0 = 0.025 # Source peak frequency is 25Hz (0.025 kHz)","title":"Computational considerations"},{"location":"tutorials/02_rtm/#true-and-smooth-velocity-models","text":"First, we create the model data for the \"true\" model from a given demonstration preset. This model represents the subsurface topology for the purposes of this example and we will later use it to generate our synthetic data readings. We also generate a second model and apply a smoothing filter to it, which represents our initial model for the imaging algorithm. The perturbation between these two models can be thought of as the image we are trying to recover. #NBVAL_IGNORE_OUTPUT from seismic import plot_velocity , plot_perturbation from scipy import ndimage # Create true model from a preset model = create_model () # Create initial model and smooth the boundaries model0 = create_model ( grid = model . grid ) model0 . vp = ndimage . gaussian_filter ( model0 . vp . data , sigma = filter_sigma , order = 0 ) # Plot the true and initial model and the perturbation between them plot_velocity ( model ) plot_velocity ( model0 ) plot_perturbation ( model0 , model )","title":"True and smooth velocity models"},{"location":"tutorials/02_rtm/#acquisition-geometry","text":"Next we define the positioning and the wave signal of our source, as well as the location of our receivers. To generate the wavelet for our source we require the discretized values of time that we are going to use to model a single \"shot\", which again depends on the grid spacing used in our model. For consistency this initial setup will look exactly as in the previous modelling tutorial, although we will vary the position of our source later on during the actual imaging algorithm. #NBVAL_IGNORE_OUTPUT # Define acquisition geometry: source from seismic import AcquisitionGeometry # First, position source centrally in all dimensions, then set depth src_coordinates = np . empty (( 1 , 2 )) src_coordinates [ 0 , :] = np . array ( model . domain_size ) * . 5 src_coordinates [ 0 , - 1 ] = 20. # Depth is 20m # Define acquisition geometry: receivers # Initialize receivers for synthetic and imaging data rec_coordinates = np . empty (( nreceivers , 2 )) rec_coordinates [:, 0 ] = np . linspace ( 0 , model . domain_size [ 0 ], num = nreceivers ) rec_coordinates [:, 1 ] = 30. # Geometry geometry = AcquisitionGeometry ( model , rec_coordinates , src_coordinates , t0 , tn , f0 =. 015 , src_type = 'Ricker' ) # We can plot the time signature to see the wavelet geometry . src . show ()","title":"Acquisition geometry"},{"location":"tutorials/02_rtm/#true-and-smooth-data","text":"We can now generate the shot record (receiver readings) corresponding to our true and initial models. The difference between these two records will be the basis of the imaging procedure. For this purpose we will use the same forward modelling operator that was introduced in the previous tutorial, provided by the AcousticWaveSolver utility class. This object instantiates a set of pre-defined operators according to an initial definition of the acquisition geometry, consisting of source and receiver symbols. The solver objects caches the individual operators and provides a slightly more high-level API that allows us to invoke the modelling modelling operators from the initial tutorial in a single line. In the following cells we use this to generate shot data by only specifying the respective model symbol m to use, and the solver will create and return a new Receiver object the represents the readings at the previously defined receiver coordinates. # Compute synthetic data with forward operator from seismic.acoustic import AcousticWaveSolver solver = AcousticWaveSolver ( model , geometry , space_order = 4 ) true_d , _ , _ = solver . forward ( vp = model . vp ) # Compute initial data with forward operator smooth_d , _ , _ = solver . forward ( vp = model0 . vp ) #NBVAL_IGNORE_OUTPUT # Plot shot record for true and smooth velocity model and the difference from seismic import plot_shotrecord plot_shotrecord ( true_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data - true_d . data , model , t0 , tn )","title":"True and smooth data"},{"location":"tutorials/02_rtm/#imaging-with-back-propagation","text":"As explained in the introduction of this tutorial, this method is based on back-propagation.","title":"Imaging with back-propagation"},{"location":"tutorials/02_rtm/#adjoint-wave-equation","text":"If we go back to the modelling part, we can rewrite the simulation as a linear system solve: \\begin{equation} \\mathbf{A}(\\mathbf{m}) \\mathbf{u} = \\mathbf{q} \\end{equation} \\begin{equation} \\mathbf{A}(\\mathbf{m}) \\mathbf{u} = \\mathbf{q} \\end{equation} where \\mathbf{m} \\mathbf{m} is the discretized square slowness, \\mathbf{q} \\mathbf{q} is the discretized source and \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) is the discretized wave-equation. The discretized wave-equation matricial representation is a lower triangular matrix that can be solve with forward substitution. The pointwise writing or the forward substitution leads to the time-stepping stencil. On a small problem one could form the matrix explicitly and transpose it to obtain the adjoint discrete wave-equation: \\begin{equation} \\mathbf{A}(\\mathbf{m})^T \\mathbf{v} = \\delta \\mathbf{d} \\end{equation} \\begin{equation} \\mathbf{A}(\\mathbf{m})^T \\mathbf{v} = \\delta \\mathbf{d} \\end{equation} where \\mathbf{v} \\mathbf{v} is the discrete adjoint wavefield and \\delta \\mathbf{d} \\delta \\mathbf{d} is the data residual defined as the difference between the field/observed data and the synthetic data \\mathbf{d}_s = \\mathbf{P}_r \\mathbf{u} \\mathbf{d}_s = \\mathbf{P}_r \\mathbf{u} . In our case we derive the discrete adjoint wave-equation from the discrete forward wave-equation to get its stencil.","title":"Adjoint wave equation"},{"location":"tutorials/02_rtm/#imaging","text":"Wave-equation based imaging relies on one simple concept: If the background velocity model is cinematically correct, the forward wavefield \\mathbf{u} \\mathbf{u} and the adjoint wavefield \\mathbf{v} \\mathbf{v} meet at the reflectors position at zero time offset. The sum over time of the zero time-offset correlation of these two fields then creates an image of the subsurface. Mathematically this leads to the simple imaging condition: \\begin{equation} \\text{Image} = \\sum_{t=1}^{n_t} \\mathbf{u}[t] \\mathbf{v}[t] \\end{equation} \\begin{equation} \\text{Image} = \\sum_{t=1}^{n_t} \\mathbf{u}[t] \\mathbf{v}[t] \\end{equation} In the following tutorials we will describe a more advanced imaging condition that produces shaper and more accurate results.","title":"Imaging"},{"location":"tutorials/02_rtm/#operator","text":"We will now define the imaging operator that computes the adjoint wavefield \\mathbf{v} \\mathbf{v} and correlates it with the forward wavefield \\mathbf{u} \\mathbf{u} . This operator essentially consists of three components: * Stencil update of the adjoint wavefield v * Injection of the data residual at the adjoint source (forward receiver) location * Correlation of u and v to compute the image contribution at each timestep # Define gradient operator for imaging from devito import TimeFunction , Operator , Eq , solve from seismic import PointSource def ImagingOperator ( model , image ): # Define the wavefield with the size of the model and the time dimension v = TimeFunction ( name = 'v' , grid = model . grid , time_order = 2 , space_order = 4 ) u = TimeFunction ( name = 'u' , grid = model . grid , time_order = 2 , space_order = 4 , save = geometry . nt ) # Define the wave equation, but with a negated damping term eqn = model . m * v . dt2 - v . laplace + model . damp * v . dt . T # Use `solve` to rearrange the equation into a stencil expression stencil = Eq ( v . backward , solve ( eqn , v . backward )) # Define residual injection at the location of the forward receivers dt = model . critical_dt residual = PointSource ( name = 'residual' , grid = model . grid , time_range = geometry . time_axis , coordinates = geometry . rec_positions ) res_term = residual . inject ( field = v . backward , expr = residual * dt ** 2 / model . m ) # Correlate u and v for the current time step and add it to the image image_update = Eq ( image , image - u * v ) return Operator ([ stencil ] + res_term + [ image_update ], subs = model . spacing_map )","title":"Operator"},{"location":"tutorials/02_rtm/#implementation-of-the-imaging-loop","text":"As just explained, the forward wave-equation is solved forward in time while the adjoint wave-equation is solved in a reversed time order. Therefore, the correlation of these two fields over time requires to store one of the two fields. The computational procedure for imaging follows: Simulate the forward wave-equation with the background velocity model to get the synthetic data and save the full wavefield \\mathbf{u} \\mathbf{u} Compute the data residual Back-propagate the data residual and compute on the fly the image contribution at each time step. This procedure is applied to multiple source positions (shots) and summed to obtain the full image of the subsurface. We can first visualize the varying locations of the sources that we will use. #NBVAL_IGNORE_OUTPUT # Prepare the varying source locations source_locations = np . empty (( nshots , 2 ), dtype = np . float32 ) source_locations [:, 0 ] = np . linspace ( 0. , 1000 , num = nshots ) source_locations [:, 1 ] = 30. plot_velocity ( model , source = source_locations ) # Run imaging loop over shots from devito import Function # Create image symbol and instantiate the previously defined imaging operator image = Function ( name = 'image' , grid = model . grid ) op_imaging = ImagingOperator ( model , image ) for i in range ( nshots ): print ( 'Imaging source %d out of %d ' % ( i + 1 , nshots )) # Update source location geometry . src_positions [ 0 , :] = source_locations [ i , :] # Generate synthetic data from true model true_d , _ , _ = solver . forward ( vp = model . vp ) # Compute smooth data and full forward wavefield u0 smooth_d , u0 , _ = solver . forward ( vp = model0 . vp , save = True ) # Compute gradient from the data residual v = TimeFunction ( name = 'v' , grid = model . grid , time_order = 2 , space_order = 4 ) residual = smooth_d . data - true_d . data op_imaging ( u = u0 , v = v , vp = model0 . vp , dt = model0 . critical_dt , residual = residual ) Imaging source 1 out of 21 Imaging source 2 out of 21 Imaging source 3 out of 21 Imaging source 4 out of 21 Imaging source 5 out of 21 Imaging source 6 out of 21 Imaging source 7 out of 21 Imaging source 8 out of 21 Imaging source 9 out of 21 Imaging source 10 out of 21 Imaging source 11 out of 21 Imaging source 12 out of 21 Imaging source 13 out of 21 Imaging source 14 out of 21 Imaging source 15 out of 21 Imaging source 16 out of 21 Imaging source 17 out of 21 Imaging source 18 out of 21 Imaging source 19 out of 21 Imaging source 20 out of 21 Imaging source 21 out of 21 #NBVAL_IGNORE_OUTPUT from seismic import plot_image # Plot the inverted image plot_image ( image , diff = True , depth_scaling = True ) from devito import norm assert np . isclose ( norm ( image ), 1e7 , rtol = 1e1 ) And we have an image of the subsurface with a strong reflector at the original location.","title":"Implementation of the imaging loop"},{"location":"tutorials/02_rtm/#references","text":"[1] Versteeg, R.J. & Grau, G. (eds.) (1991): The Marmousi experience. Proc. EAGE workshop on Practical Aspects of Seismic Data Inversion (Copenhagen, 1990), Eur. Assoc. Explor. Geophysicists, Zeist.","title":"References"},{"location":"tutorials/03_fwi/","text":"03 - Full-Waveform Inversion (FWI) This notebook is the third in a series of tutorial highlighting various aspects of seismic inversion based on Devito operators. In this second example we aim to highlight the core ideas behind seismic inversion, where we create an image of the subsurface from field recorded data. This tutorial follows on the modelling tutorial and will reuse the modelling and velocity model. Inversion requirement Seismic inversion relies on two known parameters: Field data - or also called recorded data . This is a shot record corresponding to the true velocity model. In practice this data is acquired as described in the first tutorial. In order to simplify this tutorial we will fake field data by modelling it with the true velocity model. Initial velocity model . This is a velocity model that has been obtained by processing the field data. This model is a rough and very smooth estimate of the velocity as an initial estimate for the inversion. This is a necessary requirement for any optimization (method). Inversion computational setup In this tutorial, we will introduce the gradient operator. This operator corresponds to the imaging condition introduced in the previous tutorial with some minor modifications that are defined by the objective function (also referred to in the tutorial series as the functional , f ) and its gradient, g . We will define these two terms in the tutorial too. Notes on the operators As we have already described the creation of a forward modelling operator, we will only call a wrapper function here. This wrapper already contains all the necessary operators for seismic modeling, imaging and inversion. Operators introduced for the first time in this tutorial will be properly described. import numpy as np % matplotlib inline from devito import configuration configuration [ 'log-level' ] = 'WARNING' Computational considerations As we will see, FWI is computationally extremely demanding, even more than RTM. To keep this tutorial as lightwight as possible we therefore again use a very small demonstration model. We also define here a few parameters for the final example runs that can be changed to modify the overall runtime of the tutorial. nshots = 9 # Number of shots to create gradient from nreceivers = 101 # Number of receiver locations per shot fwi_iterations = 5 # Number of outer FWI iterations True and smooth velocity models We will use a very simple model domain, consisting of a circle within a 2D domain. We will again use the \"true\" model to generate our synthetic shot data and use a \"smooth\" model as our initial guess. In this case the smooth model is very smooth indeed - it is simply a constant background velocity without any features. #NBVAL_IGNORE_OUTPUT from seismic import demo_model , plot_velocity , plot_perturbation # Define true and initial model shape = ( 101 , 101 ) # Number of grid point (nx, nz) spacing = ( 10. , 10. ) # Grid spacing in m. The domain size is now 1km by 1km origin = ( 0. , 0. ) # Need origin to define relative source and receiver locations model = demo_model ( 'circle-isotropic' , vp_circle = 3.0 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = 40 ) model0 = demo_model ( 'circle-isotropic' , vp_circle = 2.5 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = 40 , grid = model . grid ) plot_velocity ( model ) plot_velocity ( model0 ) plot_perturbation ( model0 , model ) Acquisition geometry In this tutorial, we will use the easiest case for inversion, namely a transmission experiment. The sources are located on one side of the model and the receivers on the other side. This allows to record most of the information necessary for inversion, as reflections usually lead to poor inversion results. #NBVAL_IGNORE_OUTPUT # Define acquisition geometry: source from seismic import AcquisitionGeometry t0 = 0. tn = 1000. f0 = 0.010 # First, position source centrally in all dimensions, then set depth src_coordinates = np . empty (( 1 , 2 )) src_coordinates [ 0 , :] = np . array ( model . domain_size ) * . 5 src_coordinates [ 0 , 0 ] = 20. # Depth is 20m # Define acquisition geometry: receivers # Initialize receivers for synthetic and imaging data rec_coordinates = np . empty (( nreceivers , 2 )) rec_coordinates [:, 1 ] = np . linspace ( 0 , model . domain_size [ 0 ], num = nreceivers ) rec_coordinates [:, 0 ] = 980. # Geometry geometry = AcquisitionGeometry ( model , rec_coordinates , src_coordinates , t0 , tn , f0 = f0 , src_type = 'Ricker' ) # We can plot the time signature to see the wavelet geometry . src . show () # Plot acquisition geometry plot_velocity ( model , source = geometry . src_positions , receiver = geometry . rec_positions [:: 4 , :]) True and smooth data We can generate shot records for the true and smoothed initial velocity models, since the difference between them will again form the basis of our imaging procedure. # Compute synthetic data with forward operator from seismic.acoustic import AcousticWaveSolver solver = AcousticWaveSolver ( model , geometry , space_order = 4 ) true_d , _ , _ = solver . forward ( vp = model . vp ) # Compute initial data with forward operator smooth_d , _ , _ = solver . forward ( vp = model0 . vp ) #NBVAL_IGNORE_OUTPUT from seismic import plot_shotrecord # Plot shot record for true and smooth velocity model and the difference plot_shotrecord ( true_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data - true_d . data , model , t0 , tn ) Full-Waveform Inversion Full-waveform inversion (FWI) aims to invert an accurate model of the discrete wave velocity, \\mathbf{c} \\mathbf{c} , or equivalently the square slowness of the wave, \\mathbf{m} = \\frac{1}{\\mathbf{c}^2} \\mathbf{m} = \\frac{1}{\\mathbf{c}^2} , from a given set of measurements of the pressure wavefield \\mathbf{u} \\mathbf{u} . This can be expressed as the following optimization problem [1, 2]: \\begin{aligned} \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\Phi_s(\\mathbf{m})&=\\frac{1}{2}\\left\\lVert\\mathbf{P}_r \\mathbf{u} - \\mathbf{d}\\right\\rVert_2^2 \\\\ \\mathbf{u} &= \\mathbf{A}(\\mathbf{m})^{-1} \\mathbf{P}_s^T \\mathbf{q}_s, \\end{aligned} \\begin{aligned} \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\Phi_s(\\mathbf{m})&=\\frac{1}{2}\\left\\lVert\\mathbf{P}_r \\mathbf{u} - \\mathbf{d}\\right\\rVert_2^2 \\\\ \\mathbf{u} &= \\mathbf{A}(\\mathbf{m})^{-1} \\mathbf{P}_s^T \\mathbf{q}_s, \\end{aligned} where \\mathbf{P}_r \\mathbf{P}_r is the sampling operator at the receiver locations, \\mathbf{P}_s^T \\mathbf{P}_s^T is the injection operator at the source locations, \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) is the operator representing the discretized wave equation matrix, \\mathbf{u} \\mathbf{u} is the discrete synthetic pressure wavefield, \\mathbf{q}_s \\mathbf{q}_s is the corresponding pressure source and \\mathbf{d} \\mathbf{d} is the measured data. It is worth noting that \\mathbf{m} \\mathbf{m} is the unknown in this formulation and that multiple implementations of the wave equation operator \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) are possible. We have already defined a concrete solver scheme for \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) in the first tutorial, including appropriate implementations of the sampling operator \\mathbf{P}_r \\mathbf{P}_r and source term \\mathbf{q}_s \\mathbf{q}_s . To solve this optimization problem using a gradient-based method, we use the adjoint-state method to evaluate the gradient \\nabla\\Phi_s(\\mathbf{m}) \\nabla\\Phi_s(\\mathbf{m}) : \\begin{align} \\nabla\\Phi_s(\\mathbf{m})=\\sum_{\\mathbf{t} =1}^{n_t}\\mathbf{u}[\\mathbf{t}] \\mathbf{v}_{tt}[\\mathbf{t}] =\\mathbf{J}^T\\delta\\mathbf{d}_s, \\end{align} \\begin{align} \\nabla\\Phi_s(\\mathbf{m})=\\sum_{\\mathbf{t} =1}^{n_t}\\mathbf{u}[\\mathbf{t}] \\mathbf{v}_{tt}[\\mathbf{t}] =\\mathbf{J}^T\\delta\\mathbf{d}_s, \\end{align} where n_t n_t is the number of computational time steps, \\delta\\mathbf{d}_s = \\left(\\mathbf{P}_r \\mathbf{u} - \\mathbf{d} \\right) \\delta\\mathbf{d}_s = \\left(\\mathbf{P}_r \\mathbf{u} - \\mathbf{d} \\right) is the data residual (difference between the measured data and the modelled data), \\mathbf{J} \\mathbf{J} is the Jacobian operator and \\mathbf{v}_{tt} \\mathbf{v}_{tt} is the second-order time derivative of the adjoint wavefield solving: \\begin{align} \\mathbf{A}^T(\\mathbf{m}) \\mathbf{v} = \\mathbf{P}_r^T \\delta\\mathbf{d}. \\end{align} \\begin{align} \\mathbf{A}^T(\\mathbf{m}) \\mathbf{v} = \\mathbf{P}_r^T \\delta\\mathbf{d}. \\end{align} We see that the gradient of the FWI function is the previously defined imaging condition with an extra second-order time derivative. We will therefore reuse the operators defined previously inside a Devito wrapper. FWI gradient operator To compute a single gradient \\nabla\\Phi_s(\\mathbf{m}) \\nabla\\Phi_s(\\mathbf{m}) in our optimization workflow we again use solver.forward to compute the entire forward wavefield \\mathbf{u} \\mathbf{u} and a similar pre-defined gradient operator to compute the adjoint wavefield v . The gradient operator provided by our solver utility also computes the correlation between the wavefields, allowing us to encode a similar procedure to the previous imaging tutorial as our gradient calculation: Simulate the forward wavefield with the background velocity model to get the synthetic data and save the full wavefield \\mathbf{u} \\mathbf{u} Compute the data residual Back-propagate the data residual and compute on the fly the gradient contribution at each time step. This procedure is applied to multiple source positions and summed to obtain a gradient image of the subsurface. We again prepare the source locations for each shot and visualize them, before defining a single gradient computation over a number of shots as a single function. #NBVAL_IGNORE_OUTPUT # Prepare the varying source locations sources source_locations = np . empty (( nshots , 2 ), dtype = np . float32 ) source_locations [:, 0 ] = 30. source_locations [:, 1 ] = np . linspace ( 0. , 1000 , num = nshots ) plot_velocity ( model , source = source_locations ) # Create FWI gradient kernel from devito import Function , TimeFunction from seismic import Receiver import scipy def fwi_gradient ( vp_in ): # Create symbols to hold the gradient and residual grad = Function ( name = \"grad\" , grid = model . grid ) residual = Receiver ( name = 'rec' , grid = model . grid , time_range = geometry . time_axis , coordinates = geometry . rec_positions ) objective = 0. for i in range ( nshots ): # Update source location geometry . src_positions [ 0 , :] = source_locations [ i , :] # Generate synthetic data from true model true_d , _ , _ = solver . forward ( vp = model . vp ) # Compute smooth data and full forward wavefield u0 smooth_d , u0 , _ = solver . forward ( vp = vp_in , save = True ) # Compute gradient from data residual and update objective function residual . data [:] = smooth_d . data [:] - true_d . data [:] objective += . 5 * np . linalg . norm ( residual . data . flatten ()) ** 2 solver . gradient ( rec = residual , u = u0 , vp = vp_in , grad = grad ) return objective , - grad . data Having defined our FWI gradient procedure we can compute the initial iteration from our starting model. This allows us to visualize the gradient alongside the model perturbation and the effect of the gradient update on the model. # Compute gradient of initial model ff , update = fwi_gradient ( model0 . vp ) assert np . isclose ( ff , 57283 , rtol = 1e0 ) #NBVAL_IGNORE_OUTPUT from seismic import plot_image # Plot the FWI gradient plot_image ( update , cmap = \"jet\" ) # Plot the difference between the true and initial model. # This is not known in practice as only the initial model is provided. plot_image ( model0 . vp . data - model . vp . data , cmap = \"jet\" ) We see that the gradient and the true perturbation have the same sign, therefore, with an appropriate scaling factor, we will update the model in the correct direction. # Define bounding box constraints on the solution. def apply_box_constraint ( vp ): # Maximum possible 'realistic' velocity is 3.5 km/sec # Minimum possible 'realistic' velocity is 2 km/sec return np . clip ( vp , 2.0 , 3.5 ) #NBVAL_SKIP # Run FWI with gradient descent history = np . zeros (( fwi_iterations , 1 )) for i in range ( 0 , fwi_iterations ): # Compute the functional value and gradient for the current # model estimate phi , direction = fwi_gradient ( model0 . vp ) # Store the history of the functional values history [ i ] = phi # Artificial Step length for gradient descent # In practice this would be replaced by a Linesearch (Wolfe, ...) # that would guarantee functional decrease Phi(m-alpha g) <= epsilon Phi(m) # where epsilon is a minimum decrease constant alpha = . 05 / np . abs ( direction ) . max () # Update the model estimate and enforce minimum/maximum values model0 . vp = apply_box_constraint ( model0 . vp . data - alpha * direction ) # Log the progress made print ( 'Objective value is %f at iteration %d ' % ( phi , i + 1 )) Objective value is 57265.621845 at iteration 1 Objective value is 35755.544324 at iteration 2 Objective value is 20997.316985 at iteration 3 Objective value is 11545.768588 at iteration 4 Objective value is 5784.804134 at iteration 5 #NBVAL_IGNORE_OUTPUT # Plot inverted velocity model plot_velocity ( model0 ) #NBVAL_SKIP import matplotlib.pyplot as plt # Plot objective function decrease plt . figure () plt . loglog ( history ) plt . xlabel ( 'Iteration number' ) plt . ylabel ( 'Misift value Phi' ) plt . title ( 'Convergence' ) plt . show () References [1] Virieux, J. and Operto, S.: An overview of full-waveform inversion in exploration geophysics, GEOPHYSICS, 74, WCC1\u2013WCC26, doi:10.1190/1.3238367, http://library.seg.org/doi/abs/10.1190/1.3238367 , 2009. [2] Haber, E., Chung, M., and Herrmann, F. J.: An effective method for parameter estimation with PDE constraints with multiple right hand sides, SIAM Journal on Optimization, 22, http://dx.doi.org/10.1137/11081126X , 2012. This notebook is part of the tutorial \"Optimised Symbolic Finite Difference Computation with Devito\" presented at the Intel\u00ae HPC Developer Conference 2017.","title":"Acoustic FWI"},{"location":"tutorials/03_fwi/#03-full-waveform-inversion-fwi","text":"This notebook is the third in a series of tutorial highlighting various aspects of seismic inversion based on Devito operators. In this second example we aim to highlight the core ideas behind seismic inversion, where we create an image of the subsurface from field recorded data. This tutorial follows on the modelling tutorial and will reuse the modelling and velocity model.","title":"03 - Full-Waveform Inversion (FWI)"},{"location":"tutorials/03_fwi/#inversion-requirement","text":"Seismic inversion relies on two known parameters: Field data - or also called recorded data . This is a shot record corresponding to the true velocity model. In practice this data is acquired as described in the first tutorial. In order to simplify this tutorial we will fake field data by modelling it with the true velocity model. Initial velocity model . This is a velocity model that has been obtained by processing the field data. This model is a rough and very smooth estimate of the velocity as an initial estimate for the inversion. This is a necessary requirement for any optimization (method).","title":"Inversion requirement"},{"location":"tutorials/03_fwi/#inversion-computational-setup","text":"In this tutorial, we will introduce the gradient operator. This operator corresponds to the imaging condition introduced in the previous tutorial with some minor modifications that are defined by the objective function (also referred to in the tutorial series as the functional , f ) and its gradient, g . We will define these two terms in the tutorial too.","title":"Inversion computational setup"},{"location":"tutorials/03_fwi/#notes-on-the-operators","text":"As we have already described the creation of a forward modelling operator, we will only call a wrapper function here. This wrapper already contains all the necessary operators for seismic modeling, imaging and inversion. Operators introduced for the first time in this tutorial will be properly described. import numpy as np % matplotlib inline from devito import configuration configuration [ 'log-level' ] = 'WARNING'","title":"Notes on the operators"},{"location":"tutorials/03_fwi/#computational-considerations","text":"As we will see, FWI is computationally extremely demanding, even more than RTM. To keep this tutorial as lightwight as possible we therefore again use a very small demonstration model. We also define here a few parameters for the final example runs that can be changed to modify the overall runtime of the tutorial. nshots = 9 # Number of shots to create gradient from nreceivers = 101 # Number of receiver locations per shot fwi_iterations = 5 # Number of outer FWI iterations","title":"Computational considerations"},{"location":"tutorials/03_fwi/#true-and-smooth-velocity-models","text":"We will use a very simple model domain, consisting of a circle within a 2D domain. We will again use the \"true\" model to generate our synthetic shot data and use a \"smooth\" model as our initial guess. In this case the smooth model is very smooth indeed - it is simply a constant background velocity without any features. #NBVAL_IGNORE_OUTPUT from seismic import demo_model , plot_velocity , plot_perturbation # Define true and initial model shape = ( 101 , 101 ) # Number of grid point (nx, nz) spacing = ( 10. , 10. ) # Grid spacing in m. The domain size is now 1km by 1km origin = ( 0. , 0. ) # Need origin to define relative source and receiver locations model = demo_model ( 'circle-isotropic' , vp_circle = 3.0 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = 40 ) model0 = demo_model ( 'circle-isotropic' , vp_circle = 2.5 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = 40 , grid = model . grid ) plot_velocity ( model ) plot_velocity ( model0 ) plot_perturbation ( model0 , model )","title":"True and smooth velocity models"},{"location":"tutorials/03_fwi/#acquisition-geometry","text":"In this tutorial, we will use the easiest case for inversion, namely a transmission experiment. The sources are located on one side of the model and the receivers on the other side. This allows to record most of the information necessary for inversion, as reflections usually lead to poor inversion results. #NBVAL_IGNORE_OUTPUT # Define acquisition geometry: source from seismic import AcquisitionGeometry t0 = 0. tn = 1000. f0 = 0.010 # First, position source centrally in all dimensions, then set depth src_coordinates = np . empty (( 1 , 2 )) src_coordinates [ 0 , :] = np . array ( model . domain_size ) * . 5 src_coordinates [ 0 , 0 ] = 20. # Depth is 20m # Define acquisition geometry: receivers # Initialize receivers for synthetic and imaging data rec_coordinates = np . empty (( nreceivers , 2 )) rec_coordinates [:, 1 ] = np . linspace ( 0 , model . domain_size [ 0 ], num = nreceivers ) rec_coordinates [:, 0 ] = 980. # Geometry geometry = AcquisitionGeometry ( model , rec_coordinates , src_coordinates , t0 , tn , f0 = f0 , src_type = 'Ricker' ) # We can plot the time signature to see the wavelet geometry . src . show () # Plot acquisition geometry plot_velocity ( model , source = geometry . src_positions , receiver = geometry . rec_positions [:: 4 , :])","title":"Acquisition geometry"},{"location":"tutorials/03_fwi/#true-and-smooth-data","text":"We can generate shot records for the true and smoothed initial velocity models, since the difference between them will again form the basis of our imaging procedure. # Compute synthetic data with forward operator from seismic.acoustic import AcousticWaveSolver solver = AcousticWaveSolver ( model , geometry , space_order = 4 ) true_d , _ , _ = solver . forward ( vp = model . vp ) # Compute initial data with forward operator smooth_d , _ , _ = solver . forward ( vp = model0 . vp ) #NBVAL_IGNORE_OUTPUT from seismic import plot_shotrecord # Plot shot record for true and smooth velocity model and the difference plot_shotrecord ( true_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data - true_d . data , model , t0 , tn )","title":"True and smooth data"},{"location":"tutorials/03_fwi/#full-waveform-inversion","text":"Full-waveform inversion (FWI) aims to invert an accurate model of the discrete wave velocity, \\mathbf{c} \\mathbf{c} , or equivalently the square slowness of the wave, \\mathbf{m} = \\frac{1}{\\mathbf{c}^2} \\mathbf{m} = \\frac{1}{\\mathbf{c}^2} , from a given set of measurements of the pressure wavefield \\mathbf{u} \\mathbf{u} . This can be expressed as the following optimization problem [1, 2]: \\begin{aligned} \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\Phi_s(\\mathbf{m})&=\\frac{1}{2}\\left\\lVert\\mathbf{P}_r \\mathbf{u} - \\mathbf{d}\\right\\rVert_2^2 \\\\ \\mathbf{u} &= \\mathbf{A}(\\mathbf{m})^{-1} \\mathbf{P}_s^T \\mathbf{q}_s, \\end{aligned} \\begin{aligned} \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\Phi_s(\\mathbf{m})&=\\frac{1}{2}\\left\\lVert\\mathbf{P}_r \\mathbf{u} - \\mathbf{d}\\right\\rVert_2^2 \\\\ \\mathbf{u} &= \\mathbf{A}(\\mathbf{m})^{-1} \\mathbf{P}_s^T \\mathbf{q}_s, \\end{aligned} where \\mathbf{P}_r \\mathbf{P}_r is the sampling operator at the receiver locations, \\mathbf{P}_s^T \\mathbf{P}_s^T is the injection operator at the source locations, \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) is the operator representing the discretized wave equation matrix, \\mathbf{u} \\mathbf{u} is the discrete synthetic pressure wavefield, \\mathbf{q}_s \\mathbf{q}_s is the corresponding pressure source and \\mathbf{d} \\mathbf{d} is the measured data. It is worth noting that \\mathbf{m} \\mathbf{m} is the unknown in this formulation and that multiple implementations of the wave equation operator \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) are possible. We have already defined a concrete solver scheme for \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) in the first tutorial, including appropriate implementations of the sampling operator \\mathbf{P}_r \\mathbf{P}_r and source term \\mathbf{q}_s \\mathbf{q}_s . To solve this optimization problem using a gradient-based method, we use the adjoint-state method to evaluate the gradient \\nabla\\Phi_s(\\mathbf{m}) \\nabla\\Phi_s(\\mathbf{m}) : \\begin{align} \\nabla\\Phi_s(\\mathbf{m})=\\sum_{\\mathbf{t} =1}^{n_t}\\mathbf{u}[\\mathbf{t}] \\mathbf{v}_{tt}[\\mathbf{t}] =\\mathbf{J}^T\\delta\\mathbf{d}_s, \\end{align} \\begin{align} \\nabla\\Phi_s(\\mathbf{m})=\\sum_{\\mathbf{t} =1}^{n_t}\\mathbf{u}[\\mathbf{t}] \\mathbf{v}_{tt}[\\mathbf{t}] =\\mathbf{J}^T\\delta\\mathbf{d}_s, \\end{align} where n_t n_t is the number of computational time steps, \\delta\\mathbf{d}_s = \\left(\\mathbf{P}_r \\mathbf{u} - \\mathbf{d} \\right) \\delta\\mathbf{d}_s = \\left(\\mathbf{P}_r \\mathbf{u} - \\mathbf{d} \\right) is the data residual (difference between the measured data and the modelled data), \\mathbf{J} \\mathbf{J} is the Jacobian operator and \\mathbf{v}_{tt} \\mathbf{v}_{tt} is the second-order time derivative of the adjoint wavefield solving: \\begin{align} \\mathbf{A}^T(\\mathbf{m}) \\mathbf{v} = \\mathbf{P}_r^T \\delta\\mathbf{d}. \\end{align} \\begin{align} \\mathbf{A}^T(\\mathbf{m}) \\mathbf{v} = \\mathbf{P}_r^T \\delta\\mathbf{d}. \\end{align} We see that the gradient of the FWI function is the previously defined imaging condition with an extra second-order time derivative. We will therefore reuse the operators defined previously inside a Devito wrapper.","title":"Full-Waveform Inversion"},{"location":"tutorials/03_fwi/#fwi-gradient-operator","text":"To compute a single gradient \\nabla\\Phi_s(\\mathbf{m}) \\nabla\\Phi_s(\\mathbf{m}) in our optimization workflow we again use solver.forward to compute the entire forward wavefield \\mathbf{u} \\mathbf{u} and a similar pre-defined gradient operator to compute the adjoint wavefield v . The gradient operator provided by our solver utility also computes the correlation between the wavefields, allowing us to encode a similar procedure to the previous imaging tutorial as our gradient calculation: Simulate the forward wavefield with the background velocity model to get the synthetic data and save the full wavefield \\mathbf{u} \\mathbf{u} Compute the data residual Back-propagate the data residual and compute on the fly the gradient contribution at each time step. This procedure is applied to multiple source positions and summed to obtain a gradient image of the subsurface. We again prepare the source locations for each shot and visualize them, before defining a single gradient computation over a number of shots as a single function. #NBVAL_IGNORE_OUTPUT # Prepare the varying source locations sources source_locations = np . empty (( nshots , 2 ), dtype = np . float32 ) source_locations [:, 0 ] = 30. source_locations [:, 1 ] = np . linspace ( 0. , 1000 , num = nshots ) plot_velocity ( model , source = source_locations ) # Create FWI gradient kernel from devito import Function , TimeFunction from seismic import Receiver import scipy def fwi_gradient ( vp_in ): # Create symbols to hold the gradient and residual grad = Function ( name = \"grad\" , grid = model . grid ) residual = Receiver ( name = 'rec' , grid = model . grid , time_range = geometry . time_axis , coordinates = geometry . rec_positions ) objective = 0. for i in range ( nshots ): # Update source location geometry . src_positions [ 0 , :] = source_locations [ i , :] # Generate synthetic data from true model true_d , _ , _ = solver . forward ( vp = model . vp ) # Compute smooth data and full forward wavefield u0 smooth_d , u0 , _ = solver . forward ( vp = vp_in , save = True ) # Compute gradient from data residual and update objective function residual . data [:] = smooth_d . data [:] - true_d . data [:] objective += . 5 * np . linalg . norm ( residual . data . flatten ()) ** 2 solver . gradient ( rec = residual , u = u0 , vp = vp_in , grad = grad ) return objective , - grad . data Having defined our FWI gradient procedure we can compute the initial iteration from our starting model. This allows us to visualize the gradient alongside the model perturbation and the effect of the gradient update on the model. # Compute gradient of initial model ff , update = fwi_gradient ( model0 . vp ) assert np . isclose ( ff , 57283 , rtol = 1e0 ) #NBVAL_IGNORE_OUTPUT from seismic import plot_image # Plot the FWI gradient plot_image ( update , cmap = \"jet\" ) # Plot the difference between the true and initial model. # This is not known in practice as only the initial model is provided. plot_image ( model0 . vp . data - model . vp . data , cmap = \"jet\" ) We see that the gradient and the true perturbation have the same sign, therefore, with an appropriate scaling factor, we will update the model in the correct direction. # Define bounding box constraints on the solution. def apply_box_constraint ( vp ): # Maximum possible 'realistic' velocity is 3.5 km/sec # Minimum possible 'realistic' velocity is 2 km/sec return np . clip ( vp , 2.0 , 3.5 ) #NBVAL_SKIP # Run FWI with gradient descent history = np . zeros (( fwi_iterations , 1 )) for i in range ( 0 , fwi_iterations ): # Compute the functional value and gradient for the current # model estimate phi , direction = fwi_gradient ( model0 . vp ) # Store the history of the functional values history [ i ] = phi # Artificial Step length for gradient descent # In practice this would be replaced by a Linesearch (Wolfe, ...) # that would guarantee functional decrease Phi(m-alpha g) <= epsilon Phi(m) # where epsilon is a minimum decrease constant alpha = . 05 / np . abs ( direction ) . max () # Update the model estimate and enforce minimum/maximum values model0 . vp = apply_box_constraint ( model0 . vp . data - alpha * direction ) # Log the progress made print ( 'Objective value is %f at iteration %d ' % ( phi , i + 1 )) Objective value is 57265.621845 at iteration 1 Objective value is 35755.544324 at iteration 2 Objective value is 20997.316985 at iteration 3 Objective value is 11545.768588 at iteration 4 Objective value is 5784.804134 at iteration 5 #NBVAL_IGNORE_OUTPUT # Plot inverted velocity model plot_velocity ( model0 ) #NBVAL_SKIP import matplotlib.pyplot as plt # Plot objective function decrease plt . figure () plt . loglog ( history ) plt . xlabel ( 'Iteration number' ) plt . ylabel ( 'Misift value Phi' ) plt . title ( 'Convergence' ) plt . show ()","title":"FWI gradient operator"},{"location":"tutorials/03_fwi/#references","text":"[1] Virieux, J. and Operto, S.: An overview of full-waveform inversion in exploration geophysics, GEOPHYSICS, 74, WCC1\u2013WCC26, doi:10.1190/1.3238367, http://library.seg.org/doi/abs/10.1190/1.3238367 , 2009. [2] Haber, E., Chung, M., and Herrmann, F. J.: An effective method for parameter estimation with PDE constraints with multiple right hand sides, SIAM Journal on Optimization, 22, http://dx.doi.org/10.1137/11081126X , 2012. This notebook is part of the tutorial \"Optimised Symbolic Finite Difference Computation with Devito\" presented at the Intel\u00ae HPC Developer Conference 2017.","title":"References"},{"location":"tutorials/04_dask/","text":"04 - Full Waveform Inversion with Devito and Dask Introduction In this tutorial, we will build on the previous FWI tutorial and implement parallel versions of both forward modeling and FWI objective functions. Furthermore, we will show how our parallel FWI function can be passed to black-box third party optimization libraries, such as SciPy's optimize package, to access sophisticated optimization algorithms without having to implement them from scratch! To implement parallel versions of forward modeling and FWI, we will use Dask , a Python library for distributed computing based on parallel data structures and task-based programming. As computing multiple seismic shot records or gradients for subsequent source locations is an embarassingly parallel process, we will use Dask to dynamically distribute our workload to a pool of available workers and afterwards collect the results. The first part of this tutorial closely follows tutorial 3 and consists of reading the velocity model and setting up the acquisition geometry. Subsequently, we will implement serial versions of forward modeling and FWI objective functions and then show how we can use Dask to implement parallel versions of these functions. Finally, we will show how to write a wrapper that lets us pass our objective function to scipy's optimize package and how to run a small 2D FWI example using a limited-memory Quasi-Newton method Set up velocity models As before, we start by reading the true (i.e. unknown) velocity model, as well as the starting model for FWI. For our example, we once again use the 2D Camembert model with a transmission acquisition set up, which involves having sources on one side of the model and receivers on the other side. In reality, we obvisouly cannot know what the true velocity is, but here we use the true model to generate our own data (inverse crime alert!) and to compare it to our FWI result. from seismic import demo_model # Set up velocity model shape = ( 101 , 101 ) # Number of grid points (nx, nz). spacing = ( 10. , 10. ) # Grid spacing in m. The domain size is now 1km by 1km. origin = ( 0 , 0 ) # Need origin to define relative source and receiver locations. nbl = 40 # True model model1 = demo_model ( 'circle-isotropic' , vp_circle = 3.0 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = 40 ) # Initial model model0 = demo_model ( 'circle-isotropic' , vp_circle = 2.5 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = 40 , grid = model1 . grid ) Operator `initdamp` run in 0.03 s Operator `padfunc` run in 0.01 s Operator `initdamp` run in 0.01 s Operator `padfunc` run in 0.01 s Acquisition geometry For the acquisition geometry, we use the same setup as in tutorial 3 and position 5 source position on one side of the model, and an array of 101 receivers on the other side. Note that now our source coordinate array ( src_coordinates ) is a 5 x 2 array, containing the shot locations of all 5 source experiments. After defining the source/receiver coordinates, we set up individual geometry objects for both the observed data (using model ) and the predicted data (using model0 ). from seismic import AcquisitionGeometry import numpy as np # Set up acquisiton geometry t0 = 0. tn = 1000. f0 = 0.010 # Set up source geometry, but define 5 sources instead of just one. nsources = 5 src_coordinates = np . empty (( nsources , 2 )) src_coordinates [:, 1 ] = np . linspace ( spacing [ 0 ], model1 . domain_size [ 0 ] - spacing [ 0 ], num = nsources ) src_coordinates [:, 0 ] = 20. # Source depth is 20m # Initialize receivers for synthetic and imaging data nreceivers = 101 rec_coordinates = np . empty (( nreceivers , 2 )) rec_coordinates [:, 1 ] = np . linspace ( spacing [ 1 ], model1 . domain_size [ 0 ] - spacing [ 1 ], num = nreceivers ) rec_coordinates [:, 0 ] = 980. # Receiver depth # Set up geometry objects for observed and predicted data geometry1 = AcquisitionGeometry ( model1 , rec_coordinates , src_coordinates , t0 , tn , f0 = f0 , src_type = 'Ricker' ) geometry0 = AcquisitionGeometry ( model0 , rec_coordinates , src_coordinates , t0 , tn , f0 = f0 , src_type = 'Ricker' ) Forward modeling Before diving into FWI, we will start with forward modeling and show how we can use Dask to implement a parallel wrapper around a serial modeling function to compute seismic shot records for multiple source locations in parallel. First, we implement a forward modeling function for a single shot, which takes a geometry data structure as the only mandatory input argument. This function assumes that the geometry structure only contains a single source location. To solve the wave equation for the current shot location and model as specified in geometry , we use the AcousticSolver from previous tutorials, which is an abstract layer built on top of (generic) Devito objects. AcousticSolver contains Devito implementations of forward and adjoint wave equations, as well as Jacobians as specified in tutorials 1 and 2, so we don't have to re-implement these PDEs here. from seismic.acoustic import AcousticWaveSolver # Serial modeling function def forward_modeling_single_shot ( geometry , save = False , dt = 4.0 ): solver = AcousticWaveSolver ( geometry . model , geometry , space_order = 4 ) d_obs , u0 = solver . forward ( vp = geometry . model . vp , save = save )[ 0 : 2 ] return d_obs . resample ( dt ), u0 Parallelization with dask With our modeling function for a single shot record in place, we now implement our parallel version of our modeling function, which consists of a loop over all source locations. As the geometry object in forward_modeling_single_shot expects only a single source location, we set up a new geometry structure for the i-th source location to pass to our modeling function. However, rather than simpling calling the modeling function for single shots, we tell Dask to create a task for each source location and to distribute them to the available parallel workers. Dask returns a remote reference to the result on each worker called future . The wait statement tells our function to wait for all tasks to finish their computations, after which we collect the modeled shot records from the workers. # Parallel modeling function def forward_modeling_multi_shots ( geometry , save = False , dt = 4.0 ): futures = [] for i in range ( geometry . nsrc ): # Geometry for current shot geometry_i = AcquisitionGeometry ( geometry . model , geometry . rec_positions , geometry . src_positions [ i , :], geometry . t0 , geometry . tn , f0 = geometry . f0 , src_type = geometry . src_type ) # Call serial modeling function for each index futures . append ( client . submit ( forward_modeling_single_shot , geometry_i , save = save , dt = dt )) # Wait for all workers to finish and collect shots wait ( futures ) shots = [] for i in range ( geometry . nsrc ): shots . append ( futures [ i ] . result ()[ 0 ]) return shots We can use this parallel modeling function to generate our own observed data set, which we will subsequently use for our FWI example. In reality, we would instead read our observed data from a SEG-Y file. To compute the data in parallel, we launch a pool of workers on our local machine and then call the parallel modeling function: from distributed import Client , LocalCluster , wait # Start Dask cluster cluster = LocalCluster ( n_workers = nsources , death_timeout = 600 ) client = Client ( cluster ) # Compute observed data in parallel (inverse crime). In real life we would read the SEG-Y data here. d_obs = forward_modeling_multi_shots ( geometry1 , save = False ) The variable d_obs is a list of the 5 shots records and we can plot one of the shot records as follows: from seismic import plot_shotrecord # Plot shot no. 3 of 5 plot_shotrecord ( d_obs [ 2 ] . data , model1 , t0 , tn ) Parallel Full-Waveform Inversion Now that we know how to use Dask to implement a parallel loop around a (serial) modeling function for a single shot, we can apply the same concept to an FWI objective function, which computes the FWI function value and gradient for a given geometry and observed shot record. This function follows largely the structure in tutorial 3 and involves computing the predicted data and backpropagating the residual to compute the gradient. As we do not want to update the velocity in the area of the absorbing boundaries, we only return the gradient on the (original) physical grid. from devito import Function from seismic import Receiver # Serial FWI objective function def fwi_objective_single_shot ( geometry , d_obs ): # Devito objects for gradient and data residual grad = Function ( name = \"grad\" , grid = geometry . model . grid ) residual = Receiver ( name = 'rec' , grid = geometry . model . grid , time_range = geometry . time_axis , coordinates = geometry . rec_positions ) solver = AcousticWaveSolver ( geometry . model , geometry , space_order = 4 ) # Predicted data and residual d_pred , u0 = solver . forward ( vp = geometry . model . vp , save = True )[ 0 : 2 ] residual . data [:] = d_pred . data [:] - d_obs . resample ( geometry . dt ) . data [:][ 0 : d_pred . data . shape [ 0 ], :] # Function value and gradient fval = . 5 * np . linalg . norm ( residual . data . flatten ()) ** 2 solver . gradient ( rec = residual , u = u0 , vp = geometry . model . vp , grad = grad ) # Convert to numpy array and remove absorbing boundaries grad_crop = np . array ( grad . data [:])[ geometry . model . nbl : - geometry . model . nbl , geometry . model . nbl : - geometry . model . nbl ] return fval , grad_crop As for the serial modeling function, we can call fwi_objective_single_shot with a geometry structure containing a single source location and a single observed shot record. Since we are interested in evaluating this function for multiple sources in parallel, we follow the strategy from our forward modeling example and implement a parallel loop over all shots, in which we create a task for each shot location. As before, we use Dask to create one task per shot location and evaluate the single-shot FWI objective function for each source. We wait for all computations to finish via wait(futures) and then we sum the function values and gradients from all workers. # Parallel FWI objective function def fwi_objective_multi_shots ( geometry , d_obs ): futures = [] for i in range ( geometry . nsrc ): # Geometry for current shot geometry_i = AcquisitionGeometry ( geometry . model , geometry . rec_positions , geometry . src_positions [ i , :], geometry . t0 , geometry . tn , f0 = geometry . f0 , src_type = geometry . src_type ) # Call serial FWI objective function for each shot location futures . append ( client . submit ( fwi_objective_single_shot , geometry_i , d_obs [ i ])) # Wait for all workers to finish and collect function values and gradients wait ( futures ) fval = 0.0 grad = np . zeros ( geometry . model . shape ) for i in range ( geometry . nsrc ): fval += futures [ i ] . result ()[ 0 ] grad += futures [ i ] . result ()[ 1 ] return fval , grad We can compute a single gradient of the FWI objective function for all shots by passing the geometry structure with the initial model to the objective function, as well as the observed data we generated earlier. # Compute FWI gradient for 5 shots f , g = fwi_objective_multi_shots ( geometry0 , d_obs ) The physical units of the gradient are s^2/km^2 s^2/km^2 , which means our gradient is an update of the squared slowness, rather than of the velocity. from seismic import plot_image # Plot g plot_image ( g . reshape ( model1 . shape ), cmap = \"cividis\" ) FWI with SciPy's L-BFGS With our parallel FWI objective function in place, we can in principle implement a wide range of gradient-based optimization algorithms for FWI, such as (stochastic) gradient descent or the nonlinear conjugate gradient method. However, many optimization algorithms, especially second order methods or algorithms for constrained optimization, are far from trivial to implement correctly from scratch. Luckily, many optimization libraries exist that we can adapt for our purposes. Here, we demonstrate how we can interface the scipy optimize package to run FWI with a limited-memory Quasi-Newton method. The scipy optimize package was not specifically designed for FWI, but this does not matter, as the library accepts any Python function that can be evaluated for a current model iterate x and returns the function value and gradient: f, g = objective_function(x, args) where f is function value and g is a one-dimensional numpy array of type float64 . Our parallel FWI function does not take the current model as an input argument, but instead expects a geometry structure and the observed data. Therefore, we have to write a little wrapper function called loss , which provides the input argument structure that is expected by scipy.optimize . The function takes the current model iteratve x (in squared slowness) as the first input argument and overwrites the current velocity in geometry with x . The gradient that is returned to scipy.optimize is converted to a numpy array of the required type ( float64 ). # Wrapper for scipy optimizer: x is current model in squared slowness [s^2/km^2] def loss ( x , geometry , d_obs ): # Convert x to velocity v_curr = 1.0 / np . sqrt ( x . reshape ( geometry . model . shape )) # Overwrite current velocity in geometry (don't update boundary region) geometry . model . vp . data [ geometry . model . nbl : - geometry . model . nbl , geometry . model . nbl : - geometry . model . nbl ] = v_curr # Evaluate objective function fval , grad = fwi_objective_multi_shots ( geometry , d_obs ) return fval , grad . flatten () . astype ( np . float64 ) # scipy expects double precision vector The scipy.optimize function also takes an optional callback function as an input argument, which can be used to keep track of the model error as a function of the iteration number. The callback function takes the current model iterate xk as the only input argument and computes the \\ell_2 \\ell_2 -misfit with the true model m : # Callback to track model error model_error = [] def fwi_callback ( xk ): vp = model1 . vp . data [ model1 . nbl : - model1 . nbl , model1 . nbl : - model1 . nbl ] m = 1.0 / ( vp . reshape ( - 1 ) . astype ( np . float64 )) ** 2 model_error . append ( np . linalg . norm (( xk - m ) / m )) The final preparation step before we can run our example, is the definition of box constraints for the velocity. At each iteration, the optimizer will project the current model iterate onto a feasible set of velocites as defined by the lower and upper bounds vmin and vmax . Box contraints allow us to prevent velocities from taking negative values or values that are too small or large for the stability criteria of our modeling stepping scheme. We define the box constraints for the velocity in km/s km/s and then convert them to squared slownesses. Furthermore, we define our initial guess m0 : # Box contraints vmin = 1.4 # do not allow velocities slower than water vmax = 4.0 bounds = [( 1.0 / vmax ** 2 , 1.0 / vmin ** 2 ) for _ in range ( np . prod ( model0 . shape ))] # in [s^2/km^2] # Initial guess v0 = model0 . vp . data [ model0 . nbl : - model0 . nbl , model0 . nbl : - model0 . nbl ] m0 = 1.0 / ( v0 . reshape ( - 1 ) . astype ( np . float64 )) ** 2 Finally, we run our 2D FWI example by calling the optimize.minimize function. The first input argument is the function to be minimized, which is our loss function. The second input argument is the starting value, which in our case is our initial model in squared slowness. The third input argument ( args ) are the arguments that are passed to the loss function other than x . For this example we use the L-BFGS algorithm, a limited-memory Quasi-Newton algorithm which builds up an approximation of the (inverse) hessian as we iterate. As our loss function returns the analytically computed gradient (as opposed to a numerically approximated gradient), we set the argument jac=True . Furthermore, we pass our callback function, box constraints and the maximum number of iterations (in this case 5) to the optimizer. from scipy import optimize # FWI with L-BFGS ftol = 0.1 maxiter = 5 result = optimize . minimize ( loss , m0 , args = ( geometry0 , d_obs ), method = 'L-BFGS-B' , jac = True , callback = fwi_callback , bounds = bounds , options = { 'ftol' : ftol , 'maxiter' : maxiter , 'disp' : True }) # Check termination criteria assert np . isclose ( result [ 'fun' ], ftol ) or result [ 'nit' ] == maxiter After either the maximum iteration number is reached or we find the minimum of the objective function within some tolerance level ftol , the optimizer returns a dictionary with the results and some additional information. We convert the result back to the velocity in km/s km/s and compare it to the true model: # Plot FWI result from seismic import plot_velocity vp = 1.0 / np . sqrt ( result [ 'x' ] . reshape ( model1 . shape )) plot_velocity ( model1 , cmap = \"cividis\" ) plot_image ( vp , vmin = 2.4 , vmax = 3.0 , cmap = \"cividis\" ) Looking at the model error as a function of the iteration number, we find that the error decays monotonically, as we would expect. import matplotlib.pyplot as plt # Plot model error plt . plot ( range ( 1 , maxiter + 1 ), model_error ); plt . xlabel ( 'Iteration number' ); plt . ylabel ( 'L2-model error' ) plt . show () Next steps In our current example, the master process keeps all shot records in memory and distributes the data to the workers in the parallel pool. This works perfectly fine for 2D and even small 3D examples, but quickly becomes infeasible for large-scale data sets. Therefore, an extension of our current code should include the following steps if we want to scale things up in the future: Write shot records directly to disk on each worker and return a file pointer back to the master process. Avoid sending the velocity model to the workers and read the model directly onto each worker. Include optimal checkpointing or domain-decomposition to address the memory bottleneck in the gradient computations. For scaling Devito to industry-scale problems and being able to work on data sets in the range of multiple terabytes, it is furthermore necessary to have a fast SEG-Y reader that is able to scan through large data volumes and efficiently access blocks of data such as single shot records. Furthermore, we need the SEG-Y reader to be able to interact with Devito and automatically set up geometry objects from the SEG-Y headers. For this purpose, please check out the Julia Devito Inversion framework (JUDI) , an extension built on top of Devito in the Julia programming language. JUDI consists on an abstract linear algebra framework and an interface to a fast and parallel SEG-Y reader called SEGYIO.jl , making it possible to: Scan large-scale data sets and create look-up tables from which shot records can be directly accessed through their byte locations (no need to loop over traces or read full files). Use look-up tables to automatically set up Devito objects with source and receiver coordinates. Work with out-of-core data containers that only read the data into memory when it is used for computations. You can find a full FWI example of the 3D Overthrust model using a 1.1 TB large data set on JUDI's Github page .","title":"Parallel acoustic FWI with Dask"},{"location":"tutorials/04_dask/#04-full-waveform-inversion-with-devito-and-dask","text":"","title":"04 - Full Waveform Inversion with Devito and Dask"},{"location":"tutorials/04_dask/#introduction","text":"In this tutorial, we will build on the previous FWI tutorial and implement parallel versions of both forward modeling and FWI objective functions. Furthermore, we will show how our parallel FWI function can be passed to black-box third party optimization libraries, such as SciPy's optimize package, to access sophisticated optimization algorithms without having to implement them from scratch! To implement parallel versions of forward modeling and FWI, we will use Dask , a Python library for distributed computing based on parallel data structures and task-based programming. As computing multiple seismic shot records or gradients for subsequent source locations is an embarassingly parallel process, we will use Dask to dynamically distribute our workload to a pool of available workers and afterwards collect the results. The first part of this tutorial closely follows tutorial 3 and consists of reading the velocity model and setting up the acquisition geometry. Subsequently, we will implement serial versions of forward modeling and FWI objective functions and then show how we can use Dask to implement parallel versions of these functions. Finally, we will show how to write a wrapper that lets us pass our objective function to scipy's optimize package and how to run a small 2D FWI example using a limited-memory Quasi-Newton method","title":"Introduction"},{"location":"tutorials/04_dask/#set-up-velocity-models","text":"As before, we start by reading the true (i.e. unknown) velocity model, as well as the starting model for FWI. For our example, we once again use the 2D Camembert model with a transmission acquisition set up, which involves having sources on one side of the model and receivers on the other side. In reality, we obvisouly cannot know what the true velocity is, but here we use the true model to generate our own data (inverse crime alert!) and to compare it to our FWI result. from seismic import demo_model # Set up velocity model shape = ( 101 , 101 ) # Number of grid points (nx, nz). spacing = ( 10. , 10. ) # Grid spacing in m. The domain size is now 1km by 1km. origin = ( 0 , 0 ) # Need origin to define relative source and receiver locations. nbl = 40 # True model model1 = demo_model ( 'circle-isotropic' , vp_circle = 3.0 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = 40 ) # Initial model model0 = demo_model ( 'circle-isotropic' , vp_circle = 2.5 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = 40 , grid = model1 . grid ) Operator `initdamp` run in 0.03 s Operator `padfunc` run in 0.01 s Operator `initdamp` run in 0.01 s Operator `padfunc` run in 0.01 s","title":"Set up velocity models"},{"location":"tutorials/04_dask/#acquisition-geometry","text":"For the acquisition geometry, we use the same setup as in tutorial 3 and position 5 source position on one side of the model, and an array of 101 receivers on the other side. Note that now our source coordinate array ( src_coordinates ) is a 5 x 2 array, containing the shot locations of all 5 source experiments. After defining the source/receiver coordinates, we set up individual geometry objects for both the observed data (using model ) and the predicted data (using model0 ). from seismic import AcquisitionGeometry import numpy as np # Set up acquisiton geometry t0 = 0. tn = 1000. f0 = 0.010 # Set up source geometry, but define 5 sources instead of just one. nsources = 5 src_coordinates = np . empty (( nsources , 2 )) src_coordinates [:, 1 ] = np . linspace ( spacing [ 0 ], model1 . domain_size [ 0 ] - spacing [ 0 ], num = nsources ) src_coordinates [:, 0 ] = 20. # Source depth is 20m # Initialize receivers for synthetic and imaging data nreceivers = 101 rec_coordinates = np . empty (( nreceivers , 2 )) rec_coordinates [:, 1 ] = np . linspace ( spacing [ 1 ], model1 . domain_size [ 0 ] - spacing [ 1 ], num = nreceivers ) rec_coordinates [:, 0 ] = 980. # Receiver depth # Set up geometry objects for observed and predicted data geometry1 = AcquisitionGeometry ( model1 , rec_coordinates , src_coordinates , t0 , tn , f0 = f0 , src_type = 'Ricker' ) geometry0 = AcquisitionGeometry ( model0 , rec_coordinates , src_coordinates , t0 , tn , f0 = f0 , src_type = 'Ricker' )","title":"Acquisition geometry"},{"location":"tutorials/04_dask/#forward-modeling","text":"Before diving into FWI, we will start with forward modeling and show how we can use Dask to implement a parallel wrapper around a serial modeling function to compute seismic shot records for multiple source locations in parallel. First, we implement a forward modeling function for a single shot, which takes a geometry data structure as the only mandatory input argument. This function assumes that the geometry structure only contains a single source location. To solve the wave equation for the current shot location and model as specified in geometry , we use the AcousticSolver from previous tutorials, which is an abstract layer built on top of (generic) Devito objects. AcousticSolver contains Devito implementations of forward and adjoint wave equations, as well as Jacobians as specified in tutorials 1 and 2, so we don't have to re-implement these PDEs here. from seismic.acoustic import AcousticWaveSolver # Serial modeling function def forward_modeling_single_shot ( geometry , save = False , dt = 4.0 ): solver = AcousticWaveSolver ( geometry . model , geometry , space_order = 4 ) d_obs , u0 = solver . forward ( vp = geometry . model . vp , save = save )[ 0 : 2 ] return d_obs . resample ( dt ), u0","title":"Forward modeling"},{"location":"tutorials/04_dask/#parallelization-with-dask","text":"With our modeling function for a single shot record in place, we now implement our parallel version of our modeling function, which consists of a loop over all source locations. As the geometry object in forward_modeling_single_shot expects only a single source location, we set up a new geometry structure for the i-th source location to pass to our modeling function. However, rather than simpling calling the modeling function for single shots, we tell Dask to create a task for each source location and to distribute them to the available parallel workers. Dask returns a remote reference to the result on each worker called future . The wait statement tells our function to wait for all tasks to finish their computations, after which we collect the modeled shot records from the workers. # Parallel modeling function def forward_modeling_multi_shots ( geometry , save = False , dt = 4.0 ): futures = [] for i in range ( geometry . nsrc ): # Geometry for current shot geometry_i = AcquisitionGeometry ( geometry . model , geometry . rec_positions , geometry . src_positions [ i , :], geometry . t0 , geometry . tn , f0 = geometry . f0 , src_type = geometry . src_type ) # Call serial modeling function for each index futures . append ( client . submit ( forward_modeling_single_shot , geometry_i , save = save , dt = dt )) # Wait for all workers to finish and collect shots wait ( futures ) shots = [] for i in range ( geometry . nsrc ): shots . append ( futures [ i ] . result ()[ 0 ]) return shots We can use this parallel modeling function to generate our own observed data set, which we will subsequently use for our FWI example. In reality, we would instead read our observed data from a SEG-Y file. To compute the data in parallel, we launch a pool of workers on our local machine and then call the parallel modeling function: from distributed import Client , LocalCluster , wait # Start Dask cluster cluster = LocalCluster ( n_workers = nsources , death_timeout = 600 ) client = Client ( cluster ) # Compute observed data in parallel (inverse crime). In real life we would read the SEG-Y data here. d_obs = forward_modeling_multi_shots ( geometry1 , save = False ) The variable d_obs is a list of the 5 shots records and we can plot one of the shot records as follows: from seismic import plot_shotrecord # Plot shot no. 3 of 5 plot_shotrecord ( d_obs [ 2 ] . data , model1 , t0 , tn )","title":"Parallelization with dask"},{"location":"tutorials/04_dask/#parallel-full-waveform-inversion","text":"Now that we know how to use Dask to implement a parallel loop around a (serial) modeling function for a single shot, we can apply the same concept to an FWI objective function, which computes the FWI function value and gradient for a given geometry and observed shot record. This function follows largely the structure in tutorial 3 and involves computing the predicted data and backpropagating the residual to compute the gradient. As we do not want to update the velocity in the area of the absorbing boundaries, we only return the gradient on the (original) physical grid. from devito import Function from seismic import Receiver # Serial FWI objective function def fwi_objective_single_shot ( geometry , d_obs ): # Devito objects for gradient and data residual grad = Function ( name = \"grad\" , grid = geometry . model . grid ) residual = Receiver ( name = 'rec' , grid = geometry . model . grid , time_range = geometry . time_axis , coordinates = geometry . rec_positions ) solver = AcousticWaveSolver ( geometry . model , geometry , space_order = 4 ) # Predicted data and residual d_pred , u0 = solver . forward ( vp = geometry . model . vp , save = True )[ 0 : 2 ] residual . data [:] = d_pred . data [:] - d_obs . resample ( geometry . dt ) . data [:][ 0 : d_pred . data . shape [ 0 ], :] # Function value and gradient fval = . 5 * np . linalg . norm ( residual . data . flatten ()) ** 2 solver . gradient ( rec = residual , u = u0 , vp = geometry . model . vp , grad = grad ) # Convert to numpy array and remove absorbing boundaries grad_crop = np . array ( grad . data [:])[ geometry . model . nbl : - geometry . model . nbl , geometry . model . nbl : - geometry . model . nbl ] return fval , grad_crop As for the serial modeling function, we can call fwi_objective_single_shot with a geometry structure containing a single source location and a single observed shot record. Since we are interested in evaluating this function for multiple sources in parallel, we follow the strategy from our forward modeling example and implement a parallel loop over all shots, in which we create a task for each shot location. As before, we use Dask to create one task per shot location and evaluate the single-shot FWI objective function for each source. We wait for all computations to finish via wait(futures) and then we sum the function values and gradients from all workers. # Parallel FWI objective function def fwi_objective_multi_shots ( geometry , d_obs ): futures = [] for i in range ( geometry . nsrc ): # Geometry for current shot geometry_i = AcquisitionGeometry ( geometry . model , geometry . rec_positions , geometry . src_positions [ i , :], geometry . t0 , geometry . tn , f0 = geometry . f0 , src_type = geometry . src_type ) # Call serial FWI objective function for each shot location futures . append ( client . submit ( fwi_objective_single_shot , geometry_i , d_obs [ i ])) # Wait for all workers to finish and collect function values and gradients wait ( futures ) fval = 0.0 grad = np . zeros ( geometry . model . shape ) for i in range ( geometry . nsrc ): fval += futures [ i ] . result ()[ 0 ] grad += futures [ i ] . result ()[ 1 ] return fval , grad We can compute a single gradient of the FWI objective function for all shots by passing the geometry structure with the initial model to the objective function, as well as the observed data we generated earlier. # Compute FWI gradient for 5 shots f , g = fwi_objective_multi_shots ( geometry0 , d_obs ) The physical units of the gradient are s^2/km^2 s^2/km^2 , which means our gradient is an update of the squared slowness, rather than of the velocity. from seismic import plot_image # Plot g plot_image ( g . reshape ( model1 . shape ), cmap = \"cividis\" )","title":"Parallel Full-Waveform Inversion"},{"location":"tutorials/04_dask/#fwi-with-scipys-l-bfgs","text":"With our parallel FWI objective function in place, we can in principle implement a wide range of gradient-based optimization algorithms for FWI, such as (stochastic) gradient descent or the nonlinear conjugate gradient method. However, many optimization algorithms, especially second order methods or algorithms for constrained optimization, are far from trivial to implement correctly from scratch. Luckily, many optimization libraries exist that we can adapt for our purposes. Here, we demonstrate how we can interface the scipy optimize package to run FWI with a limited-memory Quasi-Newton method. The scipy optimize package was not specifically designed for FWI, but this does not matter, as the library accepts any Python function that can be evaluated for a current model iterate x and returns the function value and gradient: f, g = objective_function(x, args) where f is function value and g is a one-dimensional numpy array of type float64 . Our parallel FWI function does not take the current model as an input argument, but instead expects a geometry structure and the observed data. Therefore, we have to write a little wrapper function called loss , which provides the input argument structure that is expected by scipy.optimize . The function takes the current model iteratve x (in squared slowness) as the first input argument and overwrites the current velocity in geometry with x . The gradient that is returned to scipy.optimize is converted to a numpy array of the required type ( float64 ). # Wrapper for scipy optimizer: x is current model in squared slowness [s^2/km^2] def loss ( x , geometry , d_obs ): # Convert x to velocity v_curr = 1.0 / np . sqrt ( x . reshape ( geometry . model . shape )) # Overwrite current velocity in geometry (don't update boundary region) geometry . model . vp . data [ geometry . model . nbl : - geometry . model . nbl , geometry . model . nbl : - geometry . model . nbl ] = v_curr # Evaluate objective function fval , grad = fwi_objective_multi_shots ( geometry , d_obs ) return fval , grad . flatten () . astype ( np . float64 ) # scipy expects double precision vector The scipy.optimize function also takes an optional callback function as an input argument, which can be used to keep track of the model error as a function of the iteration number. The callback function takes the current model iterate xk as the only input argument and computes the \\ell_2 \\ell_2 -misfit with the true model m : # Callback to track model error model_error = [] def fwi_callback ( xk ): vp = model1 . vp . data [ model1 . nbl : - model1 . nbl , model1 . nbl : - model1 . nbl ] m = 1.0 / ( vp . reshape ( - 1 ) . astype ( np . float64 )) ** 2 model_error . append ( np . linalg . norm (( xk - m ) / m )) The final preparation step before we can run our example, is the definition of box constraints for the velocity. At each iteration, the optimizer will project the current model iterate onto a feasible set of velocites as defined by the lower and upper bounds vmin and vmax . Box contraints allow us to prevent velocities from taking negative values or values that are too small or large for the stability criteria of our modeling stepping scheme. We define the box constraints for the velocity in km/s km/s and then convert them to squared slownesses. Furthermore, we define our initial guess m0 : # Box contraints vmin = 1.4 # do not allow velocities slower than water vmax = 4.0 bounds = [( 1.0 / vmax ** 2 , 1.0 / vmin ** 2 ) for _ in range ( np . prod ( model0 . shape ))] # in [s^2/km^2] # Initial guess v0 = model0 . vp . data [ model0 . nbl : - model0 . nbl , model0 . nbl : - model0 . nbl ] m0 = 1.0 / ( v0 . reshape ( - 1 ) . astype ( np . float64 )) ** 2 Finally, we run our 2D FWI example by calling the optimize.minimize function. The first input argument is the function to be minimized, which is our loss function. The second input argument is the starting value, which in our case is our initial model in squared slowness. The third input argument ( args ) are the arguments that are passed to the loss function other than x . For this example we use the L-BFGS algorithm, a limited-memory Quasi-Newton algorithm which builds up an approximation of the (inverse) hessian as we iterate. As our loss function returns the analytically computed gradient (as opposed to a numerically approximated gradient), we set the argument jac=True . Furthermore, we pass our callback function, box constraints and the maximum number of iterations (in this case 5) to the optimizer. from scipy import optimize # FWI with L-BFGS ftol = 0.1 maxiter = 5 result = optimize . minimize ( loss , m0 , args = ( geometry0 , d_obs ), method = 'L-BFGS-B' , jac = True , callback = fwi_callback , bounds = bounds , options = { 'ftol' : ftol , 'maxiter' : maxiter , 'disp' : True }) # Check termination criteria assert np . isclose ( result [ 'fun' ], ftol ) or result [ 'nit' ] == maxiter After either the maximum iteration number is reached or we find the minimum of the objective function within some tolerance level ftol , the optimizer returns a dictionary with the results and some additional information. We convert the result back to the velocity in km/s km/s and compare it to the true model: # Plot FWI result from seismic import plot_velocity vp = 1.0 / np . sqrt ( result [ 'x' ] . reshape ( model1 . shape )) plot_velocity ( model1 , cmap = \"cividis\" ) plot_image ( vp , vmin = 2.4 , vmax = 3.0 , cmap = \"cividis\" ) Looking at the model error as a function of the iteration number, we find that the error decays monotonically, as we would expect. import matplotlib.pyplot as plt # Plot model error plt . plot ( range ( 1 , maxiter + 1 ), model_error ); plt . xlabel ( 'Iteration number' ); plt . ylabel ( 'L2-model error' ) plt . show ()","title":"FWI with SciPy's L-BFGS"},{"location":"tutorials/04_dask/#next-steps","text":"In our current example, the master process keeps all shot records in memory and distributes the data to the workers in the parallel pool. This works perfectly fine for 2D and even small 3D examples, but quickly becomes infeasible for large-scale data sets. Therefore, an extension of our current code should include the following steps if we want to scale things up in the future: Write shot records directly to disk on each worker and return a file pointer back to the master process. Avoid sending the velocity model to the workers and read the model directly onto each worker. Include optimal checkpointing or domain-decomposition to address the memory bottleneck in the gradient computations. For scaling Devito to industry-scale problems and being able to work on data sets in the range of multiple terabytes, it is furthermore necessary to have a fast SEG-Y reader that is able to scan through large data volumes and efficiently access blocks of data such as single shot records. Furthermore, we need the SEG-Y reader to be able to interact with Devito and automatically set up geometry objects from the SEG-Y headers. For this purpose, please check out the Julia Devito Inversion framework (JUDI) , an extension built on top of Devito in the Julia programming language. JUDI consists on an abstract linear algebra framework and an interface to a fast and parallel SEG-Y reader called SEGYIO.jl , making it possible to: Scan large-scale data sets and create look-up tables from which shot records can be directly accessed through their byte locations (no need to loop over traces or read full files). Use look-up tables to automatically set up Devito objects with source and receiver coordinates. Work with out-of-core data containers that only read the data into memory when it is used for computations. You can find a full FWI example of the 3D Overthrust model using a 1.1 TB large data set on JUDI's Github page .","title":"Next steps"},{"location":"tutorials/05_staggered_acoustic/","text":"05- Acoustic modeling with the first order velocity formulation In this tutorial, we introduce the use of staggered grid to solve the first order acoustic wave equation that couples a vectorial particle velocity and a scalar Pressure. Model We start, as in the previous tutorials, by setting up a Grid . from devito import * from seismic.source import WaveletSource , TimeAxis from seismic import plot_image import numpy as np from sympy import init_printing , latex init_printing ( use_latex = 'mathjax' ) # Initial grid: 1km x 1km, with spacing 100m extent = ( 2000. , 2000. ) shape = ( 81 , 81 ) x = SpaceDimension ( name = 'x' , spacing = Constant ( name = 'h_x' , value = extent [ 0 ] / ( shape [ 0 ] - 1 ))) z = SpaceDimension ( name = 'z' , spacing = Constant ( name = 'h_z' , value = extent [ 1 ] / ( shape [ 1 ] - 1 ))) grid = Grid ( extent = extent , shape = shape , dimensions = ( x , z )) First order acoustic wave equation The first order acoustic wave equation is defined as: \\begin{cases} & \\frac{d p(t, x, y)}{dt} = \\lambda \\nabla . v(t, x, y) \\\\ & \\frac{d v(t, x, y)}{dt} = \\frac{1}{\\rho} p(t, x, y) \\end{cases} \\begin{cases} & \\frac{d p(t, x, y)}{dt} = \\lambda \\nabla . v(t, x, y) \\\\ & \\frac{d v(t, x, y)}{dt} = \\frac{1}{\\rho} p(t, x, y) \\end{cases} where $ p(t, x)$ is the pressure, v(t, x, y) = (v_x(t, x, y), v_y(t, x, y) v(t, x, y) = (v_x(t, x, y), v_y(t, x, y) is the vector valued particle velocity and \\lambda, \\rho \\lambda, \\rho are the first Lame parameter ( \\lambda = \\rho * v_p^2 \\lambda = \\rho * v_p^2 with v_p v_p the sound velocity) and the density. class DGaussSource ( WaveletSource ): def wavelet ( self , f0 , t ): a = 0.004 return - 2. * a * ( t - 1. / f0 ) * np . exp ( - a * ( t - 1. / f0 ) ** 2 ) # Timestep size from Eq. 7 with V_p=6000. and dx=100 t0 , tn = 0. , 200. dt = 1e2 * ( 1. / np . sqrt ( 2. )) / 60. time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) src = DGaussSource ( name = 'src' , grid = grid , f0 = 0.01 , time_range = time_range ) src . coordinates . data [:] = [ 1000. , 1000. ] #NBVAL_SKIP src . show () # Now we create the velocity and pressure fields p = TimeFunction ( name = 'p' , grid = grid , staggered = NODE , space_order = 2 , time_order = 1 ) v = VectorTimeFunction ( name = 'v' , grid = grid , space_order = 2 , time_order = 1 ) from devito.finite_differences.operators import div , grad t = grid . stepping_dim time = grid . time_dim # We need some initial conditions V_p = 4.0 density = 1. ro = 1 / density * dt l2m = V_p * V_p * density * dt # The source injection term src_p = src . inject ( field = p . forward , expr = src ) # 2nd order acoustic according to fdelmoc u_v_2 = Eq ( v . forward , v + ro * grad ( p )) u_p_2 = Eq ( p . forward , p + l2m * div ( v . forward )) u_v_2 \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)}\\\\\\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},z \\right)} + 1.17851130197758 \\frac{\\partial}{\\partial x} p{\\left(t,x,z \\right)}\\\\\\operatorname{v_{z}}{\\left(t,x,z + \\frac{h_{z}}{2} \\right)} + 1.17851130197758 \\frac{\\partial}{\\partial z} p{\\left(t,x,z \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)}\\\\\\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},z \\right)} + 1.17851130197758 \\frac{\\partial}{\\partial x} p{\\left(t,x,z \\right)}\\\\\\operatorname{v_{z}}{\\left(t,x,z + \\frac{h_{z}}{2} \\right)} + 1.17851130197758 \\frac{\\partial}{\\partial z} p{\\left(t,x,z \\right)}\\end{matrix}\\right] u_p_2 \\displaystyle p{\\left(t + dt,x,z \\right)} = p{\\left(t,x,z \\right)} + 18.8561808316413 \\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)} + 18.8561808316413 \\frac{\\partial}{\\partial z} \\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)} \\displaystyle p{\\left(t + dt,x,z \\right)} = p{\\left(t,x,z \\right)} + 18.8561808316413 \\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)} + 18.8561808316413 \\frac{\\partial}{\\partial z} \\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)} op_2 = Operator ([ u_v_2 , u_p_2 ] + src_p ) #NBVAL_IGNORE_OUTPUT # Propagate the source op_2 ( time = src . time_range . num - 1 ) Operator `Kernel` run in 0.07 s #NBVAL_SKIP # Let's see what we got.... plot_image ( v [ 0 ] . data [ 0 ]) plot_image ( v [ 1 ] . data [ 0 ]) plot_image ( p . data [ 0 ]) norm_p = norm ( p ) assert np . isclose ( norm_p , . 35098 , atol = 1e-4 , rtol = 0 ) High order FD Similarly to the acoustic and scalar case, Devito handles any spatial discretization order trivially with a simple change at the Function definitio. We now compute the acoustic fields with a fourth order finite-difference scheme that will be less dispersive. # # 4th order acoustic according to fdelmoc # # Now we create the velocity and pressure fields p4 = TimeFunction ( name = 'p' , grid = grid , staggered = NODE , space_order = 4 , time_order = 1 ) v4 = VectorTimeFunction ( name = 'v' , grid = grid , space_order = 4 , time_order = 1 ) u_v_4 = Eq ( v4 . forward , v4 + ro * grad ( p4 )) u_p_4 = Eq ( p4 . forward , p4 + l2m * div ( v4 . forward )) #NBVAL_IGNORE_OUTPUT op_4 = Operator ([ u_v_4 , u_p_4 ] + src_p ) # Propagate the source op_4 ( time = src . time_range . num - 1 ) Operator `Kernel` run in 0.01 s #NBVAL_SKIP # Let's see what we got.... plot_image ( v4 [ 0 ] . data [ - 1 ]) plot_image ( v4 [ 1 ] . data [ - 1 ]) plot_image ( p4 . data [ - 1 ]) norm_p = norm ( p ) assert np . isclose ( norm_p , . 35098 , atol = 1e-4 , rtol = 0 )","title":"First order acoustic modeling"},{"location":"tutorials/05_staggered_acoustic/#05-acoustic-modeling-with-the-first-order-velocity-formulation","text":"In this tutorial, we introduce the use of staggered grid to solve the first order acoustic wave equation that couples a vectorial particle velocity and a scalar Pressure.","title":"05- Acoustic modeling with the first order velocity formulation"},{"location":"tutorials/05_staggered_acoustic/#model","text":"We start, as in the previous tutorials, by setting up a Grid . from devito import * from seismic.source import WaveletSource , TimeAxis from seismic import plot_image import numpy as np from sympy import init_printing , latex init_printing ( use_latex = 'mathjax' ) # Initial grid: 1km x 1km, with spacing 100m extent = ( 2000. , 2000. ) shape = ( 81 , 81 ) x = SpaceDimension ( name = 'x' , spacing = Constant ( name = 'h_x' , value = extent [ 0 ] / ( shape [ 0 ] - 1 ))) z = SpaceDimension ( name = 'z' , spacing = Constant ( name = 'h_z' , value = extent [ 1 ] / ( shape [ 1 ] - 1 ))) grid = Grid ( extent = extent , shape = shape , dimensions = ( x , z ))","title":"Model"},{"location":"tutorials/05_staggered_acoustic/#first-order-acoustic-wave-equation","text":"The first order acoustic wave equation is defined as: \\begin{cases} & \\frac{d p(t, x, y)}{dt} = \\lambda \\nabla . v(t, x, y) \\\\ & \\frac{d v(t, x, y)}{dt} = \\frac{1}{\\rho} p(t, x, y) \\end{cases} \\begin{cases} & \\frac{d p(t, x, y)}{dt} = \\lambda \\nabla . v(t, x, y) \\\\ & \\frac{d v(t, x, y)}{dt} = \\frac{1}{\\rho} p(t, x, y) \\end{cases} where $ p(t, x)$ is the pressure, v(t, x, y) = (v_x(t, x, y), v_y(t, x, y) v(t, x, y) = (v_x(t, x, y), v_y(t, x, y) is the vector valued particle velocity and \\lambda, \\rho \\lambda, \\rho are the first Lame parameter ( \\lambda = \\rho * v_p^2 \\lambda = \\rho * v_p^2 with v_p v_p the sound velocity) and the density. class DGaussSource ( WaveletSource ): def wavelet ( self , f0 , t ): a = 0.004 return - 2. * a * ( t - 1. / f0 ) * np . exp ( - a * ( t - 1. / f0 ) ** 2 ) # Timestep size from Eq. 7 with V_p=6000. and dx=100 t0 , tn = 0. , 200. dt = 1e2 * ( 1. / np . sqrt ( 2. )) / 60. time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) src = DGaussSource ( name = 'src' , grid = grid , f0 = 0.01 , time_range = time_range ) src . coordinates . data [:] = [ 1000. , 1000. ] #NBVAL_SKIP src . show () # Now we create the velocity and pressure fields p = TimeFunction ( name = 'p' , grid = grid , staggered = NODE , space_order = 2 , time_order = 1 ) v = VectorTimeFunction ( name = 'v' , grid = grid , space_order = 2 , time_order = 1 ) from devito.finite_differences.operators import div , grad t = grid . stepping_dim time = grid . time_dim # We need some initial conditions V_p = 4.0 density = 1. ro = 1 / density * dt l2m = V_p * V_p * density * dt # The source injection term src_p = src . inject ( field = p . forward , expr = src ) # 2nd order acoustic according to fdelmoc u_v_2 = Eq ( v . forward , v + ro * grad ( p )) u_p_2 = Eq ( p . forward , p + l2m * div ( v . forward )) u_v_2 \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)}\\\\\\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},z \\right)} + 1.17851130197758 \\frac{\\partial}{\\partial x} p{\\left(t,x,z \\right)}\\\\\\operatorname{v_{z}}{\\left(t,x,z + \\frac{h_{z}}{2} \\right)} + 1.17851130197758 \\frac{\\partial}{\\partial z} p{\\left(t,x,z \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)}\\\\\\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},z \\right)} + 1.17851130197758 \\frac{\\partial}{\\partial x} p{\\left(t,x,z \\right)}\\\\\\operatorname{v_{z}}{\\left(t,x,z + \\frac{h_{z}}{2} \\right)} + 1.17851130197758 \\frac{\\partial}{\\partial z} p{\\left(t,x,z \\right)}\\end{matrix}\\right] u_p_2 \\displaystyle p{\\left(t + dt,x,z \\right)} = p{\\left(t,x,z \\right)} + 18.8561808316413 \\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)} + 18.8561808316413 \\frac{\\partial}{\\partial z} \\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)} \\displaystyle p{\\left(t + dt,x,z \\right)} = p{\\left(t,x,z \\right)} + 18.8561808316413 \\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)} + 18.8561808316413 \\frac{\\partial}{\\partial z} \\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)} op_2 = Operator ([ u_v_2 , u_p_2 ] + src_p ) #NBVAL_IGNORE_OUTPUT # Propagate the source op_2 ( time = src . time_range . num - 1 ) Operator `Kernel` run in 0.07 s #NBVAL_SKIP # Let's see what we got.... plot_image ( v [ 0 ] . data [ 0 ]) plot_image ( v [ 1 ] . data [ 0 ]) plot_image ( p . data [ 0 ]) norm_p = norm ( p ) assert np . isclose ( norm_p , . 35098 , atol = 1e-4 , rtol = 0 )","title":"First order acoustic wave equation"},{"location":"tutorials/05_staggered_acoustic/#high-order-fd","text":"Similarly to the acoustic and scalar case, Devito handles any spatial discretization order trivially with a simple change at the Function definitio. We now compute the acoustic fields with a fourth order finite-difference scheme that will be less dispersive. # # 4th order acoustic according to fdelmoc # # Now we create the velocity and pressure fields p4 = TimeFunction ( name = 'p' , grid = grid , staggered = NODE , space_order = 4 , time_order = 1 ) v4 = VectorTimeFunction ( name = 'v' , grid = grid , space_order = 4 , time_order = 1 ) u_v_4 = Eq ( v4 . forward , v4 + ro * grad ( p4 )) u_p_4 = Eq ( p4 . forward , p4 + l2m * div ( v4 . forward )) #NBVAL_IGNORE_OUTPUT op_4 = Operator ([ u_v_4 , u_p_4 ] + src_p ) # Propagate the source op_4 ( time = src . time_range . num - 1 ) Operator `Kernel` run in 0.01 s #NBVAL_SKIP # Let's see what we got.... plot_image ( v4 [ 0 ] . data [ - 1 ]) plot_image ( v4 [ 1 ] . data [ - 1 ]) plot_image ( p4 . data [ - 1 ]) norm_p = norm ( p ) assert np . isclose ( norm_p , . 35098 , atol = 1e-4 , rtol = 0 )","title":"High order FD"},{"location":"tutorials/06_elastic/","text":"Elastic wave equation implementation on a staggered grid This is a first attempt at implemenenting the elastic wave equation as described in: [1] Jean Virieux (1986). \u201dP-SV wave propagation in heterogeneous media: Velocity\u2010stress finite\u2010difference method.\u201d GEOPHYSICS, 51(4), 889-901. https://doi.org/10.1190/1.1442147 The current version actually attempts to mirror the FDELMODC implementation by Jan Thorbecke: [2] https://janth.home.xs4all.nl/Software/fdelmodcManual.pdf Explosive source We will first attempt to replicate the explosive source test case described in [1], Figure 4. We start by defining the source signature g(t) g(t) , the derivative of a Gaussian pulse, given by Eq 4: g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} from devito import * from seismic.source import WaveletSource , RickerSource , GaborSource , TimeAxis from seismic import plot_image import numpy as np from sympy import init_printing , latex init_printing ( use_latex = 'mathjax' ) # Initial grid: 1km x 1km, with spacing 100m extent = ( 1500. , 1500. ) shape = ( 201 , 201 ) x = SpaceDimension ( name = 'x' , spacing = Constant ( name = 'h_x' , value = extent [ 0 ] / ( shape [ 0 ] - 1 ))) z = SpaceDimension ( name = 'z' , spacing = Constant ( name = 'h_z' , value = extent [ 1 ] / ( shape [ 1 ] - 1 ))) grid = Grid ( extent = extent , shape = shape , dimensions = ( x , z )) class DGaussSource ( WaveletSource ): def wavelet ( self , f0 , t ): a = 0.004 return - 2. * a * ( t - 1 / f0 ) * np . exp ( - a * ( t - 1 / f0 ) ** 2 ) # Timestep size from Eq. 7 with V_p=6000. and dx=100 t0 , tn = 0. , 300. dt = ( 10. / np . sqrt ( 2. )) / 6. time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) src = RickerSource ( name = 'src' , grid = grid , f0 = 0.01 , time_range = time_range ) src . coordinates . data [:] = [ 750. , 750. ] #NBVAL_SKIP src . show () # Now we create the velocity and pressure fields so = 2 v = VectorTimeFunction ( name = 'v' , grid = grid , space_order = so , time_order = 1 ) tau = TensorTimeFunction ( name = 't' , grid = grid , space_order = so , time_order = 1 ) # Now let's try and create the staggered updates t = grid . stepping_dim time = grid . time_dim # We need some initial conditions V_p = 2.0 V_s = 1.0 density = 1.8 # The source injection term src_xx = src . inject ( field = tau . forward [ 0 , 0 ], expr = src ) src_zz = src . inject ( field = tau . forward [ 1 , 1 ], expr = src ) # Thorbecke's parameter notation cp2 = V_p * V_p cs2 = V_s * V_s ro = 1 / density mu = cs2 * density l = ( cp2 * density - 2 * mu ) # fdelmodc reference implementation u_v = Eq ( v . forward , v + dt * ro * div ( tau )) u_t = Eq ( tau . forward , tau + dt * l * diag ( div ( v . forward )) + dt * mu * ( grad ( v . forward ) + grad ( v . forward ) . T )) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz ) u_v \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)}\\\\\\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)}\\\\\\operatorname{v_{z}}{\\left(t,x,z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{zz}}{\\left(t,x,z \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)}\\\\\\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)}\\\\\\operatorname{v_{z}}{\\left(t,x,z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{zz}}{\\left(t,x,z \\right)}\\end{matrix}\\right] #NBVAL_IGNORE_OUTPUT op () Operator `Kernel` run in 0.02 s #NBVAL_SKIP # Let's see what we got.... plot_image ( v [ 0 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( v [ 1 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 0 , 0 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 1 , 1 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 0 , 1 ] . data [ 0 ], cmap = \"seismic\" ) #NBVAL_IGNORE_OUTPUT assert np . isclose ( norm ( v [ 0 ]), 0.6285093 , atol = 1e-4 , rtol = 0 ) # Now that looks pretty! But let's do it again with a higher order... so = 12 v = VectorTimeFunction ( name = 'v' , grid = grid , space_order = so , time_order = 1 ) tau = TensorTimeFunction ( name = 't' , grid = grid , space_order = so , time_order = 1 ) # The source injection term src_xx = src . inject ( field = tau . forward [ 0 , 0 ], expr = src ) src_zz = src . inject ( field = tau . forward [ 1 , 1 ], expr = src ) # fdelmodc reference implementation u_v = Eq ( v . forward , v + dt * ro * div ( tau )) u_t = Eq ( tau . forward , tau + l * diag ( div ( v . forward )) + mu * ( grad ( v . forward ) + grad ( v . forward ) . T )) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz ) #NBVAL_IGNORE_OUTPUT v [ 0 ] . data . fill ( 0. ) v [ 1 ] . data . fill ( 0. ) tau [ 0 , 0 ] . data . fill ( 0. ) tau [ 0 , 1 ] . data . fill ( 0. ) tau [ 1 , 1 ] . data . fill ( 0. ) op () Operator `Kernel` run in 0.02 s #NBVAL_SKIP # Let's see what we got.... plot_image ( v [ 0 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( v [ 1 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 0 , 0 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 1 , 1 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 0 , 1 ] . data [ 0 ], cmap = \"seismic\" ) #NBVAL_IGNORE_OUTPUT assert np . isclose ( norm ( v [ 0 ]), 0.736816932 , atol = 1e-4 , rtol = 0 )","title":"Elastic modeling with constant parameters"},{"location":"tutorials/06_elastic/#elastic-wave-equation-implementation-on-a-staggered-grid","text":"This is a first attempt at implemenenting the elastic wave equation as described in: [1] Jean Virieux (1986). \u201dP-SV wave propagation in heterogeneous media: Velocity\u2010stress finite\u2010difference method.\u201d GEOPHYSICS, 51(4), 889-901. https://doi.org/10.1190/1.1442147 The current version actually attempts to mirror the FDELMODC implementation by Jan Thorbecke: [2] https://janth.home.xs4all.nl/Software/fdelmodcManual.pdf Explosive source We will first attempt to replicate the explosive source test case described in [1], Figure 4. We start by defining the source signature g(t) g(t) , the derivative of a Gaussian pulse, given by Eq 4: g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} from devito import * from seismic.source import WaveletSource , RickerSource , GaborSource , TimeAxis from seismic import plot_image import numpy as np from sympy import init_printing , latex init_printing ( use_latex = 'mathjax' ) # Initial grid: 1km x 1km, with spacing 100m extent = ( 1500. , 1500. ) shape = ( 201 , 201 ) x = SpaceDimension ( name = 'x' , spacing = Constant ( name = 'h_x' , value = extent [ 0 ] / ( shape [ 0 ] - 1 ))) z = SpaceDimension ( name = 'z' , spacing = Constant ( name = 'h_z' , value = extent [ 1 ] / ( shape [ 1 ] - 1 ))) grid = Grid ( extent = extent , shape = shape , dimensions = ( x , z )) class DGaussSource ( WaveletSource ): def wavelet ( self , f0 , t ): a = 0.004 return - 2. * a * ( t - 1 / f0 ) * np . exp ( - a * ( t - 1 / f0 ) ** 2 ) # Timestep size from Eq. 7 with V_p=6000. and dx=100 t0 , tn = 0. , 300. dt = ( 10. / np . sqrt ( 2. )) / 6. time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) src = RickerSource ( name = 'src' , grid = grid , f0 = 0.01 , time_range = time_range ) src . coordinates . data [:] = [ 750. , 750. ] #NBVAL_SKIP src . show () # Now we create the velocity and pressure fields so = 2 v = VectorTimeFunction ( name = 'v' , grid = grid , space_order = so , time_order = 1 ) tau = TensorTimeFunction ( name = 't' , grid = grid , space_order = so , time_order = 1 ) # Now let's try and create the staggered updates t = grid . stepping_dim time = grid . time_dim # We need some initial conditions V_p = 2.0 V_s = 1.0 density = 1.8 # The source injection term src_xx = src . inject ( field = tau . forward [ 0 , 0 ], expr = src ) src_zz = src . inject ( field = tau . forward [ 1 , 1 ], expr = src ) # Thorbecke's parameter notation cp2 = V_p * V_p cs2 = V_s * V_s ro = 1 / density mu = cs2 * density l = ( cp2 * density - 2 * mu ) # fdelmodc reference implementation u_v = Eq ( v . forward , v + dt * ro * div ( tau )) u_t = Eq ( tau . forward , tau + dt * l * diag ( div ( v . forward )) + dt * mu * ( grad ( v . forward ) + grad ( v . forward ) . T )) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz ) u_v \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)}\\\\\\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)}\\\\\\operatorname{v_{z}}{\\left(t,x,z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{zz}}{\\left(t,x,z \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)}\\\\\\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)}\\\\\\operatorname{v_{z}}{\\left(t,x,z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{zz}}{\\left(t,x,z \\right)}\\end{matrix}\\right] #NBVAL_IGNORE_OUTPUT op () Operator `Kernel` run in 0.02 s #NBVAL_SKIP # Let's see what we got.... plot_image ( v [ 0 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( v [ 1 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 0 , 0 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 1 , 1 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 0 , 1 ] . data [ 0 ], cmap = \"seismic\" ) #NBVAL_IGNORE_OUTPUT assert np . isclose ( norm ( v [ 0 ]), 0.6285093 , atol = 1e-4 , rtol = 0 ) # Now that looks pretty! But let's do it again with a higher order... so = 12 v = VectorTimeFunction ( name = 'v' , grid = grid , space_order = so , time_order = 1 ) tau = TensorTimeFunction ( name = 't' , grid = grid , space_order = so , time_order = 1 ) # The source injection term src_xx = src . inject ( field = tau . forward [ 0 , 0 ], expr = src ) src_zz = src . inject ( field = tau . forward [ 1 , 1 ], expr = src ) # fdelmodc reference implementation u_v = Eq ( v . forward , v + dt * ro * div ( tau )) u_t = Eq ( tau . forward , tau + l * diag ( div ( v . forward )) + mu * ( grad ( v . forward ) + grad ( v . forward ) . T )) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz ) #NBVAL_IGNORE_OUTPUT v [ 0 ] . data . fill ( 0. ) v [ 1 ] . data . fill ( 0. ) tau [ 0 , 0 ] . data . fill ( 0. ) tau [ 0 , 1 ] . data . fill ( 0. ) tau [ 1 , 1 ] . data . fill ( 0. ) op () Operator `Kernel` run in 0.02 s #NBVAL_SKIP # Let's see what we got.... plot_image ( v [ 0 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( v [ 1 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 0 , 0 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 1 , 1 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 0 , 1 ] . data [ 0 ], cmap = \"seismic\" ) #NBVAL_IGNORE_OUTPUT assert np . isclose ( norm ( v [ 0 ]), 0.736816932 , atol = 1e-4 , rtol = 0 )","title":"Elastic wave equation implementation on a staggered grid"},{"location":"tutorials/07_elastic_varying_parameters/","text":"Elastic wave equation implementation on a staggered grid This second elastic tutorial extends the previous constant parameter implementation to varying parameters (Lame parameters) and takes advantage of the Tensorial capabilities of Devito to write the elastic wave equation following its mathematical definition. The staggering is automated via the TensorFunction API. Explosive source We will first attempt to replicate the explosive source test case described in [1], Figure 4. We start by defining the source signature g(t) g(t) , the derivative of a Gaussian pulse, given by Eq 4: g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} from devito import * from seismic.source import RickerSource , Receiver , TimeAxis from seismic import plot_image , demo_model import numpy as np import matplotlib.pyplot as plt from sympy import init_printing , latex init_printing ( use_latex = 'mathjax' ) # Some ploting setup plt . rc ( 'font' , family = 'serif' ) plt . rc ( 'xtick' , labelsize = 20 ) plt . rc ( 'ytick' , labelsize = 20 ) #NBVAL_IGNORE_OUTPUT # Initial grid: 3km x 3km, with spacing 10m nlayers = 5 model = demo_model ( preset = 'layers-elastic' , nlayers = nlayers , shape = ( 301 , 301 ), spacing = ( 10. , 10. )) Operator `initdamp` run in 0.06 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s #NBVAL_SKIP aspect_ratio = model . shape [ 0 ] / model . shape [ 1 ] plt_options_model = { 'cmap' : 'jet' , 'extent' : [ model . origin [ 0 ], model . origin [ 0 ] + model . domain_size [ 0 ], model . origin [ 1 ] + model . domain_size [ 1 ], model . origin [ 1 ]]} fig , ax = plt . subplots ( nrows = 3 , ncols = 1 , figsize = ( 15 , 15 )) slices = [ slice ( model . nbl , - model . nbl ), slice ( model . nbl , - model . nbl )] img1 = ax [ 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 1.5 ** 2 , vmax = 4.0 ** 2 , ** plt_options_model ) fig . colorbar ( img1 , ax = ax [ 0 ]) ax [ 0 ] . set_title ( r \"First Lam\\'e parameter $\\lambda$\" , fontsize = 20 ) ax [ 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 0 ] . set_aspect ( 'auto' ) img2 = ax [ 1 ] . imshow ( np . transpose ( model . mu . data [ slices ]), vmin = 0 , vmax = 15 , ** plt_options_model ) fig . colorbar ( img2 , ax = ax [ 1 ]) ax [ 1 ] . set_title ( r \"Shear modulus $\\mu$\" , fontsize = 20 ) ax [ 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 ] . set_aspect ( 'auto' ) img3 = ax [ 2 ] . imshow ( 1 / np . transpose ( model . irho . data [ slices ]), vmin = 1.0 , vmax = 3.0 , ** plt_options_model ) fig . colorbar ( img3 , ax = ax [ 2 ]) ax [ 2 ] . set_title ( r \"Density $\\rho$\" , fontsize = 20 ) ax [ 2 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 2 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 2 ] . set_aspect ( 'auto' ) plt . tight_layout () # Timestep size from Eq. 7 with V_p=6000. and dx=100 t0 , tn = 0. , 2000. dt = model . critical_dt time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) src = RickerSource ( name = 'src' , grid = model . grid , f0 = 0.015 , time_range = time_range ) src . coordinates . data [:] = [ 1500. , 10. ] #NBVAL_SKIP src . show () Vectorial form While conventional litterature writes the elastic wave-equation as a set of scalar PDEs, the higher level representation comes from Hooke's law and the equation of motion and writes as: \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda tr(\\nabla v) \\mathbf{I} + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda tr(\\nabla v) \\mathbf{I} + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} and as tr(\\nabla v) tr(\\nabla v) is the divergence of v v we can rewrite it as \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda \\text{diag}(\\nabla . v) + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda \\text{diag}(\\nabla . v) + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} where v v is a vector valued function: v(t, x, y) = (v_x(t, x, y), v_y(t, x, y) v(t, x, y) = (v_x(t, x, y), v_y(t, x, y) and the stress \\tau \\tau is a symmetric tensor valued function: \\tau(t, x, y) = \\begin{bmatrix}\\tau_{xx}(t, x, y) & \\tau_{xy}(t, x, y)\\\\\\tau_{xy}t, x, y) & \\tau_{yy}(t, x, y)\\end{bmatrix} \\tau(t, x, y) = \\begin{bmatrix}\\tau_{xx}(t, x, y) & \\tau_{xy}(t, x, y)\\\\\\tau_{xy}t, x, y) & \\tau_{yy}(t, x, y)\\end{bmatrix} We show in the following how to setup the elastic wave-equation form Devito's high-level tensorial types. # Now we create the velocity and pressure fields so = 8 x , z = model . grid . dimensions t = model . grid . stepping_dim time = model . grid . time_dim s = time . spacing v = VectorTimeFunction ( name = 'v' , grid = model . grid , space_order = so , time_order = 1 ) tau = TensorTimeFunction ( name = 't' , grid = model . grid , space_order = so , time_order = 1 ) # The source injection term src_xx = src . inject ( field = tau . forward [ 0 , 0 ], expr = s * src ) src_zz = src . inject ( field = tau . forward [ 1 , 1 ], expr = s * src ) # The receiver nrec = 301 rec = Receiver ( name = \"rec\" , grid = model . grid , npoint = nrec , time_range = time_range ) rec . coordinates . data [:, 0 ] = np . linspace ( 0. , model . domain_size [ 0 ], num = nrec ) rec . coordinates . data [:, - 1 ] = 5. rec2 = Receiver ( name = \"rec2\" , grid = model . grid , npoint = nrec , time_range = time_range ) rec2 . coordinates . data [:, 0 ] = np . linspace ( 0. , model . domain_size [ 0 ], num = nrec ) rec2 . coordinates . data [:, - 1 ] = 3000.0 / nlayers rec3 = Receiver ( name = \"rec3\" , grid = model . grid , npoint = nrec , time_range = time_range ) rec3 . coordinates . data [:, 0 ] = np . linspace ( 0. , model . domain_size [ 0 ], num = nrec ) rec3 . coordinates . data [:, - 1 ] = 3000.0 / nlayers rec_term = rec . interpolate ( expr = tau [ 0 , 0 ] + tau [ 1 , 1 ]) rec_term += rec2 . interpolate ( expr = v [ 1 ]) rec_term += rec3 . interpolate ( expr = v [ 0 ]) #NBVAL_SKIP from seismic import plot_velocity plot_velocity ( model , source = src . coordinates . data , receiver = rec . coordinates . data [:: 10 , :]) plot_velocity ( model , source = src . coordinates . data , receiver = rec2 . coordinates . data [:: 10 , :]) Devito implementation We now implement the vectorial formulation directly with Devito using it's vectorial and matricial symbolic objects # Now let's try and create the staggered updates # Lame parameters l , mu , ro = model . lam , model . mu , model . irho # fdelmodc reference implementation u_v = Eq ( v . forward , model . damp * ( v + s * ro * div ( tau ))) u_t = Eq ( tau . forward , model . damp * ( tau + s * ( l * diag ( div ( v . forward )) + mu * ( grad ( v . forward ) + grad ( v . forward ) . T )))) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz + rec_term ) We can now see that both the particle velocities and stress equations are vectorial and tensorial equations. Devito takes care of the discretization and staggered grids automatically for these types of object. u_v \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\\\\\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{irho}{\\left(x,y \\right)} + \\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) \\operatorname{irho}{\\left(x,y \\right)} + \\operatorname{v_{y}}{\\left(t,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\\\\\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{irho}{\\left(x,y \\right)} + \\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) \\operatorname{irho}{\\left(x,y \\right)} + \\operatorname{v_{y}}{\\left(t,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] u_t \\displaystyle \\left[\\begin{matrix}\\operatorname{t_{xx}}{\\left(t + dt,x,y \\right)} & \\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\\\\\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} & \\operatorname{t_{yy}}{\\left(t + dt,x,y \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\right) + \\operatorname{t_{xx}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) + \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{t_{xx}}{\\left(t + dt,x,y \\right)} & \\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\\\\\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} & \\operatorname{t_{yy}}{\\left(t + dt,x,y \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\right) + \\operatorname{t_{xx}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) + \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] #NBVAL_IGNORE_OUTPUT # Partial ru for 1.2sec to plot the wavefield op ( dt = model . critical_dt , time_M = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.23 s #NBVAL_SKIP scale = . 5 * 1e-3 plt_options_model = { 'extent' : [ model . origin [ 0 ] , model . origin [ 0 ] + model . domain_size [ 0 ], model . origin [ 1 ] + model . domain_size [ 1 ], model . origin [ 1 ]]} fig , ax = plt . subplots ( nrows = 2 , ncols = 2 , figsize = ( 15 , 15 )) ax [ 0 , 0 ] . imshow ( np . transpose ( v [ 0 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 0 ] . set_aspect ( 'auto' ) ax [ 0 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_title ( r \"$v_ {x} $\" , fontsize = 20 ) ax [ 0 , 1 ] . imshow ( np . transpose ( v [ 1 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 1 ] . set_aspect ( 'auto' ) ax [ 0 , 1 ] . set_title ( r \"$v_ {z} $\" , fontsize = 20 ) ax [ 0 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 0 ] . imshow ( np . transpose ( tau [ 0 , 0 ] . data [ 0 ][ slices ] + tau [ 1 , 1 ] . data [ 0 ][ slices ]), vmin =- 10 * scale , vmax = 10 * scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 0 ] . set_aspect ( 'auto' ) ax [ 1 , 0 ] . set_title ( r \"$\\tau_ {xx} + \\tau_ {zz} $\" , fontsize = 20 ) ax [ 1 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 1 ] . imshow ( np . transpose ( tau [ 0 , 1 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 1 ] . set_aspect ( 'auto' ) ax [ 1 , 1 ] . set_title ( r \"$\\tau_ {xy} $\" , fontsize = 20 ) ax [ 1 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) plt . tight_layout () #NBVAL_IGNORE_OUTPUT # Full run for the data op ( dt = model . critical_dt , time_m = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.25 s # Data on a standard 2ms tim axis rec_plot = rec . resample ( num = 1001 ) rec2_plot = rec2 . resample ( num = 1001 ) rec3_plot = rec3 . resample ( num = 1001 ) scale_for_plot = np . diag ( np . linspace ( 1.0 , 2.5 , 1001 ) ** 2.0 ) #NBVAL_SKIP # Pressure (txx + tzz) data at sea surface extent = [ rec_plot . coordinates . data [ 0 , 0 ], rec_plot . coordinates . data [ - 1 , 0 ], 1e-3 * tn , t0 ] aspect = rec_plot . coordinates . data [ - 1 , 0 ] / ( 1e-3 * tn ) /. 5 plt . figure ( figsize = ( 15 , 15 )) plt . imshow ( np . dot ( scale_for_plot , rec_plot . data ), vmin =-. 01 , vmax =. 01 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) Text(0.5, 0, 'Receiver position (m)') #NBVAL_SKIP # OBC data of vx/vz plt . figure ( figsize = ( 15 , 15 )) plt . subplot ( 121 ) plt . imshow ( rec2_plot . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) plt . subplot ( 122 ) plt . imshow ( rec3_plot . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) Text(0.5, 0, 'Receiver position (m)') Second order formulation The elastic wave-equation can be formulated in a second-order in time way as well as: \\begin{cases} &\\frac{d^2v}{dt^2} = \\nabla . \\tau \\\\ & \\tau = \\lambda \\text{diag}(\\nabla . v) + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} \\begin{cases} &\\frac{d^2v}{dt^2} = \\nabla . \\tau \\\\ & \\tau = \\lambda \\text{diag}(\\nabla . v) + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} where once again v v is the vector valued particle velocity, and \\tau \\tau is now time independent. This formulation is straightforward to implement as well and only requires minor update to the declaration of the symbolic objects and PDE. # Now that looks pretty! But let's do it again with a 2nd order in time so = 8 v2 = VectorTimeFunction ( name = 'v2' , grid = model . grid , space_order = so , time_order = 2 ) tau0 = TensorFunction ( name = 't0' , grid = model . grid , space_order = so ) # The source injection term src_xx = src . inject ( field = tau0 [ 0 , 0 ], expr = src . dt ) src_zz = src . inject ( field = tau0 [ 1 , 1 ], expr = src . dt ) s = model . grid . time_dim . spacing # fdelmodc reference implementation u_v = Eq ( v2 . forward , model . damp * ( 2 * v2 - model . damp * v2 . backward + s ** 2 * ro * div ( tau0 ))) u_t = Eq ( tau0 , model . damp * ( l * diag ( div ( v2 . forward )) + mu * ( grad ( v2 . forward ) + grad ( v2 . forward ) . T ))) # rec_term = rec.interpolate(expr=tau[0, 0] + tau[1, 1]) rec_term = rec2 . interpolate ( expr = v2 [ 0 ]) rec_term += rec3 . interpolate ( expr = v2 [ 1 ]) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz + rec_term ) #NBVAL_IGNORE_OUTPUT # Partial ru for 1.2sec to plot the wavefield op ( dt = model . critical_dt , time_M = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.20 s #NBVAL_SKIP scale = 1e-4 plt_options_model = { 'extent' : [ model . origin [ 0 ] , model . origin [ 0 ] + model . domain_size [ 0 ], model . origin [ 1 ] + model . domain_size [ 1 ], model . origin [ 1 ]]} fig , ax = plt . subplots ( nrows = 2 , ncols = 2 , figsize = ( 15 , 15 )) ax [ 0 , 0 ] . imshow ( np . transpose ( v2 [ 0 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 0 ] . set_aspect ( 'auto' ) ax [ 0 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_title ( r \"$v_ {x} $\" , fontsize = 20 ) ax [ 0 , 1 ] . imshow ( np . transpose ( v2 [ 1 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 1 ] . set_aspect ( 'auto' ) ax [ 0 , 1 ] . set_title ( r \"$v_ {z} $\" , fontsize = 20 ) ax [ 0 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 0 ] . imshow ( np . transpose ( tau0 [ 0 , 0 ] . data [ slices ] + tau0 [ 1 , 1 ] . data [ slices ]), vmin =- 10 * scale , vmax = 10 * scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 0 ] . set_aspect ( 'auto' ) ax [ 1 , 0 ] . set_title ( r \"$\\tau_ {xx} + \\tau_ {zz} $\" , fontsize = 20 ) ax [ 1 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 1 ] . imshow ( np . transpose ( tau0 [ 0 , 1 ] . data [ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 1 ] . set_aspect ( 'auto' ) ax [ 1 , 1 ] . set_title ( r \"$\\tau_ {xy} $\" , fontsize = 20 ) ax [ 1 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) plt . tight_layout () #NBVAL_IGNORE_OUTPUT op ( dt = model . critical_dt , time_m = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.20 s rec2_plot2 = rec2 . resample ( num = 1001 ) rec3_plot2 = rec3 . resample ( num = 1001 ) #NBVAL_SKIP # OBC data of vx/vz plt . figure ( figsize = ( 15 , 15 )) plt . subplot ( 121 ) plt . imshow ( rec2_plot2 . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) plt . subplot ( 122 ) plt . imshow ( rec3_plot2 . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) Text(0.5, 0, 'Receiver position (m)')","title":"Elastic modeling with varying parameters"},{"location":"tutorials/07_elastic_varying_parameters/#elastic-wave-equation-implementation-on-a-staggered-grid","text":"This second elastic tutorial extends the previous constant parameter implementation to varying parameters (Lame parameters) and takes advantage of the Tensorial capabilities of Devito to write the elastic wave equation following its mathematical definition. The staggering is automated via the TensorFunction API. Explosive source We will first attempt to replicate the explosive source test case described in [1], Figure 4. We start by defining the source signature g(t) g(t) , the derivative of a Gaussian pulse, given by Eq 4: g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} from devito import * from seismic.source import RickerSource , Receiver , TimeAxis from seismic import plot_image , demo_model import numpy as np import matplotlib.pyplot as plt from sympy import init_printing , latex init_printing ( use_latex = 'mathjax' ) # Some ploting setup plt . rc ( 'font' , family = 'serif' ) plt . rc ( 'xtick' , labelsize = 20 ) plt . rc ( 'ytick' , labelsize = 20 ) #NBVAL_IGNORE_OUTPUT # Initial grid: 3km x 3km, with spacing 10m nlayers = 5 model = demo_model ( preset = 'layers-elastic' , nlayers = nlayers , shape = ( 301 , 301 ), spacing = ( 10. , 10. )) Operator `initdamp` run in 0.06 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s #NBVAL_SKIP aspect_ratio = model . shape [ 0 ] / model . shape [ 1 ] plt_options_model = { 'cmap' : 'jet' , 'extent' : [ model . origin [ 0 ], model . origin [ 0 ] + model . domain_size [ 0 ], model . origin [ 1 ] + model . domain_size [ 1 ], model . origin [ 1 ]]} fig , ax = plt . subplots ( nrows = 3 , ncols = 1 , figsize = ( 15 , 15 )) slices = [ slice ( model . nbl , - model . nbl ), slice ( model . nbl , - model . nbl )] img1 = ax [ 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 1.5 ** 2 , vmax = 4.0 ** 2 , ** plt_options_model ) fig . colorbar ( img1 , ax = ax [ 0 ]) ax [ 0 ] . set_title ( r \"First Lam\\'e parameter $\\lambda$\" , fontsize = 20 ) ax [ 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 0 ] . set_aspect ( 'auto' ) img2 = ax [ 1 ] . imshow ( np . transpose ( model . mu . data [ slices ]), vmin = 0 , vmax = 15 , ** plt_options_model ) fig . colorbar ( img2 , ax = ax [ 1 ]) ax [ 1 ] . set_title ( r \"Shear modulus $\\mu$\" , fontsize = 20 ) ax [ 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 ] . set_aspect ( 'auto' ) img3 = ax [ 2 ] . imshow ( 1 / np . transpose ( model . irho . data [ slices ]), vmin = 1.0 , vmax = 3.0 , ** plt_options_model ) fig . colorbar ( img3 , ax = ax [ 2 ]) ax [ 2 ] . set_title ( r \"Density $\\rho$\" , fontsize = 20 ) ax [ 2 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 2 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 2 ] . set_aspect ( 'auto' ) plt . tight_layout () # Timestep size from Eq. 7 with V_p=6000. and dx=100 t0 , tn = 0. , 2000. dt = model . critical_dt time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) src = RickerSource ( name = 'src' , grid = model . grid , f0 = 0.015 , time_range = time_range ) src . coordinates . data [:] = [ 1500. , 10. ] #NBVAL_SKIP src . show ()","title":"Elastic wave equation implementation on a staggered grid"},{"location":"tutorials/07_elastic_varying_parameters/#vectorial-form","text":"While conventional litterature writes the elastic wave-equation as a set of scalar PDEs, the higher level representation comes from Hooke's law and the equation of motion and writes as: \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda tr(\\nabla v) \\mathbf{I} + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda tr(\\nabla v) \\mathbf{I} + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} and as tr(\\nabla v) tr(\\nabla v) is the divergence of v v we can rewrite it as \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda \\text{diag}(\\nabla . v) + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda \\text{diag}(\\nabla . v) + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} where v v is a vector valued function: v(t, x, y) = (v_x(t, x, y), v_y(t, x, y) v(t, x, y) = (v_x(t, x, y), v_y(t, x, y) and the stress \\tau \\tau is a symmetric tensor valued function: \\tau(t, x, y) = \\begin{bmatrix}\\tau_{xx}(t, x, y) & \\tau_{xy}(t, x, y)\\\\\\tau_{xy}t, x, y) & \\tau_{yy}(t, x, y)\\end{bmatrix} \\tau(t, x, y) = \\begin{bmatrix}\\tau_{xx}(t, x, y) & \\tau_{xy}(t, x, y)\\\\\\tau_{xy}t, x, y) & \\tau_{yy}(t, x, y)\\end{bmatrix} We show in the following how to setup the elastic wave-equation form Devito's high-level tensorial types. # Now we create the velocity and pressure fields so = 8 x , z = model . grid . dimensions t = model . grid . stepping_dim time = model . grid . time_dim s = time . spacing v = VectorTimeFunction ( name = 'v' , grid = model . grid , space_order = so , time_order = 1 ) tau = TensorTimeFunction ( name = 't' , grid = model . grid , space_order = so , time_order = 1 ) # The source injection term src_xx = src . inject ( field = tau . forward [ 0 , 0 ], expr = s * src ) src_zz = src . inject ( field = tau . forward [ 1 , 1 ], expr = s * src ) # The receiver nrec = 301 rec = Receiver ( name = \"rec\" , grid = model . grid , npoint = nrec , time_range = time_range ) rec . coordinates . data [:, 0 ] = np . linspace ( 0. , model . domain_size [ 0 ], num = nrec ) rec . coordinates . data [:, - 1 ] = 5. rec2 = Receiver ( name = \"rec2\" , grid = model . grid , npoint = nrec , time_range = time_range ) rec2 . coordinates . data [:, 0 ] = np . linspace ( 0. , model . domain_size [ 0 ], num = nrec ) rec2 . coordinates . data [:, - 1 ] = 3000.0 / nlayers rec3 = Receiver ( name = \"rec3\" , grid = model . grid , npoint = nrec , time_range = time_range ) rec3 . coordinates . data [:, 0 ] = np . linspace ( 0. , model . domain_size [ 0 ], num = nrec ) rec3 . coordinates . data [:, - 1 ] = 3000.0 / nlayers rec_term = rec . interpolate ( expr = tau [ 0 , 0 ] + tau [ 1 , 1 ]) rec_term += rec2 . interpolate ( expr = v [ 1 ]) rec_term += rec3 . interpolate ( expr = v [ 0 ]) #NBVAL_SKIP from seismic import plot_velocity plot_velocity ( model , source = src . coordinates . data , receiver = rec . coordinates . data [:: 10 , :]) plot_velocity ( model , source = src . coordinates . data , receiver = rec2 . coordinates . data [:: 10 , :])","title":"Vectorial form"},{"location":"tutorials/07_elastic_varying_parameters/#devito-implementation","text":"We now implement the vectorial formulation directly with Devito using it's vectorial and matricial symbolic objects # Now let's try and create the staggered updates # Lame parameters l , mu , ro = model . lam , model . mu , model . irho # fdelmodc reference implementation u_v = Eq ( v . forward , model . damp * ( v + s * ro * div ( tau ))) u_t = Eq ( tau . forward , model . damp * ( tau + s * ( l * diag ( div ( v . forward )) + mu * ( grad ( v . forward ) + grad ( v . forward ) . T )))) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz + rec_term ) We can now see that both the particle velocities and stress equations are vectorial and tensorial equations. Devito takes care of the discretization and staggered grids automatically for these types of object. u_v \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\\\\\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{irho}{\\left(x,y \\right)} + \\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) \\operatorname{irho}{\\left(x,y \\right)} + \\operatorname{v_{y}}{\\left(t,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\\\\\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{irho}{\\left(x,y \\right)} + \\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) \\operatorname{irho}{\\left(x,y \\right)} + \\operatorname{v_{y}}{\\left(t,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] u_t \\displaystyle \\left[\\begin{matrix}\\operatorname{t_{xx}}{\\left(t + dt,x,y \\right)} & \\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\\\\\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} & \\operatorname{t_{yy}}{\\left(t + dt,x,y \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\right) + \\operatorname{t_{xx}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) + \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{t_{xx}}{\\left(t + dt,x,y \\right)} & \\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\\\\\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} & \\operatorname{t_{yy}}{\\left(t + dt,x,y \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\right) + \\operatorname{t_{xx}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) + \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] #NBVAL_IGNORE_OUTPUT # Partial ru for 1.2sec to plot the wavefield op ( dt = model . critical_dt , time_M = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.23 s #NBVAL_SKIP scale = . 5 * 1e-3 plt_options_model = { 'extent' : [ model . origin [ 0 ] , model . origin [ 0 ] + model . domain_size [ 0 ], model . origin [ 1 ] + model . domain_size [ 1 ], model . origin [ 1 ]]} fig , ax = plt . subplots ( nrows = 2 , ncols = 2 , figsize = ( 15 , 15 )) ax [ 0 , 0 ] . imshow ( np . transpose ( v [ 0 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 0 ] . set_aspect ( 'auto' ) ax [ 0 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_title ( r \"$v_ {x} $\" , fontsize = 20 ) ax [ 0 , 1 ] . imshow ( np . transpose ( v [ 1 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 1 ] . set_aspect ( 'auto' ) ax [ 0 , 1 ] . set_title ( r \"$v_ {z} $\" , fontsize = 20 ) ax [ 0 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 0 ] . imshow ( np . transpose ( tau [ 0 , 0 ] . data [ 0 ][ slices ] + tau [ 1 , 1 ] . data [ 0 ][ slices ]), vmin =- 10 * scale , vmax = 10 * scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 0 ] . set_aspect ( 'auto' ) ax [ 1 , 0 ] . set_title ( r \"$\\tau_ {xx} + \\tau_ {zz} $\" , fontsize = 20 ) ax [ 1 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 1 ] . imshow ( np . transpose ( tau [ 0 , 1 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 1 ] . set_aspect ( 'auto' ) ax [ 1 , 1 ] . set_title ( r \"$\\tau_ {xy} $\" , fontsize = 20 ) ax [ 1 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) plt . tight_layout () #NBVAL_IGNORE_OUTPUT # Full run for the data op ( dt = model . critical_dt , time_m = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.25 s # Data on a standard 2ms tim axis rec_plot = rec . resample ( num = 1001 ) rec2_plot = rec2 . resample ( num = 1001 ) rec3_plot = rec3 . resample ( num = 1001 ) scale_for_plot = np . diag ( np . linspace ( 1.0 , 2.5 , 1001 ) ** 2.0 ) #NBVAL_SKIP # Pressure (txx + tzz) data at sea surface extent = [ rec_plot . coordinates . data [ 0 , 0 ], rec_plot . coordinates . data [ - 1 , 0 ], 1e-3 * tn , t0 ] aspect = rec_plot . coordinates . data [ - 1 , 0 ] / ( 1e-3 * tn ) /. 5 plt . figure ( figsize = ( 15 , 15 )) plt . imshow ( np . dot ( scale_for_plot , rec_plot . data ), vmin =-. 01 , vmax =. 01 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) Text(0.5, 0, 'Receiver position (m)') #NBVAL_SKIP # OBC data of vx/vz plt . figure ( figsize = ( 15 , 15 )) plt . subplot ( 121 ) plt . imshow ( rec2_plot . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) plt . subplot ( 122 ) plt . imshow ( rec3_plot . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) Text(0.5, 0, 'Receiver position (m)')","title":"Devito implementation"},{"location":"tutorials/07_elastic_varying_parameters/#second-order-formulation","text":"The elastic wave-equation can be formulated in a second-order in time way as well as: \\begin{cases} &\\frac{d^2v}{dt^2} = \\nabla . \\tau \\\\ & \\tau = \\lambda \\text{diag}(\\nabla . v) + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} \\begin{cases} &\\frac{d^2v}{dt^2} = \\nabla . \\tau \\\\ & \\tau = \\lambda \\text{diag}(\\nabla . v) + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} where once again v v is the vector valued particle velocity, and \\tau \\tau is now time independent. This formulation is straightforward to implement as well and only requires minor update to the declaration of the symbolic objects and PDE. # Now that looks pretty! But let's do it again with a 2nd order in time so = 8 v2 = VectorTimeFunction ( name = 'v2' , grid = model . grid , space_order = so , time_order = 2 ) tau0 = TensorFunction ( name = 't0' , grid = model . grid , space_order = so ) # The source injection term src_xx = src . inject ( field = tau0 [ 0 , 0 ], expr = src . dt ) src_zz = src . inject ( field = tau0 [ 1 , 1 ], expr = src . dt ) s = model . grid . time_dim . spacing # fdelmodc reference implementation u_v = Eq ( v2 . forward , model . damp * ( 2 * v2 - model . damp * v2 . backward + s ** 2 * ro * div ( tau0 ))) u_t = Eq ( tau0 , model . damp * ( l * diag ( div ( v2 . forward )) + mu * ( grad ( v2 . forward ) + grad ( v2 . forward ) . T ))) # rec_term = rec.interpolate(expr=tau[0, 0] + tau[1, 1]) rec_term = rec2 . interpolate ( expr = v2 [ 0 ]) rec_term += rec3 . interpolate ( expr = v2 [ 1 ]) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz + rec_term ) #NBVAL_IGNORE_OUTPUT # Partial ru for 1.2sec to plot the wavefield op ( dt = model . critical_dt , time_M = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.20 s #NBVAL_SKIP scale = 1e-4 plt_options_model = { 'extent' : [ model . origin [ 0 ] , model . origin [ 0 ] + model . domain_size [ 0 ], model . origin [ 1 ] + model . domain_size [ 1 ], model . origin [ 1 ]]} fig , ax = plt . subplots ( nrows = 2 , ncols = 2 , figsize = ( 15 , 15 )) ax [ 0 , 0 ] . imshow ( np . transpose ( v2 [ 0 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 0 ] . set_aspect ( 'auto' ) ax [ 0 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_title ( r \"$v_ {x} $\" , fontsize = 20 ) ax [ 0 , 1 ] . imshow ( np . transpose ( v2 [ 1 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 1 ] . set_aspect ( 'auto' ) ax [ 0 , 1 ] . set_title ( r \"$v_ {z} $\" , fontsize = 20 ) ax [ 0 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 0 ] . imshow ( np . transpose ( tau0 [ 0 , 0 ] . data [ slices ] + tau0 [ 1 , 1 ] . data [ slices ]), vmin =- 10 * scale , vmax = 10 * scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 0 ] . set_aspect ( 'auto' ) ax [ 1 , 0 ] . set_title ( r \"$\\tau_ {xx} + \\tau_ {zz} $\" , fontsize = 20 ) ax [ 1 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 1 ] . imshow ( np . transpose ( tau0 [ 0 , 1 ] . data [ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 1 ] . set_aspect ( 'auto' ) ax [ 1 , 1 ] . set_title ( r \"$\\tau_ {xy} $\" , fontsize = 20 ) ax [ 1 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) plt . tight_layout () #NBVAL_IGNORE_OUTPUT op ( dt = model . critical_dt , time_m = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.20 s rec2_plot2 = rec2 . resample ( num = 1001 ) rec3_plot2 = rec3 . resample ( num = 1001 ) #NBVAL_SKIP # OBC data of vx/vz plt . figure ( figsize = ( 15 , 15 )) plt . subplot ( 121 ) plt . imshow ( rec2_plot2 . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) plt . subplot ( 122 ) plt . imshow ( rec3_plot2 . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) Text(0.5, 0, 'Receiver position (m)')","title":"Second order formulation"},{"location":"tutorials/TLE_Adjoint/","text":"import numpy as np import matplotlib.pyplot as plt % matplotlib inline Preface: Installing Devito (do not include in manuscipt) This tutorial and the coming second part are based on Devito version 3.1.0. It requires the installation of the full software with examples, not only the code generation API. To install: git clone -b v3.1.0 https://github.com/opesci/devito cd devito conda env create -f environment.yml source activate devito pip install -e . That final dot is important, don't miss it out! Useful links Devito documentation Devito source code and examples Tutorial notebooks with latest Devito/master Geophysics tutorial Full-waveform inversion 2: adjoint modeling Mathias Louboutin 1 *, Philipp Witte 1 , Michael Lange 2 , Navjot Kukreja 2 , Fabio Luporini 2 , Gerard Gorman 2 , and Felix J. Herrmann 1,3 1 Seismic Laboratory for Imaging and Modeling (SLIM), The University of British Columbia 2 Imperial College London, London, UK 3 now at Georgia Institute of Technology, USA Corresponding author: mloubout@eoas.ubc.ca Introduction This tutorial is the second part of a three part tutorial series on full-waveform inversion (FWI), in which we provide a step by step walk through of setting up forward and adjoint wave equation solvers and an optimization framework for inversion. In Part 1 (Louboutin et al., 2017), we showed how to use Devito to set up and solve acoustic wave equations with (impulsive) seismic sources and sample wavefields at the receiver locations to forward model shot records. In the second part of this tutorial series, we will discuss how to set up and solve adjoint wave equations with Devito and from that, how we can calculate gradients and function values of the FWI objective function. The gradient of FWI is most commonly computed via the adjoint state method, by cross-correlating forward and adjoint wavefields and summing the contributions over all time steps (Plessix, 2006). Calculating the gradient for one source location consists of three steps: Solve the forward wave equation to create a shot record. The time varying wavefield must be stored for use in step 3; techniques such as subsampling can be used to reduce the storage requirements. Compute the data residual (or misfit) between the predicted and observed data. Solve the corresponding discrete adjoint model using the data residual as the source. Within the adjoint (reverse) time loop, cross correlate the second time derivative of the adjoint wavefield with the forward wavefield. These cross correlations are summed to form the gradient. We start with the definition and derivation of the adjoint wave equation and its Devito stencil and then show how to compute the gradient of the conventional least squares FWI misfit function. As usual, this tutorial is accompanied by all the code you need to reproduce the figures. Go to github.com/seg/tutorials-2018 and follow the links. A simple experiment To demonstrate the gradient computation in the simplest possible way, we perform a small seismic transmission experiment with a circular imaging phantom, i.e. a constant velocity model with a circular high velocity inclusion in its centre, as shown in Figure 1. For a transmission experiment, we place 21 seismic sources on the left-hand side of the model and 101 receivers on the right-hand side. We will use the forward propagator from part 1 to independently model the 21 \"observed\" shot records using the true model. As the initial model for our gradient calculation, we use a constant velocity model with the same velocity as the true model, but without the circular velocity perturbation. We will then model the 21 predicted shot records for the initial model, calculate the data residual and gradient for each shot, and sum them to obtain the full gradient. ++ Figure 1 is generated later in the manuscript ++ Figure 1: (a) The velocity model, with sources and receivers arranged vertically. (b) The initial estimate. \u00a9 The difference between the model and the initial estimate. The adjoint wave equation Adjoint wave equations are a main component in seismic inversion algorithms and are required for computing gradients of both linear and non-linear objective functions. To ensure stability of the adjoint modeling scheme and the expected convergence of inversion algorithms, it is very important that the adjoint wave equation is in fact the adjoint (transpose) of the forward wave equation. The derivation of the adjoint wave equation in the acoustic case is simple, as it is self-adjoint if we ignore the absorbing boundaries for the moment. However, in the general case, discrete wave equations do not have this property (such as the coupled anisotropic TTI wave equation (Zhang et al., 2011)) and require correct derivations of their adjoints. We concentrate here, as in part 1, on the acoustic case and follow an optimize-discretize approach, which means we write out the adjoint wave equation for the continuous case first and then discretize it, using finite difference operators of the same order as for the forward equation. With the variables defined as in part 1 and the data residual \\delta d(x,y,t; x_r, y_r) \\delta d(x,y,t; x_r, y_r) , located at x_r, y_r x_r, y_r (receiver locations) as the adjoint source, the continuous adjoint wave equation is given by: m(x,y) \\frac{\\mathrm{d}^2 v(t,x,y)}{\\mathrm{d}t^2}\\ -\\ \\Delta v(t,x,y)\\ -\\ \\eta(x,y) \\frac{\\mathrm{d} v(t,x,y)}{\\mathrm{d}t}\\ \\ =\\ \\ \\delta d(t,x,y;x_r, y_r) m(x,y) \\frac{\\mathrm{d}^2 v(t,x,y)}{\\mathrm{d}t^2}\\ -\\ \\Delta v(t,x,y)\\ -\\ \\eta(x,y) \\frac{\\mathrm{d} v(t,x,y)}{\\mathrm{d}t}\\ \\ =\\ \\ \\delta d(t,x,y;x_r, y_r) The adjoint acoustic wave equation is equivalent to the forward equation with the exception of the damping term \\eta(x,y) \\mathrm{d}v(t,x,y)/\\mathrm{d}t \\eta(x,y) \\mathrm{d}v(t,x,y)/\\mathrm{d}t , which contains a first time derivative and therefore has a change of sign in its adjoint. (A second derivative matrix is the same as its transpose, whereas a first derivative matrix is equal to its negative transpose and vice versa.) Following the pattern of part 1, we first define the discrete adjoint wavefield \\mathbf{v} \\mathbf{v} as a Devito TimeFunction object. For reasons we'll explain later, we do not need to save the adjoint wavefield: # NOT FOR MANUSCRIPT from examples.seismic import Model , demo_model , plot_velocity , plot_perturbation shape = ( 101 , 101 ) # Number of grid point (nx, nz) spacing = ( 10. , 10. ) # Grid spacing in m. The domain size is now 1km by 1km origin = ( 0. , 0. ) # Need origin to define relative source and receiver locations model = demo_model ( 'circle-isotropic' , vp = 3.0 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbpml = 40 ) # For the manuscript, we'll re-form the model using the Vp field from # this newly created model. vp = model . vp model0 = demo_model ( 'circle-isotropic' , vp = 2.5 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbpml = 40 ) t0 = 0. # Simulation starts a t=0 tn = 1000. # Simulation last 1 second (1000 ms) dt = model . critical_dt # Time step from model grid spacing nt = int ( 1 + ( tn - t0 ) / dt ) # Discrete time axis length time = np . linspace ( t0 , tn , nt ) # Discrete modelling time # NOT FOR MANUSCRIPT from devito import TimeFunction v = TimeFunction ( name = \"v\" , grid = model . grid , time_order = 2 , space_order = 4 , save = False ) Now symbolically set up the PDE: pde = model . m * v . dt2 - v . laplace - model . damp * v . dt As before, we then define a stencil: # NOT FOR MANUSCRIPT from devito import Eq from sympy import solve stencil_v = Eq ( v . backward , solve ( pde , v . backward )[ 0 ]) Just as for the forward wave equation, stencil_v defines the update for the adjoint wavefield of a single time step. The only difference is that, while the forward modeling propagator goes forward in time, the adjoint propagator goes backwards in time, since the initial time conditions for the forward propagator turn into final time conditions for the adjoint propagator. As for the forward stencil, we can write out the corresponding discrete expression for the update of the adjoint wavefield: \\mathbf{v}[\\text{time}-\\text{dt}] = 2\\mathbf{v}[\\text{time}] - \\mathbf{v}[\\text{time}+\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}}\\Delta \\mathbf{v}[\\text{time}], \\quad \\text{time} = n_{t-1} \\cdots 1 \\mathbf{v}[\\text{time}-\\text{dt}] = 2\\mathbf{v}[\\text{time}] - \\mathbf{v}[\\text{time}+\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}}\\Delta \\mathbf{v}[\\text{time}], \\quad \\text{time} = n_{t-1} \\cdots 1 with \\text{dt} \\text{dt} being the time stepping interval. Once again, this expression does not contain any (adjoint) source terms so far, which will be defined as a separate SparseFunction object. Since the source term for the adjoint wave equation is the difference between an observed and modeled shot record, we first define an (empty) shot record residual with 101 receivers and coordinates defined in rec_coords . We then set the data field rec.data of our shot record to be the data residual between the observed data d_obs and the predicted data d_pred . The symbolic residual source expression res_term for our adjoint wave equation is then obtained by injecting the data residual into the modeling scheme ( residual.inject ). Since we solve the time-stepping loop backwards in time, the res_term is used to update the previous adjoint wavefield v.backward , rather than the next wavefield. As in the forward modeling example, the source is scaled by \\mathrm{dt}^2/\\mathbf{m} \\mathrm{dt}^2/\\mathbf{m} . In Python, we have: # NOT FOR MANUSCRIPT from examples.seismic import Receiver nshots = 21 # Number of shots to create gradient from nreceivers = 101 # Number of receiver locations per shot # Recs are distributed across model, at depth of 20 m. z_extent , _ = model . domain_size z_locations = np . linspace ( 0 , z_extent , num = nreceivers ) rec_coords = np . array ([( 980 , z ) for z in z_locations ]) # NOT FOR MANUSCRIPT from examples.seismic import PointSource residual = PointSource ( name = 'residual' , ntime = nt , grid = model . grid , coordinates = rec_coords ) res_term = residual . inject ( field = v . backward , expr = residual * dt ** 2 / model . m , offset = model . nbpml ) # NOT FOR MANUSCRIPT rec = Receiver ( name = 'rec' , npoint = nreceivers , ntime = nt , grid = model . grid , coordinates = rec_coords ) # NOT FOR MANUSCRIPT from examples.seismic import RickerSource # At first, we want only a single shot. # Src is 5% across model, at depth of 500 m. z_locations = np . linspace ( 0 , z_extent , num = nshots ) src_coords = np . array ([( z_extent / 50 , z ) for z in z_locations ]) # NOT FOR MANUSCRIPT f0 = 0.010 # kHz, peak frequency. src = RickerSource ( name = 'src' , grid = model . grid , f0 = f0 , time = time , coordinates = src_coords [ nshots // 2 ]) # NOT FOR MANUSCRIPT plt . plot ( src . time , src . data ) plt . xlabel ( \"Time (ms)\" ) plt . ylabel ( \"Amplitude\" ) plt . show () # NOT FOR MANUSCRIPT # Generates Figure 1 from matplotlib.gridspec import GridSpec # Set up figure, grid, and parameters. fig = plt . figure ( figsize = ( 8 , 12 )) gs = GridSpec ( 3 , 2 ) ax0 = fig . add_subplot ( gs [: 2 , : 2 ]) ax1 = fig . add_subplot ( gs [ 2 , 0 ]) ax2 = fig . add_subplot ( gs [ 2 , 1 ]) extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], model . origin [ 1 ] + 1e-3 * model . shape [ 1 ] * model . spacing [ 1 ], model . origin [ 1 ]] model_param = dict ( vmin = 2.5 , vmax = 3.0 , cmap = \"GnBu\" , aspect = 1 , extent = extent ) diff_param = dict ( vmin =- 1 , vmax = 0 , cmap = \"GnBu\" , aspect = 1 , extent = extent ) # Part (a) im = ax0 . imshow ( np . transpose ( model . vp ), ** model_param ) ax0 . scatter ( * rec_coords . T / 1000 , lw = 0 , c = 'green' , s = 8 ) ax0 . scatter ( * src_coords . T / 1000 , lw = 0 , c = 'red' , s = 24 ) ax0 . set_ylabel ( 'Depth (km)' , fontsize = 14 ) ax0 . text ( 0.5 , 0.08 , \"model.vp\" , ha = \"center\" , color = 'k' , size = 18 ) ax0 . text ( 0.5 , 0.5 , \"3000 m/s\" , ha = \"center\" , va = 'center' , color = 'w' , size = 14 ) ax0 . text ( 0.8 , 0.5 , \"2500 m/s\" , ha = \"center\" , va = 'center' , color = 'navy' , size = 14 ) ax0 . text ( 0.04 , 0.04 , \"sources\" , ha = \"left\" , color = 'r' , size = 12 ) ax0 . text ( 0.96 , 0.04 , \"receivers\" , ha = \"right\" , color = 'green' , size = 12 ) ax0 . set_ylim ( 1 , 0 ) plt . setp ( ax0 . get_xticklabels (), fontsize = 12 ) plt . setp ( ax0 . get_yticklabels (), fontsize = 12 ) # Part (b) im = ax1 . imshow ( np . transpose ( model0 . vp ), ** model_param ) ax1 . set_xlabel ( 'X position (km)' , fontsize = 14 ) ax1 . set_yticklabels ([ 0 , '' , 0.5 , '' , 1 ]) ax1 . text ( 0.5 , 0.08 , \"model0.vp\" , ha = \"center\" , color = 'k' , size = 14 ) ax1 . set_ylabel ( 'Depth (km)' , fontsize = 14 ) plt . setp ( ax1 . get_xticklabels (), fontsize = 12 ) plt . setp ( ax1 . get_yticklabels (), fontsize = 12 ) # Part (c) im = ax2 . imshow ( np . transpose ( model0 . vp - model . vp ), ** diff_param ) ax2 . set_xlabel ( 'X position (km)' , fontsize = 14 ) ax2 . set_yticklabels ([]) ax2 . text ( 0.5 , 0.08 , \"model0.vp \u2013 model.vp\" , ha = \"center\" , color = 'w' , size = 14 ) ax2 . text ( 0.5 , 0.5 , \"\u2013500 m/s\" , ha = \"center\" , va = 'center' , color = 'w' , size = 12 ) ax2 . text ( 0.85 , 0.5 , \"0 m/s\" , ha = \"center\" , va = 'center' , color = 'w' , size = 12 ) plt . setp ( ax2 . get_xticklabels (), fontsize = 12 ) plt . setp ( ax2 . get_yticklabels (), fontsize = 12 ) plt . savefig ( \"../Figures/Figure_1.pdf\" ) plt . savefig ( \"../Figures/Figure_1.png\" , dpi = 400 ) plt . show () In this demonstration, there is no real data. Instead we will generate the 'observed' data via forward modeling with the true model model . The synthetic data is generated from the initial model model0 . The resulting data, and their difference, are shown in Figure 2. # NOT FOR MANUSCRIPT from examples.seismic.acoustic import AcousticWaveSolver solver = AcousticWaveSolver ( model , src , rec , space_order = 4 ) # Compute 'real' data with forward operator. obs , _ , _ = solver . forward ( src = src , m = model . m ) CustomCompiler: compiled /tmp/devito-gx10ovxj/7a282d6885f4ad3a7b16fd67992b9457900f0291.c [0.62 s] ========================================================================================= Section section_1<714,1> with OI=0.73 computed in 0.000 s [0.52 GFlops/s] Section section_2<714,101> with OI=1.37 computed in 0.001 s [2.20 GFlops/s] Section main<714,179,179> with OI=1.95 computed in 0.090 s [8.15 GFlops/s, 0.25 GPts/s] ========================================================================================= # NOT FOR MANUSCRIPT # Compute initial data with forward operator. pred , u0 , _ = solver . forward ( src = src , m = model0 . m , save = True ) CustomCompiler: compiled /tmp/devito-gx10ovxj/460b72ec62af10f5fed261f3a591dc9679cffa88.c [0.25 s] ========================================================================================= Section section_1<714,1> with OI=0.73 computed in 0.000 s [0.26 GFlops/s] Section section_2<714,101> with OI=1.37 computed in 0.001 s [1.86 GFlops/s] Section main<714,179,179> with OI=1.95 computed in 0.113 s [6.49 GFlops/s, 0.20 GPts/s] ========================================================================================= # NOT FOR MANUSCRIPT fig = plt . figure ( figsize = ( 15 , 5 )) extent = [ model . origin [ 0 ], # Horizontal min model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], tn / 1000 , # Vertical min (bottom) t0 / 1000 ] # Vertical max (top) ma = np . percentile ( obs . data , 99.5 ) params = dict ( vmin =- ma , vmax = ma , cmap = \"Greys\" , aspect = 1 , extent = extent ) text_params = dict ( ha = \"center\" , color = 'w' , size = 16 ) ax0 = fig . add_subplot ( 131 ) im = plt . imshow ( obs . data , ** params ) ax0 . set_ylabel ( 'Time (s)' , fontsize = 16 ) ax0 . text ( 0.5 , 0.08 , \"obs\" , ** text_params ) plt . xticks ( fontsize = 10 ) plt . yticks ( fontsize = 10 ) ax1 = fig . add_subplot ( 132 ) im = plt . imshow ( pred . data , ** params ) ax1 . set_xlabel ( 'Z position (km)' , fontsize = 16 ) ax1 . set_yticklabels ([]) ax1 . text ( 0.5 , 0.08 , \"pred\" , ** text_params ) plt . xticks ( fontsize = 10 ) plt . yticks ( fontsize = 10 ) ax2 = fig . add_subplot ( 133 ) im = plt . imshow ( pred . data - obs . data , ** params ) ax2 . set_yticklabels ([]) ax2 . text ( 0.5 , 0.08 , \"pred \u2013 obs\" , ** text_params ) plt . xticks ( fontsize = 10 ) plt . yticks ( fontsize = 10 ) plt . savefig ( \"../Figures/Figure2.pdf\" ) plt . savefig ( \"../Figures/Figure2.png\" , dpi = 400 ) plt . show () Figure 2. Shot records for a shot at a Z position of 0.5 km. (a) The observed data, using the known model with the high velocity disc, contains a perturbation not present in (b) the 'predicted' data, using the initial estimate of the model, which contais no disc. \u00a9 The residual. Finally, we create the full propagator by adding the residual source expression to our previously defined stencil and set the flag time_axis=Backward , to specify that the propagator runs in backwards in time: # NOT FOR MANUSCRIPT from devito import Operator , Backward op_adj = Operator ([ stencil_v ] + res_term , time_axis = Backward ) In contrast to forward modeling, we do not record any measurements at the surface since we are only interested in the adjoint wavefield itself. The full script for setting up the adjoint wave equation, including an animation of the adjoint wavefield is available in adjoint_modeling.ipynb . Computing the FWI gradient The goal of FWI is to estimate a discrete parametrization of the subsurface by minimizing the misfit between the observed shot records of a seismic survey and numerically modeled shot records. The predicted shot records are obtained by solving an individual wave equation per shot location and depend on the parametrization \\mathbf{m} \\mathbf{m} of our wave propagator. The most common function for measuring the data misfit between the observed and modeled data is the \\ell_2 \\ell_2 norm, which leads to the following objective function (Lions (1971), Tarantola (1984)): \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\hspace{.2cm} f(\\mathbf{m})= \\sum_{i=1}^{n_\\mathrm{s}} \\frac{1}{2} \\left\\lVert \\mathbf{d}^\\mathrm{pred}_i (\\mathbf{m}, \\mathbf{q}_i) - \\mathbf{d}_i^\\mathrm{obs} \\right\\rVert_2^2, \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\hspace{.2cm} f(\\mathbf{m})= \\sum_{i=1}^{n_\\mathrm{s}} \\frac{1}{2} \\left\\lVert \\mathbf{d}^\\mathrm{pred}_i (\\mathbf{m}, \\mathbf{q}_i) - \\mathbf{d}_i^\\mathrm{obs} \\right\\rVert_2^2, where the index i i runs over the total number of shots n_\\mathrm{s} n_\\mathrm{s} and the model parameters are the squared slowness. Optimization problems of this form are called nonlinear least-squares problems, since the predicted data modeled with the forward modeling propagator ( op_fwd() in part 1) depends nonlinearly on the unknown parameters \\mathbf{m} \\mathbf{m} . The full derivation of the FWI gradient using the adjoint state method is outside the scope of this tutorial, but conceptually we obtain the gradient by applying the chain rule and taking the partial derivative of the inverse wave equation \\mathbf{A}(\\mathbf{m})^{-1} \\mathbf{A}(\\mathbf{m})^{-1} with respect to \\mathbf{m} \\mathbf{m} , which yields the following expression (Plessix, 2006, Virieux and Operto, 2009): \\nabla f (\\mathbf{m})= - \\sum_{i=1}^{n_\\mathrm{s}} \\sum_{\\text{time}=1}^{n_t} \\mathbf{u}[\\text{time}]\\odot \\ddot{\\mathbf{v}}[\\text{time}]. \\nabla f (\\mathbf{m})= - \\sum_{i=1}^{n_\\mathrm{s}} \\sum_{\\text{time}=1}^{n_t} \\mathbf{u}[\\text{time}]\\odot \\ddot{\\mathbf{v}}[\\text{time}]. The inner sum \\text{time}=1,...,n_t \\text{time}=1,...,n_t runs over the number of computational time steps n_t n_t and \\ddot{\\mathbf{v}} \\ddot{\\mathbf{v}} denotes the second temporal derivative of the adjoint wavefield \\mathbf{v} \\mathbf{v} . Computing the gradient of Equation 3, therefore corresponds to performing the point-wise multiplication (denoted by the symbol \\odot \\odot ) of the forward wavefields with the second time derivative of the adjoint wavefield and summing over all time steps. To avoid the need to store the adjoint wavefield, the FWI gradient is calculated in the reverse time-loop while solving the adjoint wave equation. To compute the gradient \\mathbf{g} \\mathbf{g} for the current time step \\mathbf{v}[\\text{time}] \\mathbf{v}[\\text{time}] : \\mathbf{g} = \\mathbf{g} - \\frac{\\mathbf{v}[\\text{time-dt}] - 2\\mathbf{v}[\\text{time}] + \\mathbf{v}[\\text{time+dt}]}{\\mathrm{dt}^2} \\odot \\mathbf{u}[\\text{time}], \\quad \\text{time}=1 \\cdots n_{t-1} \\mathbf{g} = \\mathbf{g} - \\frac{\\mathbf{v}[\\text{time-dt}] - 2\\mathbf{v}[\\text{time}] + \\mathbf{v}[\\text{time+dt}]}{\\mathrm{dt}^2} \\odot \\mathbf{u}[\\text{time}], \\quad \\text{time}=1 \\cdots n_{t-1} The second time derivative of the adjoint wavefield is computed with a second order finite-difference stencil and uses the three adjoint wavefields that are kept in memory during the adjoint time loop (Equation 2). In Devito we define the gradient as a Function since the gradient is computed as the sum over all time steps and therefore has no time dependence: # NOT FOR MANUSCRIPT from devito import TimeFunction , Function # NOT FOR MANUSCRIPT # This is the same u as in Part 1. u = TimeFunction ( name = \"u\" , grid = model . grid , time_order = 2 , space_order = 4 , save = True , time_dim = nt ) grad = Function ( name = \"grad\" , grid = model . grid ) The update for the gradient as defined in Equations 4 and 5 is then: grad_update = Eq ( grad , grad - u * v . dt2 ) Now we must add the gradient update expression to the adjoint propagator op_grad . This yields a single symbolic expression with update instructions for both the adjoint wavefield and the gradient: op_grad = Operator ([ stencil_v ] + res_term + [ grad_update ], time_axis = Backward ) Solving the adjoint wave equation by running the following now computes the FWI gradient for a single source. Its value is stored in grad.data . op_grad ( u = u0 , v = v , m = model0 . m , residual = pred . data - obs . data , time = nt , dt = dt ) CustomCompiler: compiled /tmp/devito-gx10ovxj/ec66845144ec0c1fb8e1bb5f532cda21c551712e.c [0.28 s] ========================================================================================= Section section_1<714,101> with OI=0.80 computed in 0.003 s [1.18 GFlops/s] Section main<714,179,179> with OI=2.83 computed in 0.303 s [6.11 GFlops/s, 0.08 GPts/s] ========================================================================================= # NOT FOR MANUSCIPT plt . figure ( figsize = ( 8 , 8 )) plt . imshow ( np . transpose ( grad . data [ 40 : - 40 , 40 : - 40 ]), extent = extent , cmap = 'RdBu' , vmin =- 1e3 , vmax = 1e3 ) plt . colorbar ( shrink = 0.75 ) plt . show () # NOT FOR MANUSCRIPT tmp = grad . copy () Now we can iterate over all the shot locations, running the same sequence of commands each time. # NOT FOR MANUSCRIPT from devito import configuration configuration [ 'log_level' ] = 'WARNING' # Create the symbols. u0 = TimeFunction ( name = 'u0' , grid = model . grid , time_order = 2 , space_order = 4 , save = True , time_dim = nt ) u = TimeFunction ( name = 'u' , grid = model . grid , time_order = 2 , space_order = 4 , save = True , time_dim = nt ) v = TimeFunction ( name = 'v' , grid = model . grid , time_order = 2 , space_order = 4 , save = False ) # Define the wave equation, but with a negated damping term eqn = model . m * v . dt2 - v . laplace - model . damp * v . dt # Use SymPy to rearrange the equation into a stencil expression. stencil = Eq ( v . backward , solve ( eqn , v . backward )[ 0 ]) # Define the residual injection. residual = PointSource ( name = 'residual' , ntime = nt , coordinates = rec_coords , grid = model . grid ) res_term = residual . inject ( field = v . backward , expr = residual * dt ** 2 / model . m , offset = model . nbpml ) # Correlate u and v for the current time step and add it to the gradient. grad = Function ( name = 'grad' , grid = model . grid , dtype = model . m . dtype ) grad_update = Eq ( grad , grad - u * v . dt2 ) # Compose the operator. op_grad2 = Operator ([ stencil ] + res_term + [ grad_update ], time_axis = Backward ) # Iterate over the shots. for i in range ( nshots ): print ( \"Source {} of {} \" . format ( i , nshots )) # Opdate source location. src . coordinates . data [ 0 , :] = src_coords [ i ] # Generate data from true model and current model estimate. obs , _ , _ = solver . forward ( src = src , m = model . m ) pred , _ , _ = solver . forward ( src = src , m = model0 . m , u = u0 , save = True ) # Compute the gradient from the residual. v = TimeFunction ( name = 'v' , grid = model . grid , time_order = 2 , space_order = 4 ) residual . data [:] = pred . data - obs . data op_grad2 ( u = u0 , v = v , m = model0 . m , residual = residual , grad = grad , dt = dt ) configuration [ 'log_level' ] = 'INFO' Source 0 of 21 Source 1 of 21 Source 2 of 21 Source 3 of 21 Source 4 of 21 Source 5 of 21 Source 6 of 21 Source 7 of 21 Source 8 of 21 Source 9 of 21 Source 10 of 21 Source 11 of 21 Source 12 of 21 Source 13 of 21 Source 14 of 21 Source 15 of 21 Source 16 of 21 Source 17 of 21 Source 18 of 21 Source 19 of 21 Source 20 of 21 # NOT FOR MANUSCRIPT plt . figure ( figsize = ( 8 , 8 )) plt . imshow ( np . transpose ( grad . data )[ 40 : - 40 , 40 : - 40 ], extent = extent , vmin =- 1e4 , vmax = 1e4 , cmap = 'RdBu' ) plt . colorbar ( shrink = 0.75 ) plt . show () # NOT FOR MANUSCRIPT # Generates Figure 3 from plot_utils import add_subplot_axes fig = plt . figure ( figsize = ( 12 , 6 )) ax0 = fig . add_subplot ( 121 ) ma = 1e3 im = ax0 . imshow ( np . transpose ( tmp . data [ 40 : - 40 , 40 : - 40 ]), extent = extent , cmap = 'RdBu' , vmin =- ma , vmax = ma ) cax = add_subplot_axes ( ax0 , [ 0.3 , 0.075 , 0.4 , 0.02 ]) fig . colorbar ( im , cax = cax , orientation = 'horizontal' ) cax . text ( 0 , 1 , \" {:.0f} \" . format ( - ma ), ha = 'right' , va = 'top' , size = 10 ) cax . text ( 1 , 1 , \" {:.0f} \" . format ( ma ), ha = 'left' , va = 'top' , size = 10 ) cax . set_axis_off () ax0 . text ( 0.5 , 0.05 , \"Shot @ 500 m\" , ha = 'center' , va = 'center' , size = 16 ) ax0 . set_xlabel ( 'X position (m)' , fontsize = 16 ) ax0 . set_ylabel ( 'Z position (m)' , fontsize = 16 ) plt . setp ( ax0 . get_xticklabels (), fontsize = 12 ) plt . setp ( ax0 . get_yticklabels (), fontsize = 12 ) ax1 = fig . add_subplot ( 122 ) ma = 1e4 im = ax1 . imshow ( np . transpose ( grad . data [ 40 : - 40 , 40 : - 40 ]), extent = extent , cmap = 'RdBu' , vmin =- ma , vmax = ma ) cax = add_subplot_axes ( ax1 , [ 0.3 , 0.075 , 0.4 , 0.02 ]) fig . colorbar ( im , cax = cax , orientation = 'horizontal' ) cax . text ( 0 , 1 , \" {:.0f} \" . format ( - ma ), ha = 'right' , va = 'top' , size = 10 ) cax . text ( 1 , 1 , \" {:.0f} \" . format ( ma ), ha = 'left' , va = 'top' , size = 10 ) cax . set_axis_off () ax1 . text ( 0.5 , 0.05 , \"All {} shots\" . format ( nshots ), ha = 'center' , va = 'center' , size = 16 ) ax1 . set_xlabel ( 'X position (m)' , fontsize = 16 ) ax1 . set_yticklabels ([]) plt . setp ( ax1 . get_xticklabels (), fontsize = 12 ) plt . setp ( ax1 . get_yticklabels (), fontsize = 12 ) plt . savefig ( \"../Figures/Figure3.pdf\" ) plt . savefig ( \"../Figures/Figure3.png\" , dpi = 400 ) plt . show () Figure 3. Gradient plots for (a) a single shot at 0.5 km and (b) the sum of all shots. This gradient can then be used for a simple gradient descent optimization loop, as illustrated at the end of the notebook adjoint_modeling.ipynb . After each update, a new gradient is computed for the new velocity model until sufficient decrease of the objective or chosen number of iteration is reached. A detailed treatment of optimization and more advanced algorithms will be described in the third and final part of this tutorial series. Verification (do not include in manuscipt) The next step of the adjoint modeling and gradient part is verification with unit testing, i.e. we ensure that the adjoints and gradients are implemented correctly. Incorrect adjoints can lead to unpredictable behaviour during and inversion and in the worst case cause slower convergence or convergence to wrong solutions. Since our forward-adjoint wave equation solvers correspond to forward-adjoint pairs, we need to ensure that the adjoint defined dot test holds within machine precision (see **`tests/test_adjointA.py`** for the dot test). Furthermore, we verify the correct implementation of the FWI gradient by ensuring that using the gradient leads to first order convergence. The gradient test can be found in **`tests/test_gradient.py`**. Conclusions We need the gradient of the FWI objective function in order to find the optimal solution. It is computed by solving adjoint wave equations and summing the point-wise product of forward and adjoint wavefields over all time steps. Using Devito, the adjoint wave equation is set up in a similar fashion as the forward wave equation, with the main difference being the (adjoint) source, which is the residual between the observed and predicted shot records. With the ability to model shot records and compute gradients of the FWI objective function, we are ready to demonstrate how to set up more gradient-based algorithms for FWI in Part 3 next month. Acknowledgments This research was carried out as part of the SINBAD II project with the support of the member organizations of the SINBAD Consortium. This work was financially supported in part by EPSRC grant EP/L000407/1 and the Imperial College London Intel Parallel Computing Centre. References [1] Michael Lange, Navjot Kukreja, Mathias Louboutin, Fabio Luporini, Felippe Vieira Zacarias, Vincenzo Pandolfo, Paulius Velesko, Paulius Kazakas, and Gerard Gorman. Devito: Towards a generic finite difference DSL using symbolic python. In 6 th Workshop on Python for High-Performance and Scientific Computing, pages 67\u201375, 11 2016. doi: 10.1109/PyHPC.2016.9. [2] J. L. Lions. Optimal control of systems governed by partial differential equations. Springer-Verlag Berlin Heidelberg, 1 st edition, 1971. ISBN 978-3-642-65026-0. [3] Mathias Louboutin, Philipp A. Witte, Michael Lange, Navjot Kukreja, Fabio Luporini, Gerard Gorman, and Felix J. Herrmann. Full-waveform inversion - part 1: forward modeling. Submitted to The Leading Edge for the tutorial section on October 30, 2017., 2017. [4] Aaron Meurer, Christopher P. Smith, Mateusz Paprocki, Ondr\u030cej C\u030certi\u0301k, Sergey B. Kirpichev, Matthew Rocklin, AMiT Kumar, Sergiu Ivanov, Jason K. Moore, Sartaj Singh, Thilina Rathnayake, Sean Vig, Brian E. Granger, Richard P. Muller, Francesco Bonazzi, Harsh Gupta, Shivam Vats, Fredrik Johansson, Fabian Pedregosa, Matthew J. Curry, Andy R. Terrel, S\u030cte\u030cpa\u0301n Rouc\u030cka, Ashutosh Saboo, Isuru Fernando, Sumith Kulal, Robert Cimrman, and Anthony Scopatz. Sympy: symbolic computing in python. Peer J Computer Science, 3:e103, January 2017. ISSN 2376-5992. doi: 10.7717/peerj-cs.103. URL https: //doi.org/10.7717/peerj-cs.103. [5] R.-E. Plessix. A review of the adjoint-state method for computing the gradient of a functional with geophysical applications. Geophysical Journal International, 167(2):495, 2006. doi: 10.1111/j.1365-246X.2006.02978.x. URL + http://dx.doi.org/10.1111/j.1365-246X.2006.02978.x [6] Albert Tarantola. Inversion of seismic reflection data in the acoustic approximation. GEOPHYSICS, 49(8): 1259\u20131266, 1984. doi: 10.1190/1.1441754. URL https://doi.org/10.1190/1.1441754 [7] J. Virieux and S. Operto. An overview of full-waveform inversion in exploration geophysics. GEOPHYSICS, 74 (5):WCC1\u2013WCC26, 2009. doi: 10.1190/1.3238367. URL http://library.seg.org/doi/abs/10.1190/1.3238367 [8] Yu Zhang, Houzhu Zhang, and Guanquan Zhang. A stable tti reverse time migration and its implementation. GEOPHYSICS, 76(3):WA3\u2013WA11, 2011. doi: 10.1190/1.3554411. URL https://doi.org/10.1190/1.3554411 . \u00a9 2017 The authors \u2014 licensed CC-BY-SA","title":"Adjoint Modeling"},{"location":"tutorials/TLE_Adjoint/#geophysics-tutorial","text":"","title":"Geophysics tutorial"},{"location":"tutorials/TLE_Adjoint/#full-waveform-inversion-2-adjoint-modeling","text":"Mathias Louboutin 1 *, Philipp Witte 1 , Michael Lange 2 , Navjot Kukreja 2 , Fabio Luporini 2 , Gerard Gorman 2 , and Felix J. Herrmann 1,3 1 Seismic Laboratory for Imaging and Modeling (SLIM), The University of British Columbia 2 Imperial College London, London, UK 3 now at Georgia Institute of Technology, USA Corresponding author: mloubout@eoas.ubc.ca","title":"Full-waveform inversion 2: adjoint modeling"},{"location":"tutorials/TLE_Adjoint/#introduction","text":"This tutorial is the second part of a three part tutorial series on full-waveform inversion (FWI), in which we provide a step by step walk through of setting up forward and adjoint wave equation solvers and an optimization framework for inversion. In Part 1 (Louboutin et al., 2017), we showed how to use Devito to set up and solve acoustic wave equations with (impulsive) seismic sources and sample wavefields at the receiver locations to forward model shot records. In the second part of this tutorial series, we will discuss how to set up and solve adjoint wave equations with Devito and from that, how we can calculate gradients and function values of the FWI objective function. The gradient of FWI is most commonly computed via the adjoint state method, by cross-correlating forward and adjoint wavefields and summing the contributions over all time steps (Plessix, 2006). Calculating the gradient for one source location consists of three steps: Solve the forward wave equation to create a shot record. The time varying wavefield must be stored for use in step 3; techniques such as subsampling can be used to reduce the storage requirements. Compute the data residual (or misfit) between the predicted and observed data. Solve the corresponding discrete adjoint model using the data residual as the source. Within the adjoint (reverse) time loop, cross correlate the second time derivative of the adjoint wavefield with the forward wavefield. These cross correlations are summed to form the gradient. We start with the definition and derivation of the adjoint wave equation and its Devito stencil and then show how to compute the gradient of the conventional least squares FWI misfit function. As usual, this tutorial is accompanied by all the code you need to reproduce the figures. Go to github.com/seg/tutorials-2018 and follow the links.","title":"Introduction"},{"location":"tutorials/TLE_Adjoint/#a-simple-experiment","text":"To demonstrate the gradient computation in the simplest possible way, we perform a small seismic transmission experiment with a circular imaging phantom, i.e. a constant velocity model with a circular high velocity inclusion in its centre, as shown in Figure 1. For a transmission experiment, we place 21 seismic sources on the left-hand side of the model and 101 receivers on the right-hand side. We will use the forward propagator from part 1 to independently model the 21 \"observed\" shot records using the true model. As the initial model for our gradient calculation, we use a constant velocity model with the same velocity as the true model, but without the circular velocity perturbation. We will then model the 21 predicted shot records for the initial model, calculate the data residual and gradient for each shot, and sum them to obtain the full gradient. ++ Figure 1 is generated later in the manuscript ++ Figure 1: (a) The velocity model, with sources and receivers arranged vertically. (b) The initial estimate. \u00a9 The difference between the model and the initial estimate.","title":"A simple experiment"},{"location":"tutorials/TLE_Adjoint/#the-adjoint-wave-equation","text":"Adjoint wave equations are a main component in seismic inversion algorithms and are required for computing gradients of both linear and non-linear objective functions. To ensure stability of the adjoint modeling scheme and the expected convergence of inversion algorithms, it is very important that the adjoint wave equation is in fact the adjoint (transpose) of the forward wave equation. The derivation of the adjoint wave equation in the acoustic case is simple, as it is self-adjoint if we ignore the absorbing boundaries for the moment. However, in the general case, discrete wave equations do not have this property (such as the coupled anisotropic TTI wave equation (Zhang et al., 2011)) and require correct derivations of their adjoints. We concentrate here, as in part 1, on the acoustic case and follow an optimize-discretize approach, which means we write out the adjoint wave equation for the continuous case first and then discretize it, using finite difference operators of the same order as for the forward equation. With the variables defined as in part 1 and the data residual \\delta d(x,y,t; x_r, y_r) \\delta d(x,y,t; x_r, y_r) , located at x_r, y_r x_r, y_r (receiver locations) as the adjoint source, the continuous adjoint wave equation is given by: m(x,y) \\frac{\\mathrm{d}^2 v(t,x,y)}{\\mathrm{d}t^2}\\ -\\ \\Delta v(t,x,y)\\ -\\ \\eta(x,y) \\frac{\\mathrm{d} v(t,x,y)}{\\mathrm{d}t}\\ \\ =\\ \\ \\delta d(t,x,y;x_r, y_r) m(x,y) \\frac{\\mathrm{d}^2 v(t,x,y)}{\\mathrm{d}t^2}\\ -\\ \\Delta v(t,x,y)\\ -\\ \\eta(x,y) \\frac{\\mathrm{d} v(t,x,y)}{\\mathrm{d}t}\\ \\ =\\ \\ \\delta d(t,x,y;x_r, y_r) The adjoint acoustic wave equation is equivalent to the forward equation with the exception of the damping term \\eta(x,y) \\mathrm{d}v(t,x,y)/\\mathrm{d}t \\eta(x,y) \\mathrm{d}v(t,x,y)/\\mathrm{d}t , which contains a first time derivative and therefore has a change of sign in its adjoint. (A second derivative matrix is the same as its transpose, whereas a first derivative matrix is equal to its negative transpose and vice versa.) Following the pattern of part 1, we first define the discrete adjoint wavefield \\mathbf{v} \\mathbf{v} as a Devito TimeFunction object. For reasons we'll explain later, we do not need to save the adjoint wavefield: # NOT FOR MANUSCRIPT from examples.seismic import Model , demo_model , plot_velocity , plot_perturbation shape = ( 101 , 101 ) # Number of grid point (nx, nz) spacing = ( 10. , 10. ) # Grid spacing in m. The domain size is now 1km by 1km origin = ( 0. , 0. ) # Need origin to define relative source and receiver locations model = demo_model ( 'circle-isotropic' , vp = 3.0 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbpml = 40 ) # For the manuscript, we'll re-form the model using the Vp field from # this newly created model. vp = model . vp model0 = demo_model ( 'circle-isotropic' , vp = 2.5 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbpml = 40 ) t0 = 0. # Simulation starts a t=0 tn = 1000. # Simulation last 1 second (1000 ms) dt = model . critical_dt # Time step from model grid spacing nt = int ( 1 + ( tn - t0 ) / dt ) # Discrete time axis length time = np . linspace ( t0 , tn , nt ) # Discrete modelling time # NOT FOR MANUSCRIPT from devito import TimeFunction v = TimeFunction ( name = \"v\" , grid = model . grid , time_order = 2 , space_order = 4 , save = False ) Now symbolically set up the PDE: pde = model . m * v . dt2 - v . laplace - model . damp * v . dt As before, we then define a stencil: # NOT FOR MANUSCRIPT from devito import Eq from sympy import solve stencil_v = Eq ( v . backward , solve ( pde , v . backward )[ 0 ]) Just as for the forward wave equation, stencil_v defines the update for the adjoint wavefield of a single time step. The only difference is that, while the forward modeling propagator goes forward in time, the adjoint propagator goes backwards in time, since the initial time conditions for the forward propagator turn into final time conditions for the adjoint propagator. As for the forward stencil, we can write out the corresponding discrete expression for the update of the adjoint wavefield: \\mathbf{v}[\\text{time}-\\text{dt}] = 2\\mathbf{v}[\\text{time}] - \\mathbf{v}[\\text{time}+\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}}\\Delta \\mathbf{v}[\\text{time}], \\quad \\text{time} = n_{t-1} \\cdots 1 \\mathbf{v}[\\text{time}-\\text{dt}] = 2\\mathbf{v}[\\text{time}] - \\mathbf{v}[\\text{time}+\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}}\\Delta \\mathbf{v}[\\text{time}], \\quad \\text{time} = n_{t-1} \\cdots 1 with \\text{dt} \\text{dt} being the time stepping interval. Once again, this expression does not contain any (adjoint) source terms so far, which will be defined as a separate SparseFunction object. Since the source term for the adjoint wave equation is the difference between an observed and modeled shot record, we first define an (empty) shot record residual with 101 receivers and coordinates defined in rec_coords . We then set the data field rec.data of our shot record to be the data residual between the observed data d_obs and the predicted data d_pred . The symbolic residual source expression res_term for our adjoint wave equation is then obtained by injecting the data residual into the modeling scheme ( residual.inject ). Since we solve the time-stepping loop backwards in time, the res_term is used to update the previous adjoint wavefield v.backward , rather than the next wavefield. As in the forward modeling example, the source is scaled by \\mathrm{dt}^2/\\mathbf{m} \\mathrm{dt}^2/\\mathbf{m} . In Python, we have: # NOT FOR MANUSCRIPT from examples.seismic import Receiver nshots = 21 # Number of shots to create gradient from nreceivers = 101 # Number of receiver locations per shot # Recs are distributed across model, at depth of 20 m. z_extent , _ = model . domain_size z_locations = np . linspace ( 0 , z_extent , num = nreceivers ) rec_coords = np . array ([( 980 , z ) for z in z_locations ]) # NOT FOR MANUSCRIPT from examples.seismic import PointSource residual = PointSource ( name = 'residual' , ntime = nt , grid = model . grid , coordinates = rec_coords ) res_term = residual . inject ( field = v . backward , expr = residual * dt ** 2 / model . m , offset = model . nbpml ) # NOT FOR MANUSCRIPT rec = Receiver ( name = 'rec' , npoint = nreceivers , ntime = nt , grid = model . grid , coordinates = rec_coords ) # NOT FOR MANUSCRIPT from examples.seismic import RickerSource # At first, we want only a single shot. # Src is 5% across model, at depth of 500 m. z_locations = np . linspace ( 0 , z_extent , num = nshots ) src_coords = np . array ([( z_extent / 50 , z ) for z in z_locations ]) # NOT FOR MANUSCRIPT f0 = 0.010 # kHz, peak frequency. src = RickerSource ( name = 'src' , grid = model . grid , f0 = f0 , time = time , coordinates = src_coords [ nshots // 2 ]) # NOT FOR MANUSCRIPT plt . plot ( src . time , src . data ) plt . xlabel ( \"Time (ms)\" ) plt . ylabel ( \"Amplitude\" ) plt . show () # NOT FOR MANUSCRIPT # Generates Figure 1 from matplotlib.gridspec import GridSpec # Set up figure, grid, and parameters. fig = plt . figure ( figsize = ( 8 , 12 )) gs = GridSpec ( 3 , 2 ) ax0 = fig . add_subplot ( gs [: 2 , : 2 ]) ax1 = fig . add_subplot ( gs [ 2 , 0 ]) ax2 = fig . add_subplot ( gs [ 2 , 1 ]) extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], model . origin [ 1 ] + 1e-3 * model . shape [ 1 ] * model . spacing [ 1 ], model . origin [ 1 ]] model_param = dict ( vmin = 2.5 , vmax = 3.0 , cmap = \"GnBu\" , aspect = 1 , extent = extent ) diff_param = dict ( vmin =- 1 , vmax = 0 , cmap = \"GnBu\" , aspect = 1 , extent = extent ) # Part (a) im = ax0 . imshow ( np . transpose ( model . vp ), ** model_param ) ax0 . scatter ( * rec_coords . T / 1000 , lw = 0 , c = 'green' , s = 8 ) ax0 . scatter ( * src_coords . T / 1000 , lw = 0 , c = 'red' , s = 24 ) ax0 . set_ylabel ( 'Depth (km)' , fontsize = 14 ) ax0 . text ( 0.5 , 0.08 , \"model.vp\" , ha = \"center\" , color = 'k' , size = 18 ) ax0 . text ( 0.5 , 0.5 , \"3000 m/s\" , ha = \"center\" , va = 'center' , color = 'w' , size = 14 ) ax0 . text ( 0.8 , 0.5 , \"2500 m/s\" , ha = \"center\" , va = 'center' , color = 'navy' , size = 14 ) ax0 . text ( 0.04 , 0.04 , \"sources\" , ha = \"left\" , color = 'r' , size = 12 ) ax0 . text ( 0.96 , 0.04 , \"receivers\" , ha = \"right\" , color = 'green' , size = 12 ) ax0 . set_ylim ( 1 , 0 ) plt . setp ( ax0 . get_xticklabels (), fontsize = 12 ) plt . setp ( ax0 . get_yticklabels (), fontsize = 12 ) # Part (b) im = ax1 . imshow ( np . transpose ( model0 . vp ), ** model_param ) ax1 . set_xlabel ( 'X position (km)' , fontsize = 14 ) ax1 . set_yticklabels ([ 0 , '' , 0.5 , '' , 1 ]) ax1 . text ( 0.5 , 0.08 , \"model0.vp\" , ha = \"center\" , color = 'k' , size = 14 ) ax1 . set_ylabel ( 'Depth (km)' , fontsize = 14 ) plt . setp ( ax1 . get_xticklabels (), fontsize = 12 ) plt . setp ( ax1 . get_yticklabels (), fontsize = 12 ) # Part (c) im = ax2 . imshow ( np . transpose ( model0 . vp - model . vp ), ** diff_param ) ax2 . set_xlabel ( 'X position (km)' , fontsize = 14 ) ax2 . set_yticklabels ([]) ax2 . text ( 0.5 , 0.08 , \"model0.vp \u2013 model.vp\" , ha = \"center\" , color = 'w' , size = 14 ) ax2 . text ( 0.5 , 0.5 , \"\u2013500 m/s\" , ha = \"center\" , va = 'center' , color = 'w' , size = 12 ) ax2 . text ( 0.85 , 0.5 , \"0 m/s\" , ha = \"center\" , va = 'center' , color = 'w' , size = 12 ) plt . setp ( ax2 . get_xticklabels (), fontsize = 12 ) plt . setp ( ax2 . get_yticklabels (), fontsize = 12 ) plt . savefig ( \"../Figures/Figure_1.pdf\" ) plt . savefig ( \"../Figures/Figure_1.png\" , dpi = 400 ) plt . show () In this demonstration, there is no real data. Instead we will generate the 'observed' data via forward modeling with the true model model . The synthetic data is generated from the initial model model0 . The resulting data, and their difference, are shown in Figure 2. # NOT FOR MANUSCRIPT from examples.seismic.acoustic import AcousticWaveSolver solver = AcousticWaveSolver ( model , src , rec , space_order = 4 ) # Compute 'real' data with forward operator. obs , _ , _ = solver . forward ( src = src , m = model . m ) CustomCompiler: compiled /tmp/devito-gx10ovxj/7a282d6885f4ad3a7b16fd67992b9457900f0291.c [0.62 s] ========================================================================================= Section section_1<714,1> with OI=0.73 computed in 0.000 s [0.52 GFlops/s] Section section_2<714,101> with OI=1.37 computed in 0.001 s [2.20 GFlops/s] Section main<714,179,179> with OI=1.95 computed in 0.090 s [8.15 GFlops/s, 0.25 GPts/s] ========================================================================================= # NOT FOR MANUSCRIPT # Compute initial data with forward operator. pred , u0 , _ = solver . forward ( src = src , m = model0 . m , save = True ) CustomCompiler: compiled /tmp/devito-gx10ovxj/460b72ec62af10f5fed261f3a591dc9679cffa88.c [0.25 s] ========================================================================================= Section section_1<714,1> with OI=0.73 computed in 0.000 s [0.26 GFlops/s] Section section_2<714,101> with OI=1.37 computed in 0.001 s [1.86 GFlops/s] Section main<714,179,179> with OI=1.95 computed in 0.113 s [6.49 GFlops/s, 0.20 GPts/s] ========================================================================================= # NOT FOR MANUSCRIPT fig = plt . figure ( figsize = ( 15 , 5 )) extent = [ model . origin [ 0 ], # Horizontal min model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], tn / 1000 , # Vertical min (bottom) t0 / 1000 ] # Vertical max (top) ma = np . percentile ( obs . data , 99.5 ) params = dict ( vmin =- ma , vmax = ma , cmap = \"Greys\" , aspect = 1 , extent = extent ) text_params = dict ( ha = \"center\" , color = 'w' , size = 16 ) ax0 = fig . add_subplot ( 131 ) im = plt . imshow ( obs . data , ** params ) ax0 . set_ylabel ( 'Time (s)' , fontsize = 16 ) ax0 . text ( 0.5 , 0.08 , \"obs\" , ** text_params ) plt . xticks ( fontsize = 10 ) plt . yticks ( fontsize = 10 ) ax1 = fig . add_subplot ( 132 ) im = plt . imshow ( pred . data , ** params ) ax1 . set_xlabel ( 'Z position (km)' , fontsize = 16 ) ax1 . set_yticklabels ([]) ax1 . text ( 0.5 , 0.08 , \"pred\" , ** text_params ) plt . xticks ( fontsize = 10 ) plt . yticks ( fontsize = 10 ) ax2 = fig . add_subplot ( 133 ) im = plt . imshow ( pred . data - obs . data , ** params ) ax2 . set_yticklabels ([]) ax2 . text ( 0.5 , 0.08 , \"pred \u2013 obs\" , ** text_params ) plt . xticks ( fontsize = 10 ) plt . yticks ( fontsize = 10 ) plt . savefig ( \"../Figures/Figure2.pdf\" ) plt . savefig ( \"../Figures/Figure2.png\" , dpi = 400 ) plt . show () Figure 2. Shot records for a shot at a Z position of 0.5 km. (a) The observed data, using the known model with the high velocity disc, contains a perturbation not present in (b) the 'predicted' data, using the initial estimate of the model, which contais no disc. \u00a9 The residual. Finally, we create the full propagator by adding the residual source expression to our previously defined stencil and set the flag time_axis=Backward , to specify that the propagator runs in backwards in time: # NOT FOR MANUSCRIPT from devito import Operator , Backward op_adj = Operator ([ stencil_v ] + res_term , time_axis = Backward ) In contrast to forward modeling, we do not record any measurements at the surface since we are only interested in the adjoint wavefield itself. The full script for setting up the adjoint wave equation, including an animation of the adjoint wavefield is available in adjoint_modeling.ipynb .","title":"The adjoint wave equation"},{"location":"tutorials/TLE_Adjoint/#computing-the-fwi-gradient","text":"The goal of FWI is to estimate a discrete parametrization of the subsurface by minimizing the misfit between the observed shot records of a seismic survey and numerically modeled shot records. The predicted shot records are obtained by solving an individual wave equation per shot location and depend on the parametrization \\mathbf{m} \\mathbf{m} of our wave propagator. The most common function for measuring the data misfit between the observed and modeled data is the \\ell_2 \\ell_2 norm, which leads to the following objective function (Lions (1971), Tarantola (1984)): \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\hspace{.2cm} f(\\mathbf{m})= \\sum_{i=1}^{n_\\mathrm{s}} \\frac{1}{2} \\left\\lVert \\mathbf{d}^\\mathrm{pred}_i (\\mathbf{m}, \\mathbf{q}_i) - \\mathbf{d}_i^\\mathrm{obs} \\right\\rVert_2^2, \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\hspace{.2cm} f(\\mathbf{m})= \\sum_{i=1}^{n_\\mathrm{s}} \\frac{1}{2} \\left\\lVert \\mathbf{d}^\\mathrm{pred}_i (\\mathbf{m}, \\mathbf{q}_i) - \\mathbf{d}_i^\\mathrm{obs} \\right\\rVert_2^2, where the index i i runs over the total number of shots n_\\mathrm{s} n_\\mathrm{s} and the model parameters are the squared slowness. Optimization problems of this form are called nonlinear least-squares problems, since the predicted data modeled with the forward modeling propagator ( op_fwd() in part 1) depends nonlinearly on the unknown parameters \\mathbf{m} \\mathbf{m} . The full derivation of the FWI gradient using the adjoint state method is outside the scope of this tutorial, but conceptually we obtain the gradient by applying the chain rule and taking the partial derivative of the inverse wave equation \\mathbf{A}(\\mathbf{m})^{-1} \\mathbf{A}(\\mathbf{m})^{-1} with respect to \\mathbf{m} \\mathbf{m} , which yields the following expression (Plessix, 2006, Virieux and Operto, 2009): \\nabla f (\\mathbf{m})= - \\sum_{i=1}^{n_\\mathrm{s}} \\sum_{\\text{time}=1}^{n_t} \\mathbf{u}[\\text{time}]\\odot \\ddot{\\mathbf{v}}[\\text{time}]. \\nabla f (\\mathbf{m})= - \\sum_{i=1}^{n_\\mathrm{s}} \\sum_{\\text{time}=1}^{n_t} \\mathbf{u}[\\text{time}]\\odot \\ddot{\\mathbf{v}}[\\text{time}]. The inner sum \\text{time}=1,...,n_t \\text{time}=1,...,n_t runs over the number of computational time steps n_t n_t and \\ddot{\\mathbf{v}} \\ddot{\\mathbf{v}} denotes the second temporal derivative of the adjoint wavefield \\mathbf{v} \\mathbf{v} . Computing the gradient of Equation 3, therefore corresponds to performing the point-wise multiplication (denoted by the symbol \\odot \\odot ) of the forward wavefields with the second time derivative of the adjoint wavefield and summing over all time steps. To avoid the need to store the adjoint wavefield, the FWI gradient is calculated in the reverse time-loop while solving the adjoint wave equation. To compute the gradient \\mathbf{g} \\mathbf{g} for the current time step \\mathbf{v}[\\text{time}] \\mathbf{v}[\\text{time}] : \\mathbf{g} = \\mathbf{g} - \\frac{\\mathbf{v}[\\text{time-dt}] - 2\\mathbf{v}[\\text{time}] + \\mathbf{v}[\\text{time+dt}]}{\\mathrm{dt}^2} \\odot \\mathbf{u}[\\text{time}], \\quad \\text{time}=1 \\cdots n_{t-1} \\mathbf{g} = \\mathbf{g} - \\frac{\\mathbf{v}[\\text{time-dt}] - 2\\mathbf{v}[\\text{time}] + \\mathbf{v}[\\text{time+dt}]}{\\mathrm{dt}^2} \\odot \\mathbf{u}[\\text{time}], \\quad \\text{time}=1 \\cdots n_{t-1} The second time derivative of the adjoint wavefield is computed with a second order finite-difference stencil and uses the three adjoint wavefields that are kept in memory during the adjoint time loop (Equation 2). In Devito we define the gradient as a Function since the gradient is computed as the sum over all time steps and therefore has no time dependence: # NOT FOR MANUSCRIPT from devito import TimeFunction , Function # NOT FOR MANUSCRIPT # This is the same u as in Part 1. u = TimeFunction ( name = \"u\" , grid = model . grid , time_order = 2 , space_order = 4 , save = True , time_dim = nt ) grad = Function ( name = \"grad\" , grid = model . grid ) The update for the gradient as defined in Equations 4 and 5 is then: grad_update = Eq ( grad , grad - u * v . dt2 ) Now we must add the gradient update expression to the adjoint propagator op_grad . This yields a single symbolic expression with update instructions for both the adjoint wavefield and the gradient: op_grad = Operator ([ stencil_v ] + res_term + [ grad_update ], time_axis = Backward ) Solving the adjoint wave equation by running the following now computes the FWI gradient for a single source. Its value is stored in grad.data . op_grad ( u = u0 , v = v , m = model0 . m , residual = pred . data - obs . data , time = nt , dt = dt ) CustomCompiler: compiled /tmp/devito-gx10ovxj/ec66845144ec0c1fb8e1bb5f532cda21c551712e.c [0.28 s] ========================================================================================= Section section_1<714,101> with OI=0.80 computed in 0.003 s [1.18 GFlops/s] Section main<714,179,179> with OI=2.83 computed in 0.303 s [6.11 GFlops/s, 0.08 GPts/s] ========================================================================================= # NOT FOR MANUSCIPT plt . figure ( figsize = ( 8 , 8 )) plt . imshow ( np . transpose ( grad . data [ 40 : - 40 , 40 : - 40 ]), extent = extent , cmap = 'RdBu' , vmin =- 1e3 , vmax = 1e3 ) plt . colorbar ( shrink = 0.75 ) plt . show () # NOT FOR MANUSCRIPT tmp = grad . copy () Now we can iterate over all the shot locations, running the same sequence of commands each time. # NOT FOR MANUSCRIPT from devito import configuration configuration [ 'log_level' ] = 'WARNING' # Create the symbols. u0 = TimeFunction ( name = 'u0' , grid = model . grid , time_order = 2 , space_order = 4 , save = True , time_dim = nt ) u = TimeFunction ( name = 'u' , grid = model . grid , time_order = 2 , space_order = 4 , save = True , time_dim = nt ) v = TimeFunction ( name = 'v' , grid = model . grid , time_order = 2 , space_order = 4 , save = False ) # Define the wave equation, but with a negated damping term eqn = model . m * v . dt2 - v . laplace - model . damp * v . dt # Use SymPy to rearrange the equation into a stencil expression. stencil = Eq ( v . backward , solve ( eqn , v . backward )[ 0 ]) # Define the residual injection. residual = PointSource ( name = 'residual' , ntime = nt , coordinates = rec_coords , grid = model . grid ) res_term = residual . inject ( field = v . backward , expr = residual * dt ** 2 / model . m , offset = model . nbpml ) # Correlate u and v for the current time step and add it to the gradient. grad = Function ( name = 'grad' , grid = model . grid , dtype = model . m . dtype ) grad_update = Eq ( grad , grad - u * v . dt2 ) # Compose the operator. op_grad2 = Operator ([ stencil ] + res_term + [ grad_update ], time_axis = Backward ) # Iterate over the shots. for i in range ( nshots ): print ( \"Source {} of {} \" . format ( i , nshots )) # Opdate source location. src . coordinates . data [ 0 , :] = src_coords [ i ] # Generate data from true model and current model estimate. obs , _ , _ = solver . forward ( src = src , m = model . m ) pred , _ , _ = solver . forward ( src = src , m = model0 . m , u = u0 , save = True ) # Compute the gradient from the residual. v = TimeFunction ( name = 'v' , grid = model . grid , time_order = 2 , space_order = 4 ) residual . data [:] = pred . data - obs . data op_grad2 ( u = u0 , v = v , m = model0 . m , residual = residual , grad = grad , dt = dt ) configuration [ 'log_level' ] = 'INFO' Source 0 of 21 Source 1 of 21 Source 2 of 21 Source 3 of 21 Source 4 of 21 Source 5 of 21 Source 6 of 21 Source 7 of 21 Source 8 of 21 Source 9 of 21 Source 10 of 21 Source 11 of 21 Source 12 of 21 Source 13 of 21 Source 14 of 21 Source 15 of 21 Source 16 of 21 Source 17 of 21 Source 18 of 21 Source 19 of 21 Source 20 of 21 # NOT FOR MANUSCRIPT plt . figure ( figsize = ( 8 , 8 )) plt . imshow ( np . transpose ( grad . data )[ 40 : - 40 , 40 : - 40 ], extent = extent , vmin =- 1e4 , vmax = 1e4 , cmap = 'RdBu' ) plt . colorbar ( shrink = 0.75 ) plt . show () # NOT FOR MANUSCRIPT # Generates Figure 3 from plot_utils import add_subplot_axes fig = plt . figure ( figsize = ( 12 , 6 )) ax0 = fig . add_subplot ( 121 ) ma = 1e3 im = ax0 . imshow ( np . transpose ( tmp . data [ 40 : - 40 , 40 : - 40 ]), extent = extent , cmap = 'RdBu' , vmin =- ma , vmax = ma ) cax = add_subplot_axes ( ax0 , [ 0.3 , 0.075 , 0.4 , 0.02 ]) fig . colorbar ( im , cax = cax , orientation = 'horizontal' ) cax . text ( 0 , 1 , \" {:.0f} \" . format ( - ma ), ha = 'right' , va = 'top' , size = 10 ) cax . text ( 1 , 1 , \" {:.0f} \" . format ( ma ), ha = 'left' , va = 'top' , size = 10 ) cax . set_axis_off () ax0 . text ( 0.5 , 0.05 , \"Shot @ 500 m\" , ha = 'center' , va = 'center' , size = 16 ) ax0 . set_xlabel ( 'X position (m)' , fontsize = 16 ) ax0 . set_ylabel ( 'Z position (m)' , fontsize = 16 ) plt . setp ( ax0 . get_xticklabels (), fontsize = 12 ) plt . setp ( ax0 . get_yticklabels (), fontsize = 12 ) ax1 = fig . add_subplot ( 122 ) ma = 1e4 im = ax1 . imshow ( np . transpose ( grad . data [ 40 : - 40 , 40 : - 40 ]), extent = extent , cmap = 'RdBu' , vmin =- ma , vmax = ma ) cax = add_subplot_axes ( ax1 , [ 0.3 , 0.075 , 0.4 , 0.02 ]) fig . colorbar ( im , cax = cax , orientation = 'horizontal' ) cax . text ( 0 , 1 , \" {:.0f} \" . format ( - ma ), ha = 'right' , va = 'top' , size = 10 ) cax . text ( 1 , 1 , \" {:.0f} \" . format ( ma ), ha = 'left' , va = 'top' , size = 10 ) cax . set_axis_off () ax1 . text ( 0.5 , 0.05 , \"All {} shots\" . format ( nshots ), ha = 'center' , va = 'center' , size = 16 ) ax1 . set_xlabel ( 'X position (m)' , fontsize = 16 ) ax1 . set_yticklabels ([]) plt . setp ( ax1 . get_xticklabels (), fontsize = 12 ) plt . setp ( ax1 . get_yticklabels (), fontsize = 12 ) plt . savefig ( \"../Figures/Figure3.pdf\" ) plt . savefig ( \"../Figures/Figure3.png\" , dpi = 400 ) plt . show () Figure 3. Gradient plots for (a) a single shot at 0.5 km and (b) the sum of all shots. This gradient can then be used for a simple gradient descent optimization loop, as illustrated at the end of the notebook adjoint_modeling.ipynb . After each update, a new gradient is computed for the new velocity model until sufficient decrease of the objective or chosen number of iteration is reached. A detailed treatment of optimization and more advanced algorithms will be described in the third and final part of this tutorial series.","title":"Computing the FWI gradient"},{"location":"tutorials/TLE_Adjoint/#conclusions","text":"We need the gradient of the FWI objective function in order to find the optimal solution. It is computed by solving adjoint wave equations and summing the point-wise product of forward and adjoint wavefields over all time steps. Using Devito, the adjoint wave equation is set up in a similar fashion as the forward wave equation, with the main difference being the (adjoint) source, which is the residual between the observed and predicted shot records. With the ability to model shot records and compute gradients of the FWI objective function, we are ready to demonstrate how to set up more gradient-based algorithms for FWI in Part 3 next month.","title":"Conclusions"},{"location":"tutorials/TLE_Adjoint/#acknowledgments","text":"This research was carried out as part of the SINBAD II project with the support of the member organizations of the SINBAD Consortium. This work was financially supported in part by EPSRC grant EP/L000407/1 and the Imperial College London Intel Parallel Computing Centre.","title":"Acknowledgments"},{"location":"tutorials/TLE_Adjoint/#references","text":"[1] Michael Lange, Navjot Kukreja, Mathias Louboutin, Fabio Luporini, Felippe Vieira Zacarias, Vincenzo Pandolfo, Paulius Velesko, Paulius Kazakas, and Gerard Gorman. Devito: Towards a generic finite difference DSL using symbolic python. In 6 th Workshop on Python for High-Performance and Scientific Computing, pages 67\u201375, 11 2016. doi: 10.1109/PyHPC.2016.9. [2] J. L. Lions. Optimal control of systems governed by partial differential equations. Springer-Verlag Berlin Heidelberg, 1 st edition, 1971. ISBN 978-3-642-65026-0. [3] Mathias Louboutin, Philipp A. Witte, Michael Lange, Navjot Kukreja, Fabio Luporini, Gerard Gorman, and Felix J. Herrmann. Full-waveform inversion - part 1: forward modeling. Submitted to The Leading Edge for the tutorial section on October 30, 2017., 2017. [4] Aaron Meurer, Christopher P. Smith, Mateusz Paprocki, Ondr\u030cej C\u030certi\u0301k, Sergey B. Kirpichev, Matthew Rocklin, AMiT Kumar, Sergiu Ivanov, Jason K. Moore, Sartaj Singh, Thilina Rathnayake, Sean Vig, Brian E. Granger, Richard P. Muller, Francesco Bonazzi, Harsh Gupta, Shivam Vats, Fredrik Johansson, Fabian Pedregosa, Matthew J. Curry, Andy R. Terrel, S\u030cte\u030cpa\u0301n Rouc\u030cka, Ashutosh Saboo, Isuru Fernando, Sumith Kulal, Robert Cimrman, and Anthony Scopatz. Sympy: symbolic computing in python. Peer J Computer Science, 3:e103, January 2017. ISSN 2376-5992. doi: 10.7717/peerj-cs.103. URL https: //doi.org/10.7717/peerj-cs.103. [5] R.-E. Plessix. A review of the adjoint-state method for computing the gradient of a functional with geophysical applications. Geophysical Journal International, 167(2):495, 2006. doi: 10.1111/j.1365-246X.2006.02978.x. URL + http://dx.doi.org/10.1111/j.1365-246X.2006.02978.x [6] Albert Tarantola. Inversion of seismic reflection data in the acoustic approximation. GEOPHYSICS, 49(8): 1259\u20131266, 1984. doi: 10.1190/1.1441754. URL https://doi.org/10.1190/1.1441754 [7] J. Virieux and S. Operto. An overview of full-waveform inversion in exploration geophysics. GEOPHYSICS, 74 (5):WCC1\u2013WCC26, 2009. doi: 10.1190/1.3238367. URL http://library.seg.org/doi/abs/10.1190/1.3238367 [8] Yu Zhang, Houzhu Zhang, and Guanquan Zhang. A stable tti reverse time migration and its implementation. GEOPHYSICS, 76(3):WA3\u2013WA11, 2011. doi: 10.1190/1.3554411. URL https://doi.org/10.1190/1.3554411 . \u00a9 2017 The authors \u2014 licensed CC-BY-SA","title":"References"},{"location":"tutorials/TLE_Forward/","text":"import numpy as np import matplotlib.pyplot as plt % matplotlib inline Preface: Installing Devito (do not include in manuscipt) This tutorial and the coming second part are based on Devito version 3.1.0. It requires the installation of the full software with examples, not only the code generation API. To install: git clone -b v3.1.0 https://github.com/opesci/devito cd devito conda env create -f environment.yml source activate devito pip install -e . That final dot is important, don't miss it out! Useful links Devito documentation Devito source code and examples Tutorial notebooks with latest Devito/master Geophysics tutorial Full-waveform inversion 1: forward modeling Mathias Louboutin 1 *, Philipp Witte 1 , Michael Lange 2 , Navjot Kukreja 2 , Fabio Luporini 2 , Gerard Gorman 2 , and Felix J. Herrmann 1,3 1 Seismic Laboratory for Imaging and Modeling (SLIM), The University of British Columbia 2 Imperial College London, London, UK 3 now at Georgia Institute of Technology, USA Corresponding author: mloubout@eoas.ubc.ca Since its re-introduction by Pratt (1999), full-waveform inversion (FWI) has gained a lot of attention in geophysical exploration because of its ability to build high resolution velocity models more or less automatically in areas of complex geology. While there is an extensive and growing literature on the topic, publications focus mostly on technical aspects, making this topic inaccessible for a broader audience due to the lack of simple introductory resources for newcomers to geophysics. We will accomplish this by providing a hands-on walkthrough of FWI using Devito (Lange et al. 2016), a system based on domain-specific languages that automatically generates code for time-domain finite-differences. As usual, this tutorial is accompanied by all the code you need to reproduce the figures. Go to github.com/seg/tutorials-2017 and follow the links. In the Notebook, we describe how to simulate synthetic data for a specified source and receiver setup and how to save the corresponding wavefields and shot records. In part two of this series, we will address how to calculate model updates, i.e. gradients of the FWI objective function, via adjoint modeling. Finally, in part three we will demonstrate how to use this gradient as part of an optimization framework for inverting an unknown velocity model. Introduction Devito provides a concise and straightforward computational framework for discretizing wave equations, which underlie all FWI frameworks. We will show that it generates verifiable executable code at run time for wave propagators associated with forward and (in part 2) adjoint wave equations. Devito frees the user from the recurrent and time-consuming development of performant time-stepping codes and allows the user to concentrate on the geophysics of the problem rather than on low-level implementation details of wave-equation simulators. This tutorial covers the conventional adjoint-state formulation of full-waveform tomography (Tarantola 1984) that underlies most of the current methods referred to as full-waveform inversion (Virieux and Operto 2009). While other formulations have been developed to improve the convergence of FWI for poor starting models, in these tutorials we will concentrate on the standard formulation that relies on the combination of a forward/adjoint pair of propagators and a correlation-based gradient. In part one of this tutorial, we discuss how to set up wave simulations for inversion, including how to express the wave equation in Devito symbolically and how to deal with the acquisition geometry. What is FWI? FWI tries to iteratively minimize the difference between data that was acquired in a seismic survey and synthetic data that is generated from a wave simulator with an estimated (velocity) model of the subsurface. As such, each FWI framework essentially consists of a wave simulator for forward modeling the predicted data and an adjoint simulator for calculating a model update from the data misfit. This first part of this tutorial is dedicated to the forward modeling part and demonstrates how to discretize and implement the acoustic wave equation using Devito. Wave simulations for inversion The acoustic wave equation with the squared slowness m m , defined as m(x,y)=c^{-2}(x,y) m(x,y)=c^{-2}(x,y) with c(x,y) c(x,y) being the unknown spatially varying wavespeed, is given by: m(x, y) \\frac{\\mathrm{d}^2 u(t, x, y)}{\\mathrm{d}t^2}\\ -\\ \\Delta u(t, x, y)\\ +\\ \\eta(x, y) \\frac{\\mathrm{d} u(t, x, y)}{\\mathrm{d}t}\\ \\ =\\ \\ q(t, x, y; x_\\mathrm{s}, y_\\mathrm{s}),\\ \\ \\ \\ \\ \\ \\ \\ (1) m(x, y) \\frac{\\mathrm{d}^2 u(t, x, y)}{\\mathrm{d}t^2}\\ -\\ \\Delta u(t, x, y)\\ +\\ \\eta(x, y) \\frac{\\mathrm{d} u(t, x, y)}{\\mathrm{d}t}\\ \\ =\\ \\ q(t, x, y; x_\\mathrm{s}, y_\\mathrm{s}),\\ \\ \\ \\ \\ \\ \\ \\ (1) where \\Delta \\Delta is the Laplace operator, q(t, x, y;x_\\mathrm{s}, y_\\mathrm{s}) q(t, x, y;x_\\mathrm{s}, y_\\mathrm{s}) is the seismic source, located at (x_\\mathrm{s}, y_\\mathrm{s}) (x_\\mathrm{s}, y_\\mathrm{s}) and \\eta(x, y) \\eta(x, y) is a space-dependent dampening parameter for the absorbing boundary layer (Cerjan et al. 1985). As shown in Figure 1, the physical model is extended in every direction by nbpml grid points to mimic an infinite domain. The dampening term \\eta\\, \\mathrm{d}u/\\mathrm{d}t \\eta\\, \\mathrm{d}u/\\mathrm{d}t attenuates the waves in the dampening layer and prevents waves from reflecting at the model boundaries. In Devito, the discrete representations of m m and \\eta \\eta are contained in a model object that contains a grid object with all relevant information such as the origin of the coordinate system, grid spacing, size of the model and dimensions time, x, y : # FIGURE 1 from IPython.display import HTML HTML ( \"../Figures/Figure1_composed.svg\" ) image/svg+xml 0.0 0.2 0.4 0.6 0.8 1.0 X position (km) 0.0 0.2 0.4 0.6 0.8 1.0 Depth (km) receivers source Origin v = 1.5 km/s v = 2.5 km/s Example velocity model 1.6 1.8 2.0 2.2 2.4 Velocity (km/s) offset = nbpml absorbing layer x y origin source physical domain receiver Figure 1: (a) Diagram showing the model domain, with the perfectly matched layer (PML) as an absorbing layer to attenuate the wavefield at the model boundary. (b) The example model used in this tutorial, with the source and receivers indicated. The grid lines show the cell boundaries. # NOT FOR MANUSCRIPT from examples.seismic import Model , plot_velocity # Define a velocity model. The velocity is in km/s vp = np . empty (( 101 , 101 ), dtype = np . float32 ) vp [:, : 51 ] = 1.5 vp [:, 51 :] = 2.5 model = Model ( vp = vp , # A velocity model. origin = ( 0 , 0 ), # Top left corner. shape = ( 101 , 101 ), # Number of grid points. spacing = ( 10 , 10 ), # Grid spacing in m. nbpml = 40 ) # boundary layer. # NOT FOR MANUSCRIPT # Quick plot of model. plot_velocity ( model ) In the Model instantiation, vp is the velocity in \\text{km}/\\text{s} \\text{km}/\\text{s} , origin is the origin of the physical model in meters, spacing is the discrete grid spacing in meters, shape is the number of grid points in each dimension and nbpml is the number of grid points in the absorbing boundary layer. Is is important to note that shape is the size of the physical domain only, while the total number of grid points, including the absorbing boundary layer, will be automatically derived from shape and nbpml . Symbolic definition of the wave propagator To model seismic data by solving the acoustic wave equation, the first necessary step is to discretize this partial differential equation (PDE), which includes discrete representations of the velocity model and wavefields, as well as approximations of the spatial and temporal derivatives using finite-differences (FD). Unfortunately, implementing these finite-difference schemes in low-level code by hand is error prone, especially when we want performant and reliable code. The primary design objective of Devito is to allow users to define complex matrix-free finite-difference approximations from high-level symbolic definitions, while employing automated code generation to create highly optimized low-level C code. Using the symbolic algebra package SymPy (Meurer et al. 2017) to facilitate the automatic creation of derivative expressions, Devito generates computationally efficient wave propagators. At the core of Devito's symbolic API are symbolic types that behave like SymPy function objects, while also managing data: Function objects represent a spatially varying function discretized on a regular Cartesian grid. For example, a function symbol f = Function(name='f', grid=model.grid, space_order=2) is denoted symbolically as f(x, y) . The objects provide auto-generated symbolic expressions for finite-difference derivatives through shorthand expressions like f.dx and f.dx2 for the first and second derivative in x . TimeFunction objects represent a time-dependent function that has \\text{time} \\text{time} as the leading dimension, for example g(time, x, y) . In addition to spatial derivatives TimeFunction symbols also provide time derivatives g.dt and g.dt2 . SparseFunction objects represent sparse components, such as sources and receivers, which are usually distributed sparsely and often located off the computational grid \u2014 these objects also therefore handle interpolation onto the model grid. To demonstrate Devito's symbolic capabilities, let us consider a time-dependent function \\mathbf{u}(\\text{time}, x, y) \\mathbf{u}(\\text{time}, x, y) representing the discrete forward wavefield: # NOT FOR MANUSCRIPT from devito import TimeFunction t0 = 0. # Simulation starts a t=0 tn = 1000. # Simulation last 1 second (1000 ms) dt = model . critical_dt # Time step from model grid spacing nt = int ( 1 + ( tn - t0 ) / dt ) # Discrete time axis length time = np . linspace ( t0 , tn , nt ) # Discrete modelling time u = TimeFunction ( name = \"u\" , grid = model . grid , time_order = 2 , space_order = 2 , save = True , time_dim = nt ) where the grid object provided by the model defines the size of the allocated memory region, time_order and space_order define the default discretization order of the derived derivative expressions. We can now use this symbolic representation of our wavefield to generate simple discretized expressions for finite-difference derivative approximations using shorthand expressions, such as u.dt and u.dt2 to denote \\frac{\\text{d} u}{\\text{d} t} \\frac{\\text{d} u}{\\text{d} t} and \\frac{\\text{d}^2 u}{\\text{d} t^2} \\frac{\\text{d}^2 u}{\\text{d} t^2} respectively: # NOT FOR MANUSCRIPT u u(time, x, y) u . dt -u(time - dt, x, y)/(2*dt) + u(time + dt, x, y)/(2*dt) u . dt2 -2*u(time, x, y)/dt**2 + u(time - dt, x, y)/dt**2 + u(time + dt, x, y)/dt**2 Using the automatic derivation of derivative expressions, we can now implement a discretized expression for Equation 1 without the source term q(x,y,t;x_s, y_s) q(x,y,t;x_s, y_s) . The model object, which we created earlier, already contains the squared slowness \\mathbf{m} \\mathbf{m} and damping term \\mathbf{\\eta} \\mathbf{\\eta} as Function objects: pde = model . m * u . dt2 - u . laplace + model . damp * u . dt If we write out the (second order) second time derivative u.dt2 as shown earlier and ignore the damping term for the moment, our pde expression translates to the following discrete the wave equation: \\frac{\\mathbf{m}}{\\text{dt}^2} \\Big( \\mathbf{u}[\\text{time}-\\text{dt}] - 2\\mathbf{u}[\\text{time}] + \\mathbf{u}[\\text{time}+\\text{dt}]\\Big) - \\Delta \\mathbf{u}[\\text{time}] = 0, \\quad \\text{time}=1 \\cdots n_{t-1} \\ \\ \\ \\ \\ \\ \\ (2) \\frac{\\mathbf{m}}{\\text{dt}^2} \\Big( \\mathbf{u}[\\text{time}-\\text{dt}] - 2\\mathbf{u}[\\text{time}] + \\mathbf{u}[\\text{time}+\\text{dt}]\\Big) - \\Delta \\mathbf{u}[\\text{time}] = 0, \\quad \\text{time}=1 \\cdots n_{t-1} \\ \\ \\ \\ \\ \\ \\ (2) with \\text{time} \\text{time} being the current time step and \\text{dt} \\text{dt} being the time stepping interval. To propagate the wavefield, we rearrange to obtain an expression for the wavefield \\mathbf{u}(\\text{time}+\\text{dt}) \\mathbf{u}(\\text{time}+\\text{dt}) at the next time step. Ignoring the damping term once again, this yields: \\mathbf{u}[\\text{time}+\\text{dt}] = 2\\mathbf{u}[\\text{time}] - \\mathbf{u}[\\text{time}-\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}} \\Delta \\mathbf{u}[\\text{time}] \\ \\ \\ \\ \\ \\ \\ (3) \\mathbf{u}[\\text{time}+\\text{dt}] = 2\\mathbf{u}[\\text{time}] - \\mathbf{u}[\\text{time}-\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}} \\Delta \\mathbf{u}[\\text{time}] \\ \\ \\ \\ \\ \\ \\ (3) We can rearrange our pde expression automatically using the SymPy utility function solve , then create an expression which defines the update of the wavefield for the new time step \\mathbf{u}(\\text{time}+\\text{dt}) \\mathbf{u}(\\text{time}+\\text{dt}) , with the command u.forward : # NOT FOR MANUSCRIPT from devito import Eq from sympy import solve stencil = Eq ( u . forward , solve ( pde , u . forward )[ 0 ]) stencil represents the finite-difference approximation derived from Equation 3, including the finite-difference approximation of the Laplacian and the damping term. Although it defines the update for a single time step only, Devito knows that we will be solving a time-dependent problem over a number of time steps because the wavefield u is a TimeFunction object. Setting up the acquisition geometry The expression for time stepping we derived in the previous section does not contain a seismic source function yet, so the update for the wavefield at a new time step is solely defined by the two previous wavefields. However as indicated in Equation 1, wavefields for seismic experiments are often excited by an active (impulsive) source q(x,y,t;x_\\text{s}) q(x,y,t;x_\\text{s}) , which is a function of space and time (just like the wavefield u ). To include such a source term in our modeling scheme, we simply add the the source wavefield as an additional term to Equation 3: \\mathbf{u}[\\text{time}+\\text{dt}] = 2\\mathbf{u}[\\text{time}] - \\mathbf{u}[\\text{time}-\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}} \\Big(\\Delta \\mathbf{u}[\\text{time}] + \\mathbf{q}[\\text{time}]\\Big). \\ \\ \\ \\ \\ \\ \\ (4) \\mathbf{u}[\\text{time}+\\text{dt}] = 2\\mathbf{u}[\\text{time}] - \\mathbf{u}[\\text{time}-\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}} \\Big(\\Delta \\mathbf{u}[\\text{time}] + \\mathbf{q}[\\text{time}]\\Big). \\ \\ \\ \\ \\ \\ \\ (4) Since the source appears on the right-hand side in the original equation (Equation 1), the term also needs to be multiplied with \\frac{\\text{dt}^2}{\\mathbf{m}} \\frac{\\text{dt}^2}{\\mathbf{m}} (this follows from rearranging Equation 2, with the source on the right-hand side in place of 0). Unlike the discrete wavefield u however, the source q is typically localized in space and only a function of time, which means the time-dependent source wavelet is injected into the propagating wavefield at a specified source location. The same applies when we sample the wavefield at receiver locations to simulate a shot record, i.e. the simulated wavefield needs to be sampled at specified receiver locations only. Source and receiver both do not necessarily coincide with the modeling grid. Here, RickerSource acts as a wrapper around SparseFunction and models a Ricker wavelet with a peak frequency f0 and source coordinates src_coords : # NOT FOR MANUSCRIPT from examples.seismic import RickerSource # Src is halfway across model, at depth of 20 m. x_extent , _ = model . domain_size src_coords = [ x_extent / 2 , 20 ] f0 = 0.010 # kHz, peak frequency. src = RickerSource ( name = 'src' , grid = model . grid , f0 = f0 , time = time , coordinates = src_coords ) The src.inject function now injects the current time sample of the Ricker wavelet (weighted with \\frac{\\text{dt}^2}{\\mathbf{m}} \\frac{\\text{dt}^2}{\\mathbf{m}} as shown in Equation 4) into the updated wavefield u.forward at the specified coordinates. src_term = src . inject ( field = u . forward , expr = src * dt ** 2 / model . m , offset = model . nbpml ) To extract the wavefield at a predetermined set of receiver locations, there is a corresponding wrapper function for receivers as well, which creates a SparseFunction object for a given number npoint of receivers, number nt of time samples, and specified receiver coordinates rec_coords : # NOT FOR MANUSCRIPT from examples.seismic import Receiver # Recs are distributed across model, at depth of 20 m. x_locs = np . linspace ( 0 , x_extent , 101 ) rec_coords = [( x , 20 ) for x in x_locs ] rec = Receiver ( name = 'rec' , npoint = 101 , ntime = nt , grid = model . grid , coordinates = rec_coords ) Rather than injecting a function into the model as we did for the source, we now simply save the wavefield at the grid points that correspond to receiver positions and interpolate the data to their exact possibly of the computatational grid location: rec_term = rec . interpolate ( u , offset = model . nbpml ) # NOT FOR MANUSCRIPT # PLOTS HALF OF FIGURE 1. import matplotlib.patches as patches from matplotlib.ticker import MultipleLocator fig = plt . figure ( figsize = ( 9 , 9 )) extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], model . origin [ 1 ] + 1e-3 * model . shape [ 1 ] * model . spacing [ 1 ], model . origin [ 1 ]] model_param = dict ( vmin = 1.5 , vmax = 2.5 , cmap = \"GnBu\" , aspect = 1 , extent = extent ) ax0 = fig . add_subplot ( 111 ) im = plt . imshow ( np . transpose ( vp ), ** model_param ) cb = plt . colorbar ( shrink = 0.8 ) ax0 . set_ylabel ( 'Depth (km)' , fontsize = 20 ) ax0 . set_xlabel ( 'X position (km)' , fontsize = 20 ) cb . set_label ( 'Velocity (km/s)' , fontsize = 20 ) plt . xticks ( fontsize = 14 ) plt . yticks ( fontsize = 14 ) cb . ax . tick_params ( labelsize = 14 ) plt . scatter ( * ( rec . coordinates . data [:: 4 , :] . T / 1000 ), c = 'green' , clip_on = False , zorder = 100 ) plt . text ( * rec . coordinates . data [ 0 ] . T / 1000 + [ 0.02 , 0.05 ], \"receivers\" , color = 'green' , size = 14 ) plt . scatter ( * ( src . coordinates . data . squeeze () / 1000 ), c = 'red' , s = 60 ) plt . text ( * src . coordinates . data [ 0 ] / 1000 + [ 0 , 0.05 ], \"source\" , color = 'red' , size = 14 ) plt . scatter ( 0 , 0 , c = 'black' , s = 160 , clip_on = False , zorder = 101 ) plt . text ( - 0.01 , - 0.03 , \"Origin\" , color = 'k' , size = 16 , ha = \"right\" ) plt . text ( 0.02 , 0.5 - 0.03 , \"v = 1.5 km/s\" , color = 'k' , size = 16 , ha = \"left\" , va = 'center' ) plt . text ( 0.02 , 0.5 + 0.05 , \"v = 2.5 km/s\" , color = 'w' , size = 16 , ha = \"left\" , va = 'center' ) plt . title ( \"Example velocity model\" , color = 'k' , size = 24 ) plt . xlim (( 0 , 1 )) plt . ylim (( 1 , 0 )) minorLocator = MultipleLocator ( 1 / 100 ) ax0 . xaxis . set_minor_locator ( minorLocator ) ax0 . yaxis . set_minor_locator ( minorLocator ) plt . grid ( which = 'minor' , alpha = 0.3 ) plt . savefig ( \"../Figures/model.pdf\" , dpi = 400 ) plt . savefig ( \"../Figures/model.png\" ) plt . show () Forward simulation We can now define our forward propagator by adding the source and receiver terms to our stencil object: # NOT FOR MANUSCRIPT from devito import Operator op_fwd = Operator ([ stencil ] + src_term + rec_term ) The symbolic expressions used to create Operator contain sufficient meta-information for Devito to create a fully functional computational kernel. The dimension symbols contained in the symbolic function object ( time, x, y ) define the loop structure of the created code,while allowing Devito to automatically optimize the underlying loop structure to increase execution speed. The size of the loops and spacing between grid points is inferred from the symbolic Function objects and associated model.grid object at run-time. As a result, we can invoke the generated kernel through a simple Python function call by supplying the number of timesteps time and the timestep size dt . The user data associated with each Function is updated in-place during operator execution, allowing us to extract the final wavefield and shot record directly from the symbolic function objects without unwanted memory duplication: op_fwd ( time = nt , dt = model . critical_dt ) CustomCompiler: compiled /var/folders/8x/2cdqc7_57plfk5txbsszysbc0000gn/T/devito-nbfsni25/3d06ca83c7f841ceea604b9788ecda3d3e36bfef.c [1.99 s] ========================================================================================= Section section_1<595,1> with OI=0.80 computed in 0.000 s [0.45 GFlops/s] Section section_2<595,101> with OI=1.50 computed in 0.001 s [2.11 GFlops/s] Section main<595,180,180> with OI=3.27 computed in 0.072 s [14.15 GFlops/s, 0.27 GPts/s] ========================================================================================= When this has finished running, the resulting wavefield is stored in u.data and the shot record is in rec.data . We can easily plot this 2D array as an image, as shown in Figure 2. # NOT FOR MANUSCRIPT # GENERATES FIGURE 2 from matplotlib import cm fig1 = plt . figure ( figsize = ( 10 , 10 )) l = plt . imshow ( rec . data , vmin =- 1 , vmax = 1 , cmap = cm . gray , aspect = 1 , extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], 1e-3 * tn , t0 ]) plt . xlabel ( 'X position (km)' , fontsize = 20 ) plt . ylabel ( 'Time (s)' , fontsize = 20 ) plt . tick_params ( labelsize = 20 ) plt . savefig ( \"../Figures/Figure2.png\" , dpi = 400 ) plt . savefig ( \"../Figures/Figure2.pdf\" ) plt . show () Figure 2. The shot record generated by Devito for the example velocity model. As demonstrated in the notebook, a movie of snapshots of the forward wavefield can also be generated by capturing the wavefield at discrete time steps. Figure 3 shows three timesteps from the movie. # NOT FOR MANUSCRIPT # GENERATES FIGURE 3 fig = plt . figure ( figsize = ( 15 , 5 )) times = [ 200 , 300 , 400 ] extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], model . origin [ 1 ] + 1e-3 * model . shape [ 1 ] * model . spacing [ 1 ], model . origin [ 1 ]] data_param = dict ( vmin =- 1e0 , vmax = 1e0 , cmap = cm . Greys , aspect = 1 , extent = extent , interpolation = 'none' ) model_param = dict ( vmin = 1.5 , vmax = 2.5 , cmap = cm . GnBu , aspect = 1 , extent = extent , alpha =. 3 ) ax0 = fig . add_subplot ( 131 ) _ = plt . imshow ( np . transpose ( u . data [ times [ 0 ], 40 : - 40 , 40 : - 40 ]), ** data_param ) _ = plt . imshow ( np . transpose ( vp ), ** model_param ) ax0 . set_ylabel ( 'Depth (km)' , fontsize = 20 ) ax0 . text ( 0.5 , 0.08 , \"t = {:.0f} ms\" . format ( time [ times [ 0 ]]), ha = \"center\" , color = 'k' ) ax1 = fig . add_subplot ( 132 ) _ = plt . imshow ( np . transpose ( u . data [ times [ 1 ], 40 : - 40 , 40 : - 40 ]), ** data_param ) _ = plt . imshow ( np . transpose ( vp ), ** model_param ) ax1 . set_xlabel ( 'X position (km)' , fontsize = 20 ) ax1 . set_yticklabels ([]) ax1 . text ( 0.5 , 0.08 , \"t = {:.0f} ms\" . format ( time [ times [ 1 ]]), ha = \"center\" , color = 'k' ) ax2 = fig . add_subplot ( 133 ) _ = plt . imshow ( np . transpose ( u . data [ times [ 2 ], 40 : - 40 , 40 : - 40 ]), ** data_param ) _ = plt . imshow ( np . transpose ( vp ), ** model_param ) ax2 . set_yticklabels ([]) ax2 . text ( 0.5 , 0.08 , \"t = {:.0f} ms\" . format ( time [ times [ 2 ]]), ha = \"center\" , color = 'k' ) plt . savefig ( \"../Figures/Figure3.pdf\" ) plt . savefig ( \"../Figures/Figure3.png\" , dpi = 400 ) plt . show () Figure 3. Three time steps from the wavefield simulation that resulted in the shot record in Figure 2. You can generate an animated version in the Notebook at github.com/seg. # NOT FOR MANUSCRIPT import matplotlib.animation as animation from IPython.display import HTML fig = plt . figure () im = plt . imshow ( np . transpose ( u . data [ 0 , 40 : - 40 , 40 : - 40 ]), cmap = \"Greys\" , animated = True , vmin =- 1e0 , vmax = 1e0 , aspect = 1 , extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], model . origin [ 1 ] + 1e-3 * model . shape [ 1 ] * model . spacing [ 1 ], model . origin [ 1 ]]) plt . xlabel ( 'X position (km)' , fontsize = 20 ) plt . ylabel ( 'Depth (km)' , fontsize = 20 ) plt . tick_params ( labelsize = 20 ) im2 = plt . imshow ( np . transpose ( vp ), vmin = 1.5 , vmax = 2.5 , cmap = cm . GnBu , aspect = 1 , extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], model . origin [ 1 ] + 1e-3 * model . shape [ 1 ] * model . spacing [ 1 ], model . origin [ 1 ]], alpha =. 4 ) def updatefig ( i ): im . set_array ( np . transpose ( u . data [ i * 5 , 40 : - 40 , 40 : - 40 ])) return im , im2 ani = animation . FuncAnimation ( fig , updatefig , frames = np . linspace ( 0 , nt / 5 - 1 , nt // 5 , dtype = np . int64 ), blit = True , interval = 50 ) plt . close ( ani . _fig ) HTML ( ani . to_html5_video ()) Your browser does not support the video tag. # ani.save('../figures/animation.gif', writer='imagemagick', fps=30) # from IPython.display import Image # Image(url='../figures/animation.gif') Conclusions In this first part of the tutorial, we have demonstrated how to set up the discretized forward acoustic wave equations and its associated wave propagator with runtime code generation. While we limited our discussion to the constant density acoustic wave equation, Devito is capable of handling more general wave equations but this is a topic beyond this tutorial on simulating waves for inversion. In part two of our tutorial, we will show how to calculate a valid gradient of the FWI objective using the adjoint state method. In part three, we will demonstrate how to set up a complete matrix-free and scalable optimization framework for acoustic FWI. Acknowledgments This research was carried out as part of the SINBAD II project with the support of the member organizations of the SINBAD Consortium. This work was financially supported in part by EPSRC grant EP/L000407/1 and the Imperial College London Intel Parallel Computing Centre. References Cerjan, C., Kosloff, D., Kosloff, R., and Reshef, M., 1985, A nonreflecting boundary condition for discrete acoustic and elastic wave equations: GEOPHYSICS, 50, 705\u2013708. doi:10.1190/1.1441945 Lange, M., Kukreja, N., Louboutin, M., Luporini, F., Zacarias, F. V., Pandolfo, V., Gorman, G., 2016, Devito: Towards a generic finite difference DSL using symbolic python: 6 th workshop on python for high-performance and scientific computing. doi:10.1109/PyHPC.2016.9 Meurer A, Smith CP, Paprocki M, et al., 2017, SymPy: symbolic computing in Python. PeerJ Computer Science 3:e103 https://doi.org/10.7717/peerj-cs.103 Pratt, R. G., 1999, Seismic waveform inversion in the frequency domain, part 1: Theory and verification in a physical scale model: GEOPHYSICS, 64, 888\u2013901. doi:10.1190/1.1444597 Tarantola, A., 1984, Inversion of seismic reflection data in the acoustic approximation: GEOPHYSICS, 49, 1259\u20131266. doi:10.1190/1.1441754 Virieux, J., and Operto, S., 2009, An overview of full-waveform inversion in exploration geophysics: GEOPHYSICS, 74, WCC1\u2013WCC26. doi:10.1190/1.3238367 Supplemental material Devito documentation Devito source code and examples Tutorial notebooks with latest Devito/master \u00a9 2017 The authors \u2014 licensed CC-BY-SA","title":"Forward modeling"},{"location":"tutorials/TLE_Forward/#geophysics-tutorial","text":"","title":"Geophysics tutorial"},{"location":"tutorials/TLE_Forward/#full-waveform-inversion-1-forward-modeling","text":"Mathias Louboutin 1 *, Philipp Witte 1 , Michael Lange 2 , Navjot Kukreja 2 , Fabio Luporini 2 , Gerard Gorman 2 , and Felix J. Herrmann 1,3 1 Seismic Laboratory for Imaging and Modeling (SLIM), The University of British Columbia 2 Imperial College London, London, UK 3 now at Georgia Institute of Technology, USA Corresponding author: mloubout@eoas.ubc.ca Since its re-introduction by Pratt (1999), full-waveform inversion (FWI) has gained a lot of attention in geophysical exploration because of its ability to build high resolution velocity models more or less automatically in areas of complex geology. While there is an extensive and growing literature on the topic, publications focus mostly on technical aspects, making this topic inaccessible for a broader audience due to the lack of simple introductory resources for newcomers to geophysics. We will accomplish this by providing a hands-on walkthrough of FWI using Devito (Lange et al. 2016), a system based on domain-specific languages that automatically generates code for time-domain finite-differences. As usual, this tutorial is accompanied by all the code you need to reproduce the figures. Go to github.com/seg/tutorials-2017 and follow the links. In the Notebook, we describe how to simulate synthetic data for a specified source and receiver setup and how to save the corresponding wavefields and shot records. In part two of this series, we will address how to calculate model updates, i.e. gradients of the FWI objective function, via adjoint modeling. Finally, in part three we will demonstrate how to use this gradient as part of an optimization framework for inverting an unknown velocity model.","title":"Full-waveform inversion 1: forward modeling"},{"location":"tutorials/TLE_Forward/#introduction","text":"Devito provides a concise and straightforward computational framework for discretizing wave equations, which underlie all FWI frameworks. We will show that it generates verifiable executable code at run time for wave propagators associated with forward and (in part 2) adjoint wave equations. Devito frees the user from the recurrent and time-consuming development of performant time-stepping codes and allows the user to concentrate on the geophysics of the problem rather than on low-level implementation details of wave-equation simulators. This tutorial covers the conventional adjoint-state formulation of full-waveform tomography (Tarantola 1984) that underlies most of the current methods referred to as full-waveform inversion (Virieux and Operto 2009). While other formulations have been developed to improve the convergence of FWI for poor starting models, in these tutorials we will concentrate on the standard formulation that relies on the combination of a forward/adjoint pair of propagators and a correlation-based gradient. In part one of this tutorial, we discuss how to set up wave simulations for inversion, including how to express the wave equation in Devito symbolically and how to deal with the acquisition geometry.","title":"Introduction"},{"location":"tutorials/TLE_Forward/#wave-simulations-for-inversion","text":"The acoustic wave equation with the squared slowness m m , defined as m(x,y)=c^{-2}(x,y) m(x,y)=c^{-2}(x,y) with c(x,y) c(x,y) being the unknown spatially varying wavespeed, is given by: m(x, y) \\frac{\\mathrm{d}^2 u(t, x, y)}{\\mathrm{d}t^2}\\ -\\ \\Delta u(t, x, y)\\ +\\ \\eta(x, y) \\frac{\\mathrm{d} u(t, x, y)}{\\mathrm{d}t}\\ \\ =\\ \\ q(t, x, y; x_\\mathrm{s}, y_\\mathrm{s}),\\ \\ \\ \\ \\ \\ \\ \\ (1) m(x, y) \\frac{\\mathrm{d}^2 u(t, x, y)}{\\mathrm{d}t^2}\\ -\\ \\Delta u(t, x, y)\\ +\\ \\eta(x, y) \\frac{\\mathrm{d} u(t, x, y)}{\\mathrm{d}t}\\ \\ =\\ \\ q(t, x, y; x_\\mathrm{s}, y_\\mathrm{s}),\\ \\ \\ \\ \\ \\ \\ \\ (1) where \\Delta \\Delta is the Laplace operator, q(t, x, y;x_\\mathrm{s}, y_\\mathrm{s}) q(t, x, y;x_\\mathrm{s}, y_\\mathrm{s}) is the seismic source, located at (x_\\mathrm{s}, y_\\mathrm{s}) (x_\\mathrm{s}, y_\\mathrm{s}) and \\eta(x, y) \\eta(x, y) is a space-dependent dampening parameter for the absorbing boundary layer (Cerjan et al. 1985). As shown in Figure 1, the physical model is extended in every direction by nbpml grid points to mimic an infinite domain. The dampening term \\eta\\, \\mathrm{d}u/\\mathrm{d}t \\eta\\, \\mathrm{d}u/\\mathrm{d}t attenuates the waves in the dampening layer and prevents waves from reflecting at the model boundaries. In Devito, the discrete representations of m m and \\eta \\eta are contained in a model object that contains a grid object with all relevant information such as the origin of the coordinate system, grid spacing, size of the model and dimensions time, x, y : # FIGURE 1 from IPython.display import HTML HTML ( \"../Figures/Figure1_composed.svg\" ) image/svg+xml 0.0 0.2 0.4 0.6 0.8 1.0 X position (km) 0.0 0.2 0.4 0.6 0.8 1.0 Depth (km) receivers source Origin v = 1.5 km/s v = 2.5 km/s Example velocity model 1.6 1.8 2.0 2.2 2.4 Velocity (km/s) offset = nbpml absorbing layer x y origin source physical domain receiver Figure 1: (a) Diagram showing the model domain, with the perfectly matched layer (PML) as an absorbing layer to attenuate the wavefield at the model boundary. (b) The example model used in this tutorial, with the source and receivers indicated. The grid lines show the cell boundaries. # NOT FOR MANUSCRIPT from examples.seismic import Model , plot_velocity # Define a velocity model. The velocity is in km/s vp = np . empty (( 101 , 101 ), dtype = np . float32 ) vp [:, : 51 ] = 1.5 vp [:, 51 :] = 2.5 model = Model ( vp = vp , # A velocity model. origin = ( 0 , 0 ), # Top left corner. shape = ( 101 , 101 ), # Number of grid points. spacing = ( 10 , 10 ), # Grid spacing in m. nbpml = 40 ) # boundary layer. # NOT FOR MANUSCRIPT # Quick plot of model. plot_velocity ( model ) In the Model instantiation, vp is the velocity in \\text{km}/\\text{s} \\text{km}/\\text{s} , origin is the origin of the physical model in meters, spacing is the discrete grid spacing in meters, shape is the number of grid points in each dimension and nbpml is the number of grid points in the absorbing boundary layer. Is is important to note that shape is the size of the physical domain only, while the total number of grid points, including the absorbing boundary layer, will be automatically derived from shape and nbpml .","title":"Wave simulations for inversion"},{"location":"tutorials/TLE_Forward/#symbolic-definition-of-the-wave-propagator","text":"To model seismic data by solving the acoustic wave equation, the first necessary step is to discretize this partial differential equation (PDE), which includes discrete representations of the velocity model and wavefields, as well as approximations of the spatial and temporal derivatives using finite-differences (FD). Unfortunately, implementing these finite-difference schemes in low-level code by hand is error prone, especially when we want performant and reliable code. The primary design objective of Devito is to allow users to define complex matrix-free finite-difference approximations from high-level symbolic definitions, while employing automated code generation to create highly optimized low-level C code. Using the symbolic algebra package SymPy (Meurer et al. 2017) to facilitate the automatic creation of derivative expressions, Devito generates computationally efficient wave propagators. At the core of Devito's symbolic API are symbolic types that behave like SymPy function objects, while also managing data: Function objects represent a spatially varying function discretized on a regular Cartesian grid. For example, a function symbol f = Function(name='f', grid=model.grid, space_order=2) is denoted symbolically as f(x, y) . The objects provide auto-generated symbolic expressions for finite-difference derivatives through shorthand expressions like f.dx and f.dx2 for the first and second derivative in x . TimeFunction objects represent a time-dependent function that has \\text{time} \\text{time} as the leading dimension, for example g(time, x, y) . In addition to spatial derivatives TimeFunction symbols also provide time derivatives g.dt and g.dt2 . SparseFunction objects represent sparse components, such as sources and receivers, which are usually distributed sparsely and often located off the computational grid \u2014 these objects also therefore handle interpolation onto the model grid. To demonstrate Devito's symbolic capabilities, let us consider a time-dependent function \\mathbf{u}(\\text{time}, x, y) \\mathbf{u}(\\text{time}, x, y) representing the discrete forward wavefield: # NOT FOR MANUSCRIPT from devito import TimeFunction t0 = 0. # Simulation starts a t=0 tn = 1000. # Simulation last 1 second (1000 ms) dt = model . critical_dt # Time step from model grid spacing nt = int ( 1 + ( tn - t0 ) / dt ) # Discrete time axis length time = np . linspace ( t0 , tn , nt ) # Discrete modelling time u = TimeFunction ( name = \"u\" , grid = model . grid , time_order = 2 , space_order = 2 , save = True , time_dim = nt ) where the grid object provided by the model defines the size of the allocated memory region, time_order and space_order define the default discretization order of the derived derivative expressions. We can now use this symbolic representation of our wavefield to generate simple discretized expressions for finite-difference derivative approximations using shorthand expressions, such as u.dt and u.dt2 to denote \\frac{\\text{d} u}{\\text{d} t} \\frac{\\text{d} u}{\\text{d} t} and \\frac{\\text{d}^2 u}{\\text{d} t^2} \\frac{\\text{d}^2 u}{\\text{d} t^2} respectively: # NOT FOR MANUSCRIPT u u(time, x, y) u . dt -u(time - dt, x, y)/(2*dt) + u(time + dt, x, y)/(2*dt) u . dt2 -2*u(time, x, y)/dt**2 + u(time - dt, x, y)/dt**2 + u(time + dt, x, y)/dt**2 Using the automatic derivation of derivative expressions, we can now implement a discretized expression for Equation 1 without the source term q(x,y,t;x_s, y_s) q(x,y,t;x_s, y_s) . The model object, which we created earlier, already contains the squared slowness \\mathbf{m} \\mathbf{m} and damping term \\mathbf{\\eta} \\mathbf{\\eta} as Function objects: pde = model . m * u . dt2 - u . laplace + model . damp * u . dt If we write out the (second order) second time derivative u.dt2 as shown earlier and ignore the damping term for the moment, our pde expression translates to the following discrete the wave equation: \\frac{\\mathbf{m}}{\\text{dt}^2} \\Big( \\mathbf{u}[\\text{time}-\\text{dt}] - 2\\mathbf{u}[\\text{time}] + \\mathbf{u}[\\text{time}+\\text{dt}]\\Big) - \\Delta \\mathbf{u}[\\text{time}] = 0, \\quad \\text{time}=1 \\cdots n_{t-1} \\ \\ \\ \\ \\ \\ \\ (2) \\frac{\\mathbf{m}}{\\text{dt}^2} \\Big( \\mathbf{u}[\\text{time}-\\text{dt}] - 2\\mathbf{u}[\\text{time}] + \\mathbf{u}[\\text{time}+\\text{dt}]\\Big) - \\Delta \\mathbf{u}[\\text{time}] = 0, \\quad \\text{time}=1 \\cdots n_{t-1} \\ \\ \\ \\ \\ \\ \\ (2) with \\text{time} \\text{time} being the current time step and \\text{dt} \\text{dt} being the time stepping interval. To propagate the wavefield, we rearrange to obtain an expression for the wavefield \\mathbf{u}(\\text{time}+\\text{dt}) \\mathbf{u}(\\text{time}+\\text{dt}) at the next time step. Ignoring the damping term once again, this yields: \\mathbf{u}[\\text{time}+\\text{dt}] = 2\\mathbf{u}[\\text{time}] - \\mathbf{u}[\\text{time}-\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}} \\Delta \\mathbf{u}[\\text{time}] \\ \\ \\ \\ \\ \\ \\ (3) \\mathbf{u}[\\text{time}+\\text{dt}] = 2\\mathbf{u}[\\text{time}] - \\mathbf{u}[\\text{time}-\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}} \\Delta \\mathbf{u}[\\text{time}] \\ \\ \\ \\ \\ \\ \\ (3) We can rearrange our pde expression automatically using the SymPy utility function solve , then create an expression which defines the update of the wavefield for the new time step \\mathbf{u}(\\text{time}+\\text{dt}) \\mathbf{u}(\\text{time}+\\text{dt}) , with the command u.forward : # NOT FOR MANUSCRIPT from devito import Eq from sympy import solve stencil = Eq ( u . forward , solve ( pde , u . forward )[ 0 ]) stencil represents the finite-difference approximation derived from Equation 3, including the finite-difference approximation of the Laplacian and the damping term. Although it defines the update for a single time step only, Devito knows that we will be solving a time-dependent problem over a number of time steps because the wavefield u is a TimeFunction object.","title":"Symbolic definition of the wave propagator"},{"location":"tutorials/TLE_Forward/#setting-up-the-acquisition-geometry","text":"The expression for time stepping we derived in the previous section does not contain a seismic source function yet, so the update for the wavefield at a new time step is solely defined by the two previous wavefields. However as indicated in Equation 1, wavefields for seismic experiments are often excited by an active (impulsive) source q(x,y,t;x_\\text{s}) q(x,y,t;x_\\text{s}) , which is a function of space and time (just like the wavefield u ). To include such a source term in our modeling scheme, we simply add the the source wavefield as an additional term to Equation 3: \\mathbf{u}[\\text{time}+\\text{dt}] = 2\\mathbf{u}[\\text{time}] - \\mathbf{u}[\\text{time}-\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}} \\Big(\\Delta \\mathbf{u}[\\text{time}] + \\mathbf{q}[\\text{time}]\\Big). \\ \\ \\ \\ \\ \\ \\ (4) \\mathbf{u}[\\text{time}+\\text{dt}] = 2\\mathbf{u}[\\text{time}] - \\mathbf{u}[\\text{time}-\\text{dt}] + \\frac{\\text{dt}^2}{\\mathbf{m}} \\Big(\\Delta \\mathbf{u}[\\text{time}] + \\mathbf{q}[\\text{time}]\\Big). \\ \\ \\ \\ \\ \\ \\ (4) Since the source appears on the right-hand side in the original equation (Equation 1), the term also needs to be multiplied with \\frac{\\text{dt}^2}{\\mathbf{m}} \\frac{\\text{dt}^2}{\\mathbf{m}} (this follows from rearranging Equation 2, with the source on the right-hand side in place of 0). Unlike the discrete wavefield u however, the source q is typically localized in space and only a function of time, which means the time-dependent source wavelet is injected into the propagating wavefield at a specified source location. The same applies when we sample the wavefield at receiver locations to simulate a shot record, i.e. the simulated wavefield needs to be sampled at specified receiver locations only. Source and receiver both do not necessarily coincide with the modeling grid. Here, RickerSource acts as a wrapper around SparseFunction and models a Ricker wavelet with a peak frequency f0 and source coordinates src_coords : # NOT FOR MANUSCRIPT from examples.seismic import RickerSource # Src is halfway across model, at depth of 20 m. x_extent , _ = model . domain_size src_coords = [ x_extent / 2 , 20 ] f0 = 0.010 # kHz, peak frequency. src = RickerSource ( name = 'src' , grid = model . grid , f0 = f0 , time = time , coordinates = src_coords ) The src.inject function now injects the current time sample of the Ricker wavelet (weighted with \\frac{\\text{dt}^2}{\\mathbf{m}} \\frac{\\text{dt}^2}{\\mathbf{m}} as shown in Equation 4) into the updated wavefield u.forward at the specified coordinates. src_term = src . inject ( field = u . forward , expr = src * dt ** 2 / model . m , offset = model . nbpml ) To extract the wavefield at a predetermined set of receiver locations, there is a corresponding wrapper function for receivers as well, which creates a SparseFunction object for a given number npoint of receivers, number nt of time samples, and specified receiver coordinates rec_coords : # NOT FOR MANUSCRIPT from examples.seismic import Receiver # Recs are distributed across model, at depth of 20 m. x_locs = np . linspace ( 0 , x_extent , 101 ) rec_coords = [( x , 20 ) for x in x_locs ] rec = Receiver ( name = 'rec' , npoint = 101 , ntime = nt , grid = model . grid , coordinates = rec_coords ) Rather than injecting a function into the model as we did for the source, we now simply save the wavefield at the grid points that correspond to receiver positions and interpolate the data to their exact possibly of the computatational grid location: rec_term = rec . interpolate ( u , offset = model . nbpml ) # NOT FOR MANUSCRIPT # PLOTS HALF OF FIGURE 1. import matplotlib.patches as patches from matplotlib.ticker import MultipleLocator fig = plt . figure ( figsize = ( 9 , 9 )) extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], model . origin [ 1 ] + 1e-3 * model . shape [ 1 ] * model . spacing [ 1 ], model . origin [ 1 ]] model_param = dict ( vmin = 1.5 , vmax = 2.5 , cmap = \"GnBu\" , aspect = 1 , extent = extent ) ax0 = fig . add_subplot ( 111 ) im = plt . imshow ( np . transpose ( vp ), ** model_param ) cb = plt . colorbar ( shrink = 0.8 ) ax0 . set_ylabel ( 'Depth (km)' , fontsize = 20 ) ax0 . set_xlabel ( 'X position (km)' , fontsize = 20 ) cb . set_label ( 'Velocity (km/s)' , fontsize = 20 ) plt . xticks ( fontsize = 14 ) plt . yticks ( fontsize = 14 ) cb . ax . tick_params ( labelsize = 14 ) plt . scatter ( * ( rec . coordinates . data [:: 4 , :] . T / 1000 ), c = 'green' , clip_on = False , zorder = 100 ) plt . text ( * rec . coordinates . data [ 0 ] . T / 1000 + [ 0.02 , 0.05 ], \"receivers\" , color = 'green' , size = 14 ) plt . scatter ( * ( src . coordinates . data . squeeze () / 1000 ), c = 'red' , s = 60 ) plt . text ( * src . coordinates . data [ 0 ] / 1000 + [ 0 , 0.05 ], \"source\" , color = 'red' , size = 14 ) plt . scatter ( 0 , 0 , c = 'black' , s = 160 , clip_on = False , zorder = 101 ) plt . text ( - 0.01 , - 0.03 , \"Origin\" , color = 'k' , size = 16 , ha = \"right\" ) plt . text ( 0.02 , 0.5 - 0.03 , \"v = 1.5 km/s\" , color = 'k' , size = 16 , ha = \"left\" , va = 'center' ) plt . text ( 0.02 , 0.5 + 0.05 , \"v = 2.5 km/s\" , color = 'w' , size = 16 , ha = \"left\" , va = 'center' ) plt . title ( \"Example velocity model\" , color = 'k' , size = 24 ) plt . xlim (( 0 , 1 )) plt . ylim (( 1 , 0 )) minorLocator = MultipleLocator ( 1 / 100 ) ax0 . xaxis . set_minor_locator ( minorLocator ) ax0 . yaxis . set_minor_locator ( minorLocator ) plt . grid ( which = 'minor' , alpha = 0.3 ) plt . savefig ( \"../Figures/model.pdf\" , dpi = 400 ) plt . savefig ( \"../Figures/model.png\" ) plt . show ()","title":"Setting up the acquisition geometry"},{"location":"tutorials/TLE_Forward/#forward-simulation","text":"We can now define our forward propagator by adding the source and receiver terms to our stencil object: # NOT FOR MANUSCRIPT from devito import Operator op_fwd = Operator ([ stencil ] + src_term + rec_term ) The symbolic expressions used to create Operator contain sufficient meta-information for Devito to create a fully functional computational kernel. The dimension symbols contained in the symbolic function object ( time, x, y ) define the loop structure of the created code,while allowing Devito to automatically optimize the underlying loop structure to increase execution speed. The size of the loops and spacing between grid points is inferred from the symbolic Function objects and associated model.grid object at run-time. As a result, we can invoke the generated kernel through a simple Python function call by supplying the number of timesteps time and the timestep size dt . The user data associated with each Function is updated in-place during operator execution, allowing us to extract the final wavefield and shot record directly from the symbolic function objects without unwanted memory duplication: op_fwd ( time = nt , dt = model . critical_dt ) CustomCompiler: compiled /var/folders/8x/2cdqc7_57plfk5txbsszysbc0000gn/T/devito-nbfsni25/3d06ca83c7f841ceea604b9788ecda3d3e36bfef.c [1.99 s] ========================================================================================= Section section_1<595,1> with OI=0.80 computed in 0.000 s [0.45 GFlops/s] Section section_2<595,101> with OI=1.50 computed in 0.001 s [2.11 GFlops/s] Section main<595,180,180> with OI=3.27 computed in 0.072 s [14.15 GFlops/s, 0.27 GPts/s] ========================================================================================= When this has finished running, the resulting wavefield is stored in u.data and the shot record is in rec.data . We can easily plot this 2D array as an image, as shown in Figure 2. # NOT FOR MANUSCRIPT # GENERATES FIGURE 2 from matplotlib import cm fig1 = plt . figure ( figsize = ( 10 , 10 )) l = plt . imshow ( rec . data , vmin =- 1 , vmax = 1 , cmap = cm . gray , aspect = 1 , extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], 1e-3 * tn , t0 ]) plt . xlabel ( 'X position (km)' , fontsize = 20 ) plt . ylabel ( 'Time (s)' , fontsize = 20 ) plt . tick_params ( labelsize = 20 ) plt . savefig ( \"../Figures/Figure2.png\" , dpi = 400 ) plt . savefig ( \"../Figures/Figure2.pdf\" ) plt . show () Figure 2. The shot record generated by Devito for the example velocity model. As demonstrated in the notebook, a movie of snapshots of the forward wavefield can also be generated by capturing the wavefield at discrete time steps. Figure 3 shows three timesteps from the movie. # NOT FOR MANUSCRIPT # GENERATES FIGURE 3 fig = plt . figure ( figsize = ( 15 , 5 )) times = [ 200 , 300 , 400 ] extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], model . origin [ 1 ] + 1e-3 * model . shape [ 1 ] * model . spacing [ 1 ], model . origin [ 1 ]] data_param = dict ( vmin =- 1e0 , vmax = 1e0 , cmap = cm . Greys , aspect = 1 , extent = extent , interpolation = 'none' ) model_param = dict ( vmin = 1.5 , vmax = 2.5 , cmap = cm . GnBu , aspect = 1 , extent = extent , alpha =. 3 ) ax0 = fig . add_subplot ( 131 ) _ = plt . imshow ( np . transpose ( u . data [ times [ 0 ], 40 : - 40 , 40 : - 40 ]), ** data_param ) _ = plt . imshow ( np . transpose ( vp ), ** model_param ) ax0 . set_ylabel ( 'Depth (km)' , fontsize = 20 ) ax0 . text ( 0.5 , 0.08 , \"t = {:.0f} ms\" . format ( time [ times [ 0 ]]), ha = \"center\" , color = 'k' ) ax1 = fig . add_subplot ( 132 ) _ = plt . imshow ( np . transpose ( u . data [ times [ 1 ], 40 : - 40 , 40 : - 40 ]), ** data_param ) _ = plt . imshow ( np . transpose ( vp ), ** model_param ) ax1 . set_xlabel ( 'X position (km)' , fontsize = 20 ) ax1 . set_yticklabels ([]) ax1 . text ( 0.5 , 0.08 , \"t = {:.0f} ms\" . format ( time [ times [ 1 ]]), ha = \"center\" , color = 'k' ) ax2 = fig . add_subplot ( 133 ) _ = plt . imshow ( np . transpose ( u . data [ times [ 2 ], 40 : - 40 , 40 : - 40 ]), ** data_param ) _ = plt . imshow ( np . transpose ( vp ), ** model_param ) ax2 . set_yticklabels ([]) ax2 . text ( 0.5 , 0.08 , \"t = {:.0f} ms\" . format ( time [ times [ 2 ]]), ha = \"center\" , color = 'k' ) plt . savefig ( \"../Figures/Figure3.pdf\" ) plt . savefig ( \"../Figures/Figure3.png\" , dpi = 400 ) plt . show () Figure 3. Three time steps from the wavefield simulation that resulted in the shot record in Figure 2. You can generate an animated version in the Notebook at github.com/seg. # NOT FOR MANUSCRIPT import matplotlib.animation as animation from IPython.display import HTML fig = plt . figure () im = plt . imshow ( np . transpose ( u . data [ 0 , 40 : - 40 , 40 : - 40 ]), cmap = \"Greys\" , animated = True , vmin =- 1e0 , vmax = 1e0 , aspect = 1 , extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], model . origin [ 1 ] + 1e-3 * model . shape [ 1 ] * model . spacing [ 1 ], model . origin [ 1 ]]) plt . xlabel ( 'X position (km)' , fontsize = 20 ) plt . ylabel ( 'Depth (km)' , fontsize = 20 ) plt . tick_params ( labelsize = 20 ) im2 = plt . imshow ( np . transpose ( vp ), vmin = 1.5 , vmax = 2.5 , cmap = cm . GnBu , aspect = 1 , extent = [ model . origin [ 0 ], model . origin [ 0 ] + 1e-3 * model . shape [ 0 ] * model . spacing [ 0 ], model . origin [ 1 ] + 1e-3 * model . shape [ 1 ] * model . spacing [ 1 ], model . origin [ 1 ]], alpha =. 4 ) def updatefig ( i ): im . set_array ( np . transpose ( u . data [ i * 5 , 40 : - 40 , 40 : - 40 ])) return im , im2 ani = animation . FuncAnimation ( fig , updatefig , frames = np . linspace ( 0 , nt / 5 - 1 , nt // 5 , dtype = np . int64 ), blit = True , interval = 50 ) plt . close ( ani . _fig ) HTML ( ani . to_html5_video ()) Your browser does not support the video tag. # ani.save('../figures/animation.gif', writer='imagemagick', fps=30) # from IPython.display import Image # Image(url='../figures/animation.gif')","title":"Forward simulation"},{"location":"tutorials/TLE_Forward/#conclusions","text":"In this first part of the tutorial, we have demonstrated how to set up the discretized forward acoustic wave equations and its associated wave propagator with runtime code generation. While we limited our discussion to the constant density acoustic wave equation, Devito is capable of handling more general wave equations but this is a topic beyond this tutorial on simulating waves for inversion. In part two of our tutorial, we will show how to calculate a valid gradient of the FWI objective using the adjoint state method. In part three, we will demonstrate how to set up a complete matrix-free and scalable optimization framework for acoustic FWI.","title":"Conclusions"},{"location":"tutorials/TLE_Forward/#acknowledgments","text":"This research was carried out as part of the SINBAD II project with the support of the member organizations of the SINBAD Consortium. This work was financially supported in part by EPSRC grant EP/L000407/1 and the Imperial College London Intel Parallel Computing Centre.","title":"Acknowledgments"},{"location":"tutorials/TLE_Forward/#references","text":"Cerjan, C., Kosloff, D., Kosloff, R., and Reshef, M., 1985, A nonreflecting boundary condition for discrete acoustic and elastic wave equations: GEOPHYSICS, 50, 705\u2013708. doi:10.1190/1.1441945 Lange, M., Kukreja, N., Louboutin, M., Luporini, F., Zacarias, F. V., Pandolfo, V., Gorman, G., 2016, Devito: Towards a generic finite difference DSL using symbolic python: 6 th workshop on python for high-performance and scientific computing. doi:10.1109/PyHPC.2016.9 Meurer A, Smith CP, Paprocki M, et al., 2017, SymPy: symbolic computing in Python. PeerJ Computer Science 3:e103 https://doi.org/10.7717/peerj-cs.103 Pratt, R. G., 1999, Seismic waveform inversion in the frequency domain, part 1: Theory and verification in a physical scale model: GEOPHYSICS, 64, 888\u2013901. doi:10.1190/1.1444597 Tarantola, A., 1984, Inversion of seismic reflection data in the acoustic approximation: GEOPHYSICS, 49, 1259\u20131266. doi:10.1190/1.1441754 Virieux, J., and Operto, S., 2009, An overview of full-waveform inversion in exploration geophysics: GEOPHYSICS, 74, WCC1\u2013WCC26. doi:10.1190/1.3238367","title":"References"},{"location":"tutorials/TLE_Forward/#supplemental-material","text":"Devito documentation Devito source code and examples Tutorial notebooks with latest Devito/master \u00a9 2017 The authors \u2014 licensed CC-BY-SA","title":"Supplemental material"}]}
{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Devito-Examples Documentation for the seismic modeling and inversion examples developed at Georgia Institute of Technology with contribution from the rest of the Devito team at Imperial College London (in particular F. Luporini, R. Nelson and G. Bismas). Overview This repository contains a set of examples and tutorials for seismic modeling and inversion using Devito . These examples use four different wave equations, namely The acoustic isotropic wave equation in seismic/acoustic The TTI pseudo-acoustic wave equation in seismic/tti The elastic isotropic wave equation in seismic/elastic The viscoelastic isotropic wave equation in seismic/elastic Currently, the acoustic isotropic wave equation solver also contains the propagator associated with the adjoint and linearized (Born) wave-equation solution and the gradient of the FWI objective (application of the Jacobian to data residual) Disclaimer A good part of these examples can also be found in the Devito examples directory as a fork of this one. These examples for seismic applications have been developed and implemented by Mathias Louboutin at Georgian Institute of Technology. Some extra examples are also included over there, such as tutorials on the Devito compiler as these examples have been developed primarily at Imperial College London. Installation To install this set of examples with its dependencies run in your terminal (OSX, Ubuntu): git clone https://github.com/slimgroup/Devito-Examples cd Devito-Examples pip install -e . This command will install all dependencies including Devito and will allow you to run the examples. To verify your installation you can run: python seismic/acoustic/acoustic_example.py -nd 1 Some of the examples require velocity models such as the marmousi-ii model. These models can be downloaded at devito-data to be used in the tutorials. Related literature Some of these examples are described in the following papers: Devito's symbolic API \\ TTI imaging \\ Mathias Louboutin's thesis More advanced geophysical application can be found in the JUDI repository. JUDI is a linear algebra DSL built on top of Devito for large scale inverse problems and includes abstractions for source/receivers and handles large SEG-Y datasets with SegyIO . A complete description of JUDI and the related seismic inversion application can be found in Philipp Witte's thesis .","title":"Home"},{"location":"#devito-examples","text":"Documentation for the seismic modeling and inversion examples developed at Georgia Institute of Technology with contribution from the rest of the Devito team at Imperial College London (in particular F. Luporini, R. Nelson and G. Bismas).","title":"Devito-Examples"},{"location":"#overview","text":"This repository contains a set of examples and tutorials for seismic modeling and inversion using Devito . These examples use four different wave equations, namely The acoustic isotropic wave equation in seismic/acoustic The TTI pseudo-acoustic wave equation in seismic/tti The elastic isotropic wave equation in seismic/elastic The viscoelastic isotropic wave equation in seismic/elastic Currently, the acoustic isotropic wave equation solver also contains the propagator associated with the adjoint and linearized (Born) wave-equation solution and the gradient of the FWI objective (application of the Jacobian to data residual)","title":"Overview"},{"location":"#disclaimer","text":"A good part of these examples can also be found in the Devito examples directory as a fork of this one. These examples for seismic applications have been developed and implemented by Mathias Louboutin at Georgian Institute of Technology. Some extra examples are also included over there, such as tutorials on the Devito compiler as these examples have been developed primarily at Imperial College London.","title":"Disclaimer"},{"location":"#installation","text":"To install this set of examples with its dependencies run in your terminal (OSX, Ubuntu): git clone https://github.com/slimgroup/Devito-Examples cd Devito-Examples pip install -e . This command will install all dependencies including Devito and will allow you to run the examples. To verify your installation you can run: python seismic/acoustic/acoustic_example.py -nd 1 Some of the examples require velocity models such as the marmousi-ii model. These models can be downloaded at devito-data to be used in the tutorials.","title":"Installation"},{"location":"#related-literature","text":"Some of these examples are described in the following papers: Devito's symbolic API \\ TTI imaging \\ Mathias Louboutin's thesis More advanced geophysical application can be found in the JUDI repository. JUDI is a linear algebra DSL built on top of Devito for large scale inverse problems and includes abstractions for source/receivers and handles large SEG-Y datasets with SegyIO . A complete description of JUDI and the related seismic inversion application can be found in Philipp Witte's thesis .","title":"Related literature"},{"location":"tutorials/01_modelling/","text":"01 - Introduction to seismic modelling This notebook is the first in a series of tutorials highlighting various aspects of seismic inversion based on Devito operators. In this first example we aim to highlight the core ideas behind seismic modelling, where we create a numerical model that captures the processes involved in a seismic survey. This forward model will then form the basis for further tutorials on the implementation of inversion processes using Devito operators. Modelling workflow The core process we are aiming to model is a seismic survey, which consists of two main components: Source - A source is positioned at a single or a few physical locations where artificial pressure is injected into the domain we want to model. In the case of land survey, it is usually dynamite blowing up at a given location, or a vibroseis (a vibrating engine generating continuous sound waves). For a marine survey, the source is an air gun sending a bubble of compressed air into the water that will expand and generate a seismic wave. Receiver - A set of microphones or hydrophones are used to measure the resulting wave and create a set of measurements called a Shot Record . These measurements are recorded at multiple locations, and usually at the surface of the domain or at the bottom of the ocean in some marine cases. In order to create a numerical model of a seismic survey, we need to solve the wave equation and implement source and receiver interpolation to inject the source and record the seismic wave at sparse point locations in the grid. The acoustic seismic wave equation The acoustic wave equation for the square slowness m m , defined as m=\\frac{1}{c^2} m=\\frac{1}{c^2} , where c c is the speed of sound in the given physical media, and a source q q is given by: \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) = q \\ \\text{in } \\Omega \\\\ &u(.,t=0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) = q \\ \\text{in } \\Omega \\\\ &u(.,t=0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} with the zero initial conditions to guarantee unicity of the solution. The boundary conditions are Dirichlet conditions: \\begin{equation} u(x,t)|_\\delta\\Omega = 0 \\end{equation} where \\delta\\Omega \\delta\\Omega is the surface of the boundary of the model \\Omega \\Omega . Finite domains The last piece of the puzzle is the computational limitation. In the field, the seismic wave propagates in every direction to an \"infinite\" distance. However, solving the wave equation in a mathematically/discrete infinite domain is not feasible. In order to compensate, Absorbing Boundary Conditions (ABC) or Perfectly Matched Layers (PML) are required to mimic an infinite domain. These two methods allow to approximate an infinite media by damping and absorbing the waves at the limit of the domain to avoid reflections. The simplest of these methods is the absorbing damping mask. The core idea is to extend the physical domain and to add a Sponge mask in this extension that will absorb the incident waves. The acoustic wave equation with this damping mask can be rewritten as: \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) + \\eta \\frac{d u(x,t)}{dt}=q \\ \\text{in } \\Omega \\\\ &u(.,0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) + \\eta \\frac{d u(x,t)}{dt}=q \\ \\text{in } \\Omega \\\\ &u(.,0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} where \\eta \\eta is the damping mask equal to 0 0 inside the physical domain and increasing inside the sponge layer. Multiple choice of profile can be chosen for \\eta \\eta from linear to exponential. Seismic modelling with devito We describe here a step by step setup of seismic modelling with Devito in a simple 2D case. We will create a physical model of our domain and define a single source and an according set of receivers to model for the forward model. But first, we initialize some basic utilities. import numpy as np % matplotlib inline Define the physical problem The first step is to define the physical model: What are the physical dimensions of interest What is the velocity profile of this physical domain We will create a simple velocity model here by hand for demonstration purposes. This model essentially consists of two layers, each with a different velocity: 1.5km/s 1.5km/s in the top layer and 2.5km/s 2.5km/s in the bottom layer. We will use this simple model a lot in the following tutorials, so we will rely on a utility function to create it again later. #NBVAL_IGNORE_OUTPUT from seismic import Model , plot_velocity # Define a physical size shape = ( 101 , 101 ) # Number of grid point (nx, nz) spacing = ( 10. , 10. ) # Grid spacing in m. The domain size is now 1km by 1km origin = ( 0. , 0. ) # What is the location of the top left corner. This is necessary to define # the absolute location of the source and receivers # Define a velocity profile. The velocity is in km/s v = np . empty ( shape , dtype = np . float32 ) v [:, : 51 ] = 1.5 v [:, 51 :] = 2.5 # With the velocity and model size defined, we can create the seismic model that # encapsulates this properties. We also define the size of the absorbing layer as 10 grid points model = Model ( vp = v , origin = origin , shape = shape , spacing = spacing , space_order = 2 , nbl = 10 ) plot_velocity ( model ) Operator `initdamp` run in 0.03 s Operator `padfunc` run in 0.01 s Acquisition geometry To fully define our problem setup we also need to define the source that injects the wave to model and the set of receiver locations at which to sample the wavefield. The source time signature will be modelled using a Ricker wavelet defined as \\begin{equation} q(t) = (1-2\\pi^2 f_0^2 (t - \\frac{1}{f_0})^2 )e^{- \\pi^2 f_0^2 (t - \\frac{1}{f_0})} \\end{equation} \\begin{equation} q(t) = (1-2\\pi^2 f_0^2 (t - \\frac{1}{f_0})^2 )e^{- \\pi^2 f_0^2 (t - \\frac{1}{f_0})} \\end{equation} To fully define the source signature we first need to define the time duration for our model and the timestep size, which is dictated by the CFL condition and our grid spacing. Luckily, our Model utility provides us with the critical timestep size, so we can fully discretize our model time axis as an array: from seismic import TimeAxis t0 = 0. # Simulation starts a t=0 tn = 1000. # Simulation last 1 second (1000 ms) dt = model . critical_dt # Time step from model grid spacing time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) The source is positioned at a 20m 20m depth and at the middle of the x x axis ( x_{src}=500m x_{src}=500m ), with a peak wavelet frequency of 10Hz 10Hz . #NBVAL_IGNORE_OUTPUT from seismic import RickerSource f0 = 0.010 # Source peak frequency is 10Hz (0.010 kHz) src = RickerSource ( name = 'src' , grid = model . grid , f0 = f0 , npoint = 1 , time_range = time_range ) # First, position source centrally in all dimensions, then set depth src . coordinates . data [ 0 , :] = np . array ( model . domain_size ) * . 5 src . coordinates . data [ 0 , - 1 ] = 20. # Depth is 20m # We can plot the time signature to see the wavelet src . show () Similarly to our source object, we can now define our receiver geometry as a symbol of type Receiver . It is worth noting here that both utility classes, RickerSource and Receiver are thin wrappers around the Devito's SparseTimeFunction type, which encapsulates sparse point data and allows us to inject and interpolate values into and out of the computational grid. As we have already seen, both types provide a .coordinates property to define the position within the domain of all points encapsulated by that symbol. In this example we will position receivers at the same depth as the source, every 10m 10m along the x axis. The rec.data property will be initialized, but left empty, as we will compute the receiver readings during the simulation. #NBVAL_IGNORE_OUTPUT from seismic import Receiver # Create symbol for 101 receivers rec = Receiver ( name = 'rec' , grid = model . grid , npoint = 101 , time_range = time_range ) # Prescribe even spacing for receivers along the x-axis rec . coordinates . data [:, 0 ] = np . linspace ( 0 , model . domain_size [ 0 ], num = 101 ) rec . coordinates . data [:, 1 ] = 20. # Depth is 20m # We can now show the source and receivers within our domain: # Red dot: Source location # Green dots: Receiver locations (every 4th point) plot_velocity ( model , source = src . coordinates . data , receiver = rec . coordinates . data [:: 4 , :]) Finite-difference discretization Devito is a finite-difference DSL that solves the discretized wave-equation on a Cartesian grid. The finite-difference approximation is derived from Taylor expansions of the continuous field after removing the error term. Time discretization We only consider the second order time discretization for now. From the Taylor expansion, the second order discrete approximation of the second order time derivative is: \\begin{equation} \\begin{aligned} \\frac{d^2 u(x,t)}{dt^2} = \\frac{\\mathbf{u}(\\mathbf{x},\\mathbf{t+\\Delta t}) - 2 \\mathbf{u}(\\mathbf{x},\\mathbf{t}) + \\mathbf{u}(\\mathbf{x},\\mathbf{t-\\Delta t})}{\\mathbf{\\Delta t}^2} + O(\\mathbf{\\Delta t}^2). \\end{aligned} \\end{equation} where \\mathbf{u} \\mathbf{u} is the discrete wavefield, \\mathbf{\\Delta t} \\mathbf{\\Delta t} is the discrete time-step (distance between two consecutive discrete time points) and O(\\mathbf{\\Delta t}^2) O(\\mathbf{\\Delta t}^2) is the discretization error term. The discretized approximation of the second order time derivative is then given by dropping the error term. This derivative is represented in Devito by u.dt2 where u is a TimeFunction object. Spatial discretization We define the discrete Laplacian as the sum of the second order spatial derivatives in the three dimensions: \\begin{equation} \\begin{aligned} \\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t})= \\sum_{j=1}^{j=\\frac{k}{2}} \\Bigg[\\alpha_j \\Bigg(& \\mathbf{u}(\\mathbf{x+jdx},\\mathbf{y},\\mathbf{z},\\mathbf{t})+\\mathbf{u}(\\mathbf{x-jdx},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\\\ &\\mathbf{u}(\\mathbf{x},\\mathbf{y+jdy},\\mathbf{z},\\mathbf{t})+\\mathbf{u}(\\mathbf{x},\\mathbf{y-jdy},\\mathbf{z}\\mathbf{t}) + \\\\ &\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z+jdz},\\mathbf{t})+\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z-jdz},\\mathbf{t})\\Bigg) \\Bigg] + \\\\ &3\\alpha_0 \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}). \\end{aligned} \\end{equation} This derivative is represented in Devito by u.laplace where u is a TimeFunction object. Wave equation With the space and time discretization defined, we can fully discretize the wave-equation with the combination of time and space discretizations and obtain the following second order in time and k^{th} k^{th} order in space discrete stencil to update one grid point at position \\mathbf{x}, \\mathbf{y},\\mathbf{z} \\mathbf{x}, \\mathbf{y},\\mathbf{z} at time \\mathbf{t} \\mathbf{t} , i.e. \\begin{equation} \\begin{aligned} \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t+\\Delta t}) = &2\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) - \\mathbf{u}(\\mathbf{x},\\mathbf{y}, \\mathbf{z},\\mathbf{t-\\Delta t}) +\\\\ & \\frac{\\mathbf{\\Delta t}^2}{\\mathbf{m(\\mathbf{x},\\mathbf{y},\\mathbf{z})}} \\Big(\\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\mathbf{q}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) \\Big). \\end{aligned} \\end{equation} # In order to represent the wavefield u and the square slowness we need symbolic objects # corresponding to time-space-varying field (u, TimeFunction) and # space-varying field (m, Function) from devito import TimeFunction # Define the wavefield with the size of the model and the time dimension u = TimeFunction ( name = \"u\" , grid = model . grid , time_order = 2 , space_order = 2 ) # We can now write the PDE pde = model . m * u . dt2 - u . laplace + model . damp * u . dt # The PDE representation is as on paper pde \\displaystyle \\operatorname{damp}{\\left(x,y \\right)} \\frac{\\partial}{\\partial t} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial x^{2}} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial y^{2}} u{\\left(t,x,y \\right)} + \\frac{\\frac{\\partial^{2}}{\\partial t^{2}} u{\\left(t,x,y \\right)}}{\\operatorname{vp}^{2}{\\left(x,y \\right)}} \\displaystyle \\operatorname{damp}{\\left(x,y \\right)} \\frac{\\partial}{\\partial t} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial x^{2}} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial y^{2}} u{\\left(t,x,y \\right)} + \\frac{\\frac{\\partial^{2}}{\\partial t^{2}} u{\\left(t,x,y \\right)}}{\\operatorname{vp}^{2}{\\left(x,y \\right)}} # This discrete PDE can be solved in a time-marching way updating u(t+dt) from the previous time step # Devito as a shortcut for u(t+dt) which is u.forward. We can then rewrite the PDE as # a time marching updating equation known as a stencil using customized SymPy functions from devito import Eq , solve stencil = Eq ( u . forward , solve ( pde , u . forward )) Source injection and receiver interpolation With a numerical scheme to solve the homogenous wave equation, we need to add the source to introduce seismic waves and to implement the measurement operator, and interpolation operator. This operation is linked to the discrete scheme and needs to be done at the proper time step. The semi-discretized in time wave equation with a source reads: \\begin{equation} \\begin{aligned} \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t+\\Delta t}) = &2\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) - \\mathbf{u}(\\mathbf{x},\\mathbf{y}, \\mathbf{z},\\mathbf{t-\\Delta t}) +\\\\ & \\frac{\\mathbf{\\Delta t}^2}{\\mathbf{m(\\mathbf{x},\\mathbf{y},\\mathbf{z})}} \\Big(\\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\mathbf{q}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) \\Big). \\end{aligned} \\end{equation} \\begin{equation} \\begin{aligned} \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t+\\Delta t}) = &2\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) - \\mathbf{u}(\\mathbf{x},\\mathbf{y}, \\mathbf{z},\\mathbf{t-\\Delta t}) +\\\\ & \\frac{\\mathbf{\\Delta t}^2}{\\mathbf{m(\\mathbf{x},\\mathbf{y},\\mathbf{z})}} \\Big(\\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\mathbf{q}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) \\Big). \\end{aligned} \\end{equation} It shows that in order to update \\mathbf{u} \\mathbf{u} at time \\mathbf{t+\\Delta t} \\mathbf{t+\\Delta t} we have to inject the value of the source term \\mathbf{q} \\mathbf{q} of time \\mathbf{t} \\mathbf{t} . In Devito, it corresponds the update of u u at index t+1 t+1 (t = time implicitly) with the source of time t t . On the receiver side, the problem is either as it only requires to record the data at the given time step t t for the receiver at time time=t time=t . # Finally we define the source injection and receiver read function to generate the corresponding code src_term = src . inject ( field = u . forward , expr = src * dt ** 2 / model . m ) # Create interpolation expression for receivers rec_term = rec . interpolate ( expr = u . forward ) Devito operator and solve After constructing all the necessary expressions for updating the wavefield, injecting the source term and interpolating onto the receiver points, we can now create the Devito operator that will generate the C code at runtime. When creating the operator, Devito's two optimization engines will log which performance optimizations have been performed: * DSE: The Devito Symbolics Engine will attempt to reduce the number of operations required by the kernel. * DLE: The Devito Loop Engine will perform various loop-level optimizations to improve runtime performance. Note : The argument subs=model.spacing_map causes the operator to substitute values for our current grid spacing into the expressions before code generation. This reduces the number of floating point operations executed by the kernel by pre-evaluating certain coefficients. #NBVAL_IGNORE_OUTPUT from devito import Operator op = Operator ([ stencil ] + src_term + rec_term , subs = model . spacing_map ) Now we can execute the create operator for a number of timesteps. We specify the number of timesteps to compute with the keyword time and the timestep size with dt . #NBVAL_IGNORE_OUTPUT op ( time = time_range . num - 1 , dt = model . critical_dt ) Operator `Kernel` run in 0.02 s After running our operator kernel, the data associated with the receiver symbol rec.data has now been populated due to the interpolation expression we inserted into the operator. This allows us the visualize the shot record: #NBVAL_IGNORE_OUTPUT from seismic import plot_shotrecord plot_shotrecord ( rec . data , model , t0 , tn ) assert np . isclose ( np . linalg . norm ( rec . data ), 450 , rtol = 10 )","title":"Acoustic modeling"},{"location":"tutorials/01_modelling/#01-introduction-to-seismic-modelling","text":"This notebook is the first in a series of tutorials highlighting various aspects of seismic inversion based on Devito operators. In this first example we aim to highlight the core ideas behind seismic modelling, where we create a numerical model that captures the processes involved in a seismic survey. This forward model will then form the basis for further tutorials on the implementation of inversion processes using Devito operators.","title":"01 - Introduction to seismic modelling"},{"location":"tutorials/01_modelling/#modelling-workflow","text":"The core process we are aiming to model is a seismic survey, which consists of two main components: Source - A source is positioned at a single or a few physical locations where artificial pressure is injected into the domain we want to model. In the case of land survey, it is usually dynamite blowing up at a given location, or a vibroseis (a vibrating engine generating continuous sound waves). For a marine survey, the source is an air gun sending a bubble of compressed air into the water that will expand and generate a seismic wave. Receiver - A set of microphones or hydrophones are used to measure the resulting wave and create a set of measurements called a Shot Record . These measurements are recorded at multiple locations, and usually at the surface of the domain or at the bottom of the ocean in some marine cases. In order to create a numerical model of a seismic survey, we need to solve the wave equation and implement source and receiver interpolation to inject the source and record the seismic wave at sparse point locations in the grid.","title":"Modelling workflow"},{"location":"tutorials/01_modelling/#the-acoustic-seismic-wave-equation","text":"The acoustic wave equation for the square slowness m m , defined as m=\\frac{1}{c^2} m=\\frac{1}{c^2} , where c c is the speed of sound in the given physical media, and a source q q is given by: \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) = q \\ \\text{in } \\Omega \\\\ &u(.,t=0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) = q \\ \\text{in } \\Omega \\\\ &u(.,t=0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} with the zero initial conditions to guarantee unicity of the solution. The boundary conditions are Dirichlet conditions: \\begin{equation} u(x,t)|_\\delta\\Omega = 0 \\end{equation} where \\delta\\Omega \\delta\\Omega is the surface of the boundary of the model \\Omega \\Omega .","title":"The acoustic seismic wave equation"},{"location":"tutorials/01_modelling/#finite-domains","text":"The last piece of the puzzle is the computational limitation. In the field, the seismic wave propagates in every direction to an \"infinite\" distance. However, solving the wave equation in a mathematically/discrete infinite domain is not feasible. In order to compensate, Absorbing Boundary Conditions (ABC) or Perfectly Matched Layers (PML) are required to mimic an infinite domain. These two methods allow to approximate an infinite media by damping and absorbing the waves at the limit of the domain to avoid reflections. The simplest of these methods is the absorbing damping mask. The core idea is to extend the physical domain and to add a Sponge mask in this extension that will absorb the incident waves. The acoustic wave equation with this damping mask can be rewritten as: \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) + \\eta \\frac{d u(x,t)}{dt}=q \\ \\text{in } \\Omega \\\\ &u(.,0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} \\begin{cases} &m \\frac{d^2 u(x,t)}{dt^2} - \\nabla^2 u(x,t) + \\eta \\frac{d u(x,t)}{dt}=q \\ \\text{in } \\Omega \\\\ &u(.,0) = 0 \\\\ &\\frac{d u(x,t)}{dt}|_{t=0} = 0 \\end{cases} where \\eta \\eta is the damping mask equal to 0 0 inside the physical domain and increasing inside the sponge layer. Multiple choice of profile can be chosen for \\eta \\eta from linear to exponential.","title":"Finite domains"},{"location":"tutorials/01_modelling/#seismic-modelling-with-devito","text":"We describe here a step by step setup of seismic modelling with Devito in a simple 2D case. We will create a physical model of our domain and define a single source and an according set of receivers to model for the forward model. But first, we initialize some basic utilities. import numpy as np % matplotlib inline","title":"Seismic modelling with devito"},{"location":"tutorials/01_modelling/#define-the-physical-problem","text":"The first step is to define the physical model: What are the physical dimensions of interest What is the velocity profile of this physical domain We will create a simple velocity model here by hand for demonstration purposes. This model essentially consists of two layers, each with a different velocity: 1.5km/s 1.5km/s in the top layer and 2.5km/s 2.5km/s in the bottom layer. We will use this simple model a lot in the following tutorials, so we will rely on a utility function to create it again later. #NBVAL_IGNORE_OUTPUT from seismic import Model , plot_velocity # Define a physical size shape = ( 101 , 101 ) # Number of grid point (nx, nz) spacing = ( 10. , 10. ) # Grid spacing in m. The domain size is now 1km by 1km origin = ( 0. , 0. ) # What is the location of the top left corner. This is necessary to define # the absolute location of the source and receivers # Define a velocity profile. The velocity is in km/s v = np . empty ( shape , dtype = np . float32 ) v [:, : 51 ] = 1.5 v [:, 51 :] = 2.5 # With the velocity and model size defined, we can create the seismic model that # encapsulates this properties. We also define the size of the absorbing layer as 10 grid points model = Model ( vp = v , origin = origin , shape = shape , spacing = spacing , space_order = 2 , nbl = 10 ) plot_velocity ( model ) Operator `initdamp` run in 0.03 s Operator `padfunc` run in 0.01 s","title":"Define the physical problem"},{"location":"tutorials/01_modelling/#acquisition-geometry","text":"To fully define our problem setup we also need to define the source that injects the wave to model and the set of receiver locations at which to sample the wavefield. The source time signature will be modelled using a Ricker wavelet defined as \\begin{equation} q(t) = (1-2\\pi^2 f_0^2 (t - \\frac{1}{f_0})^2 )e^{- \\pi^2 f_0^2 (t - \\frac{1}{f_0})} \\end{equation} \\begin{equation} q(t) = (1-2\\pi^2 f_0^2 (t - \\frac{1}{f_0})^2 )e^{- \\pi^2 f_0^2 (t - \\frac{1}{f_0})} \\end{equation} To fully define the source signature we first need to define the time duration for our model and the timestep size, which is dictated by the CFL condition and our grid spacing. Luckily, our Model utility provides us with the critical timestep size, so we can fully discretize our model time axis as an array: from seismic import TimeAxis t0 = 0. # Simulation starts a t=0 tn = 1000. # Simulation last 1 second (1000 ms) dt = model . critical_dt # Time step from model grid spacing time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) The source is positioned at a 20m 20m depth and at the middle of the x x axis ( x_{src}=500m x_{src}=500m ), with a peak wavelet frequency of 10Hz 10Hz . #NBVAL_IGNORE_OUTPUT from seismic import RickerSource f0 = 0.010 # Source peak frequency is 10Hz (0.010 kHz) src = RickerSource ( name = 'src' , grid = model . grid , f0 = f0 , npoint = 1 , time_range = time_range ) # First, position source centrally in all dimensions, then set depth src . coordinates . data [ 0 , :] = np . array ( model . domain_size ) * . 5 src . coordinates . data [ 0 , - 1 ] = 20. # Depth is 20m # We can plot the time signature to see the wavelet src . show () Similarly to our source object, we can now define our receiver geometry as a symbol of type Receiver . It is worth noting here that both utility classes, RickerSource and Receiver are thin wrappers around the Devito's SparseTimeFunction type, which encapsulates sparse point data and allows us to inject and interpolate values into and out of the computational grid. As we have already seen, both types provide a .coordinates property to define the position within the domain of all points encapsulated by that symbol. In this example we will position receivers at the same depth as the source, every 10m 10m along the x axis. The rec.data property will be initialized, but left empty, as we will compute the receiver readings during the simulation. #NBVAL_IGNORE_OUTPUT from seismic import Receiver # Create symbol for 101 receivers rec = Receiver ( name = 'rec' , grid = model . grid , npoint = 101 , time_range = time_range ) # Prescribe even spacing for receivers along the x-axis rec . coordinates . data [:, 0 ] = np . linspace ( 0 , model . domain_size [ 0 ], num = 101 ) rec . coordinates . data [:, 1 ] = 20. # Depth is 20m # We can now show the source and receivers within our domain: # Red dot: Source location # Green dots: Receiver locations (every 4th point) plot_velocity ( model , source = src . coordinates . data , receiver = rec . coordinates . data [:: 4 , :])","title":"Acquisition geometry"},{"location":"tutorials/01_modelling/#finite-difference-discretization","text":"Devito is a finite-difference DSL that solves the discretized wave-equation on a Cartesian grid. The finite-difference approximation is derived from Taylor expansions of the continuous field after removing the error term.","title":"Finite-difference discretization"},{"location":"tutorials/01_modelling/#time-discretization","text":"We only consider the second order time discretization for now. From the Taylor expansion, the second order discrete approximation of the second order time derivative is: \\begin{equation} \\begin{aligned} \\frac{d^2 u(x,t)}{dt^2} = \\frac{\\mathbf{u}(\\mathbf{x},\\mathbf{t+\\Delta t}) - 2 \\mathbf{u}(\\mathbf{x},\\mathbf{t}) + \\mathbf{u}(\\mathbf{x},\\mathbf{t-\\Delta t})}{\\mathbf{\\Delta t}^2} + O(\\mathbf{\\Delta t}^2). \\end{aligned} \\end{equation} where \\mathbf{u} \\mathbf{u} is the discrete wavefield, \\mathbf{\\Delta t} \\mathbf{\\Delta t} is the discrete time-step (distance between two consecutive discrete time points) and O(\\mathbf{\\Delta t}^2) O(\\mathbf{\\Delta t}^2) is the discretization error term. The discretized approximation of the second order time derivative is then given by dropping the error term. This derivative is represented in Devito by u.dt2 where u is a TimeFunction object.","title":"Time discretization"},{"location":"tutorials/01_modelling/#spatial-discretization","text":"We define the discrete Laplacian as the sum of the second order spatial derivatives in the three dimensions: \\begin{equation} \\begin{aligned} \\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t})= \\sum_{j=1}^{j=\\frac{k}{2}} \\Bigg[\\alpha_j \\Bigg(& \\mathbf{u}(\\mathbf{x+jdx},\\mathbf{y},\\mathbf{z},\\mathbf{t})+\\mathbf{u}(\\mathbf{x-jdx},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\\\ &\\mathbf{u}(\\mathbf{x},\\mathbf{y+jdy},\\mathbf{z},\\mathbf{t})+\\mathbf{u}(\\mathbf{x},\\mathbf{y-jdy},\\mathbf{z}\\mathbf{t}) + \\\\ &\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z+jdz},\\mathbf{t})+\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z-jdz},\\mathbf{t})\\Bigg) \\Bigg] + \\\\ &3\\alpha_0 \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}). \\end{aligned} \\end{equation} This derivative is represented in Devito by u.laplace where u is a TimeFunction object.","title":"Spatial discretization"},{"location":"tutorials/01_modelling/#wave-equation","text":"With the space and time discretization defined, we can fully discretize the wave-equation with the combination of time and space discretizations and obtain the following second order in time and k^{th} k^{th} order in space discrete stencil to update one grid point at position \\mathbf{x}, \\mathbf{y},\\mathbf{z} \\mathbf{x}, \\mathbf{y},\\mathbf{z} at time \\mathbf{t} \\mathbf{t} , i.e. \\begin{equation} \\begin{aligned} \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t+\\Delta t}) = &2\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) - \\mathbf{u}(\\mathbf{x},\\mathbf{y}, \\mathbf{z},\\mathbf{t-\\Delta t}) +\\\\ & \\frac{\\mathbf{\\Delta t}^2}{\\mathbf{m(\\mathbf{x},\\mathbf{y},\\mathbf{z})}} \\Big(\\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\mathbf{q}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) \\Big). \\end{aligned} \\end{equation} # In order to represent the wavefield u and the square slowness we need symbolic objects # corresponding to time-space-varying field (u, TimeFunction) and # space-varying field (m, Function) from devito import TimeFunction # Define the wavefield with the size of the model and the time dimension u = TimeFunction ( name = \"u\" , grid = model . grid , time_order = 2 , space_order = 2 ) # We can now write the PDE pde = model . m * u . dt2 - u . laplace + model . damp * u . dt # The PDE representation is as on paper pde \\displaystyle \\operatorname{damp}{\\left(x,y \\right)} \\frac{\\partial}{\\partial t} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial x^{2}} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial y^{2}} u{\\left(t,x,y \\right)} + \\frac{\\frac{\\partial^{2}}{\\partial t^{2}} u{\\left(t,x,y \\right)}}{\\operatorname{vp}^{2}{\\left(x,y \\right)}} \\displaystyle \\operatorname{damp}{\\left(x,y \\right)} \\frac{\\partial}{\\partial t} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial x^{2}} u{\\left(t,x,y \\right)} - \\frac{\\partial^{2}}{\\partial y^{2}} u{\\left(t,x,y \\right)} + \\frac{\\frac{\\partial^{2}}{\\partial t^{2}} u{\\left(t,x,y \\right)}}{\\operatorname{vp}^{2}{\\left(x,y \\right)}} # This discrete PDE can be solved in a time-marching way updating u(t+dt) from the previous time step # Devito as a shortcut for u(t+dt) which is u.forward. We can then rewrite the PDE as # a time marching updating equation known as a stencil using customized SymPy functions from devito import Eq , solve stencil = Eq ( u . forward , solve ( pde , u . forward ))","title":"Wave equation"},{"location":"tutorials/01_modelling/#source-injection-and-receiver-interpolation","text":"With a numerical scheme to solve the homogenous wave equation, we need to add the source to introduce seismic waves and to implement the measurement operator, and interpolation operator. This operation is linked to the discrete scheme and needs to be done at the proper time step. The semi-discretized in time wave equation with a source reads: \\begin{equation} \\begin{aligned} \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t+\\Delta t}) = &2\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) - \\mathbf{u}(\\mathbf{x},\\mathbf{y}, \\mathbf{z},\\mathbf{t-\\Delta t}) +\\\\ & \\frac{\\mathbf{\\Delta t}^2}{\\mathbf{m(\\mathbf{x},\\mathbf{y},\\mathbf{z})}} \\Big(\\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\mathbf{q}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) \\Big). \\end{aligned} \\end{equation} \\begin{equation} \\begin{aligned} \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t+\\Delta t}) = &2\\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) - \\mathbf{u}(\\mathbf{x},\\mathbf{y}, \\mathbf{z},\\mathbf{t-\\Delta t}) +\\\\ & \\frac{\\mathbf{\\Delta t}^2}{\\mathbf{m(\\mathbf{x},\\mathbf{y},\\mathbf{z})}} \\Big(\\Delta \\mathbf{u}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) + \\mathbf{q}(\\mathbf{x},\\mathbf{y},\\mathbf{z},\\mathbf{t}) \\Big). \\end{aligned} \\end{equation} It shows that in order to update \\mathbf{u} \\mathbf{u} at time \\mathbf{t+\\Delta t} \\mathbf{t+\\Delta t} we have to inject the value of the source term \\mathbf{q} \\mathbf{q} of time \\mathbf{t} \\mathbf{t} . In Devito, it corresponds the update of u u at index t+1 t+1 (t = time implicitly) with the source of time t t . On the receiver side, the problem is either as it only requires to record the data at the given time step t t for the receiver at time time=t time=t . # Finally we define the source injection and receiver read function to generate the corresponding code src_term = src . inject ( field = u . forward , expr = src * dt ** 2 / model . m ) # Create interpolation expression for receivers rec_term = rec . interpolate ( expr = u . forward )","title":"Source injection and receiver interpolation"},{"location":"tutorials/01_modelling/#devito-operator-and-solve","text":"After constructing all the necessary expressions for updating the wavefield, injecting the source term and interpolating onto the receiver points, we can now create the Devito operator that will generate the C code at runtime. When creating the operator, Devito's two optimization engines will log which performance optimizations have been performed: * DSE: The Devito Symbolics Engine will attempt to reduce the number of operations required by the kernel. * DLE: The Devito Loop Engine will perform various loop-level optimizations to improve runtime performance. Note : The argument subs=model.spacing_map causes the operator to substitute values for our current grid spacing into the expressions before code generation. This reduces the number of floating point operations executed by the kernel by pre-evaluating certain coefficients. #NBVAL_IGNORE_OUTPUT from devito import Operator op = Operator ([ stencil ] + src_term + rec_term , subs = model . spacing_map ) Now we can execute the create operator for a number of timesteps. We specify the number of timesteps to compute with the keyword time and the timestep size with dt . #NBVAL_IGNORE_OUTPUT op ( time = time_range . num - 1 , dt = model . critical_dt ) Operator `Kernel` run in 0.02 s After running our operator kernel, the data associated with the receiver symbol rec.data has now been populated due to the interpolation expression we inserted into the operator. This allows us the visualize the shot record: #NBVAL_IGNORE_OUTPUT from seismic import plot_shotrecord plot_shotrecord ( rec . data , model , t0 , tn ) assert np . isclose ( np . linalg . norm ( rec . data ), 450 , rtol = 10 )","title":"Devito operator and solve"},{"location":"tutorials/02_rtm/","text":"02 - Reverse Time Migration This notebook is the second in a series of tutorial highlighting various aspects of seismic inversion based on Devito operators. In this second example we aim to highlight the core ideas behind seismic inversion, where we create an image of the subsurface from field recorded data. This tutorial follows on the modelling tutorial and will reuse the modelling operator and velocity model. Imaging requirement Seismic imaging relies on two known parameters: Field data - or also called recorded data . This is a shot record corresponding to the true velocity model. In practice this data is acquired as described in the first tutorial. In order to simplify this tutorial we will generate synthetic field data by modelling it with the true velocity model . Background velocity model . This is a velocity model that has been obtained by processing and inverting the field data. We will look at this methods in the following tutorial as it relies on the method we are describing here. This velocity model is usually a smooth version of the true velocity model. Imaging computational setup In this tutorial, we will introduce the back-propagation operator. This operator simulates the adjoint wave-equation, that is a wave-equation solved in a reversed time order. This time reversal led to the naming of the method we present here, called Reverse Time Migration. The notion of adjoint in exploration geophysics is fundamental as most of the wave-equation based imaging and inversion methods rely on adjoint based optimization methods. Notes on the operators As we have already described the creation of a forward modelling operator, we will use a thin wrapper function instead. This wrapper is provided by a utility class called AcousticWaveSolver , which provides all the necessary operators for seismic modeling, imaging and inversion. The AcousticWaveSolver provides a more concise API for common wave propagation operators and caches the Devito Operator objects to avoid unnecessary recompilation. Operators introduced for the first time in this tutorial will be properly described. As before we initialize printing and import some utilities. We also raise the Devito log level to avoid excessive logging for repeated operator invocations. import numpy as np % matplotlib inline from devito import configuration configuration [ 'log-level' ] = 'WARNING' Computational considerations Seismic inversion algorithms are generally very computationally demanding and require a large amount of memory to store the forward wavefield. In order to keep this tutorial as lightweight as possible we are using a very simple velocity model that requires low temporal and spatial resolution. For a more realistic model, a second set of preset parameters for a reduced version of the 2D Marmousi data set [1] is provided below in comments. This can be run to create some more realistic subsurface images. However, this second preset is more computationally demanding and requires a slightly more powerful workstation. # Configure model presets from seismic import demo_model # Enable model presets here: preset = 'layers-isotropic' # A simple but cheap model (recommended) # preset = 'marmousi2d-isotropic' # A larger more realistic model # Standard preset with a simple two-layer model if preset == 'layers-isotropic' : def create_model ( grid = None ): return demo_model ( 'layers-isotropic' , origin = ( 0. , 0. ), shape = ( 101 , 101 ), spacing = ( 10. , 10. ), nbl = 20 , grid = grid , nlayers = 4 ) filter_sigma = ( 1 , 1 ) nshots = 21 nreceivers = 101 t0 = 0. tn = 1000. # Simulation last 1 second (1000 ms) f0 = 0.010 # Source peak frequency is 10Hz (0.010 kHz) # A more computationally demanding preset based on the 2D Marmousi model if preset == 'marmousi2d-isotropic' : def create_model ( grid = None ): return demo_model ( 'marmousi2d-isotropic' , data_path = '../../../../data/' , grid = grid , nbl = 20 ) filter_sigma = ( 6 , 6 ) nshots = 301 # Need good covergae in shots, one every two grid points nreceivers = 601 # One recevier every grid point t0 = 0. tn = 3500. # Simulation last 3.5 second (3500 ms) f0 = 0.025 # Source peak frequency is 25Hz (0.025 kHz) True and smooth velocity models First, we create the model data for the \"true\" model from a given demonstration preset. This model represents the subsurface topology for the purposes of this example and we will later use it to generate our synthetic data readings. We also generate a second model and apply a smoothing filter to it, which represents our initial model for the imaging algorithm. The perturbation between these two models can be thought of as the image we are trying to recover. #NBVAL_IGNORE_OUTPUT from seismic import plot_velocity , plot_perturbation from scipy import ndimage # Create true model from a preset model = create_model () # Create initial model and smooth the boundaries model0 = create_model ( grid = model . grid ) model0 . vp = ndimage . gaussian_filter ( model0 . vp . data , sigma = filter_sigma , order = 0 ) # Plot the true and initial model and the perturbation between them plot_velocity ( model ) plot_velocity ( model0 ) plot_perturbation ( model0 , model ) Acquisition geometry Next we define the positioning and the wave signal of our source, as well as the location of our receivers. To generate the wavelet for our source we require the discretized values of time that we are going to use to model a single \"shot\", which again depends on the grid spacing used in our model. For consistency this initial setup will look exactly as in the previous modelling tutorial, although we will vary the position of our source later on during the actual imaging algorithm. #NBVAL_IGNORE_OUTPUT # Define acquisition geometry: source from seismic import AcquisitionGeometry # First, position source centrally in all dimensions, then set depth src_coordinates = np . empty (( 1 , 2 )) src_coordinates [ 0 , :] = np . array ( model . domain_size ) * . 5 src_coordinates [ 0 , - 1 ] = 20. # Depth is 20m # Define acquisition geometry: receivers # Initialize receivers for synthetic and imaging data rec_coordinates = np . empty (( nreceivers , 2 )) rec_coordinates [:, 0 ] = np . linspace ( 0 , model . domain_size [ 0 ], num = nreceivers ) rec_coordinates [:, 1 ] = 30. # Geometry geometry = AcquisitionGeometry ( model , rec_coordinates , src_coordinates , t0 , tn , f0 =. 015 , src_type = 'Ricker' ) # We can plot the time signature to see the wavelet geometry . src . show () True and smooth data We can now generate the shot record (receiver readings) corresponding to our true and initial models. The difference between these two records will be the basis of the imaging procedure. For this purpose we will use the same forward modelling operator that was introduced in the previous tutorial, provided by the AcousticWaveSolver utility class. This object instantiates a set of pre-defined operators according to an initial definition of the acquisition geometry, consisting of source and receiver symbols. The solver objects caches the individual operators and provides a slightly more high-level API that allows us to invoke the modelling modelling operators from the initial tutorial in a single line. In the following cells we use this to generate shot data by only specifying the respective model symbol m to use, and the solver will create and return a new Receiver object the represents the readings at the previously defined receiver coordinates. # Compute synthetic data with forward operator from seismic.acoustic import AcousticWaveSolver solver = AcousticWaveSolver ( model , geometry , space_order = 4 ) true_d , _ , _ = solver . forward ( vp = model . vp ) # Compute initial data with forward operator smooth_d , _ , _ = solver . forward ( vp = model0 . vp ) #NBVAL_IGNORE_OUTPUT # Plot shot record for true and smooth velocity model and the difference from seismic import plot_shotrecord plot_shotrecord ( true_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data - true_d . data , model , t0 , tn ) Imaging with back-propagation As explained in the introduction of this tutorial, this method is based on back-propagation. Adjoint wave equation If we go back to the modelling part, we can rewrite the simulation as a linear system solve: \\begin{equation} \\mathbf{A}(\\mathbf{m}) \\mathbf{u} = \\mathbf{q} \\end{equation} \\begin{equation} \\mathbf{A}(\\mathbf{m}) \\mathbf{u} = \\mathbf{q} \\end{equation} where \\mathbf{m} \\mathbf{m} is the discretized square slowness, \\mathbf{q} \\mathbf{q} is the discretized source and \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) is the discretized wave-equation. The discretized wave-equation matricial representation is a lower triangular matrix that can be solve with forward substitution. The pointwise writing or the forward substitution leads to the time-stepping stencil. On a small problem one could form the matrix explicitly and transpose it to obtain the adjoint discrete wave-equation: \\begin{equation} \\mathbf{A}(\\mathbf{m})^T \\mathbf{v} = \\delta \\mathbf{d} \\end{equation} \\begin{equation} \\mathbf{A}(\\mathbf{m})^T \\mathbf{v} = \\delta \\mathbf{d} \\end{equation} where \\mathbf{v} \\mathbf{v} is the discrete adjoint wavefield and \\delta \\mathbf{d} \\delta \\mathbf{d} is the data residual defined as the difference between the field/observed data and the synthetic data \\mathbf{d}_s = \\mathbf{P}_r \\mathbf{u} \\mathbf{d}_s = \\mathbf{P}_r \\mathbf{u} . In our case we derive the discrete adjoint wave-equation from the discrete forward wave-equation to get its stencil. Imaging Wave-equation based imaging relies on one simple concept: If the background velocity model is cinematically correct, the forward wavefield \\mathbf{u} \\mathbf{u} and the adjoint wavefield \\mathbf{v} \\mathbf{v} meet at the reflectors position at zero time offset. The sum over time of the zero time-offset correlation of these two fields then creates an image of the subsurface. Mathematically this leads to the simple imaging condition: \\begin{equation} \\text{Image} = \\sum_{t=1}^{n_t} \\mathbf{u}[t] \\mathbf{v}[t] \\end{equation} \\begin{equation} \\text{Image} = \\sum_{t=1}^{n_t} \\mathbf{u}[t] \\mathbf{v}[t] \\end{equation} In the following tutorials we will describe a more advanced imaging condition that produces shaper and more accurate results. Operator We will now define the imaging operator that computes the adjoint wavefield \\mathbf{v} \\mathbf{v} and correlates it with the forward wavefield \\mathbf{u} \\mathbf{u} . This operator essentially consists of three components: * Stencil update of the adjoint wavefield v * Injection of the data residual at the adjoint source (forward receiver) location * Correlation of u and v to compute the image contribution at each timestep # Define gradient operator for imaging from devito import TimeFunction , Operator , Eq , solve from seismic import PointSource def ImagingOperator ( model , image ): # Define the wavefield with the size of the model and the time dimension v = TimeFunction ( name = 'v' , grid = model . grid , time_order = 2 , space_order = 4 ) u = TimeFunction ( name = 'u' , grid = model . grid , time_order = 2 , space_order = 4 , save = geometry . nt ) # Define the wave equation, but with a negated damping term eqn = model . m * v . dt2 - v . laplace + model . damp * v . dt . T # Use `solve` to rearrange the equation into a stencil expression stencil = Eq ( v . backward , solve ( eqn , v . backward )) # Define residual injection at the location of the forward receivers dt = model . critical_dt residual = PointSource ( name = 'residual' , grid = model . grid , time_range = geometry . time_axis , coordinates = geometry . rec_positions ) res_term = residual . inject ( field = v . backward , expr = residual * dt ** 2 / model . m ) # Correlate u and v for the current time step and add it to the image image_update = Eq ( image , image - u * v ) return Operator ([ stencil ] + res_term + [ image_update ], subs = model . spacing_map ) Implementation of the imaging loop As just explained, the forward wave-equation is solved forward in time while the adjoint wave-equation is solved in a reversed time order. Therefore, the correlation of these two fields over time requires to store one of the two fields. The computational procedure for imaging follows: Simulate the forward wave-equation with the background velocity model to get the synthetic data and save the full wavefield \\mathbf{u} \\mathbf{u} Compute the data residual Back-propagate the data residual and compute on the fly the image contribution at each time step. This procedure is applied to multiple source positions (shots) and summed to obtain the full image of the subsurface. We can first visualize the varying locations of the sources that we will use. #NBVAL_IGNORE_OUTPUT # Prepare the varying source locations source_locations = np . empty (( nshots , 2 ), dtype = np . float32 ) source_locations [:, 0 ] = np . linspace ( 0. , 1000 , num = nshots ) source_locations [:, 1 ] = 30. plot_velocity ( model , source = source_locations ) # Run imaging loop over shots from devito import Function # Create image symbol and instantiate the previously defined imaging operator image = Function ( name = 'image' , grid = model . grid ) op_imaging = ImagingOperator ( model , image ) for i in range ( nshots ): print ( 'Imaging source %d out of %d ' % ( i + 1 , nshots )) # Update source location geometry . src_positions [ 0 , :] = source_locations [ i , :] # Generate synthetic data from true model true_d , _ , _ = solver . forward ( vp = model . vp ) # Compute smooth data and full forward wavefield u0 smooth_d , u0 , _ = solver . forward ( vp = model0 . vp , save = True ) # Compute gradient from the data residual v = TimeFunction ( name = 'v' , grid = model . grid , time_order = 2 , space_order = 4 ) residual = smooth_d . data - true_d . data op_imaging ( u = u0 , v = v , vp = model0 . vp , dt = model0 . critical_dt , residual = residual ) Imaging source 1 out of 21 Imaging source 2 out of 21 Imaging source 3 out of 21 Imaging source 4 out of 21 Imaging source 5 out of 21 Imaging source 6 out of 21 Imaging source 7 out of 21 Imaging source 8 out of 21 Imaging source 9 out of 21 Imaging source 10 out of 21 Imaging source 11 out of 21 Imaging source 12 out of 21 Imaging source 13 out of 21 Imaging source 14 out of 21 Imaging source 15 out of 21 Imaging source 16 out of 21 Imaging source 17 out of 21 Imaging source 18 out of 21 Imaging source 19 out of 21 Imaging source 20 out of 21 Imaging source 21 out of 21 #NBVAL_IGNORE_OUTPUT from seismic import plot_image # Plot the inverted image plot_image ( image , diff = True , depth_scaling = True ) from devito import norm assert np . isclose ( norm ( image ), 1e7 , rtol = 1e1 ) And we have an image of the subsurface with a strong reflector at the original location. References [1] Versteeg, R.J. & Grau, G. (eds.) (1991): The Marmousi experience. Proc. EAGE workshop on Practical Aspects of Seismic Data Inversion (Copenhagen, 1990), Eur. Assoc. Explor. Geophysicists, Zeist.","title":"Acosutic RTM"},{"location":"tutorials/02_rtm/#02-reverse-time-migration","text":"This notebook is the second in a series of tutorial highlighting various aspects of seismic inversion based on Devito operators. In this second example we aim to highlight the core ideas behind seismic inversion, where we create an image of the subsurface from field recorded data. This tutorial follows on the modelling tutorial and will reuse the modelling operator and velocity model.","title":"02 - Reverse Time Migration"},{"location":"tutorials/02_rtm/#imaging-requirement","text":"Seismic imaging relies on two known parameters: Field data - or also called recorded data . This is a shot record corresponding to the true velocity model. In practice this data is acquired as described in the first tutorial. In order to simplify this tutorial we will generate synthetic field data by modelling it with the true velocity model . Background velocity model . This is a velocity model that has been obtained by processing and inverting the field data. We will look at this methods in the following tutorial as it relies on the method we are describing here. This velocity model is usually a smooth version of the true velocity model.","title":"Imaging requirement"},{"location":"tutorials/02_rtm/#imaging-computational-setup","text":"In this tutorial, we will introduce the back-propagation operator. This operator simulates the adjoint wave-equation, that is a wave-equation solved in a reversed time order. This time reversal led to the naming of the method we present here, called Reverse Time Migration. The notion of adjoint in exploration geophysics is fundamental as most of the wave-equation based imaging and inversion methods rely on adjoint based optimization methods. Notes on the operators As we have already described the creation of a forward modelling operator, we will use a thin wrapper function instead. This wrapper is provided by a utility class called AcousticWaveSolver , which provides all the necessary operators for seismic modeling, imaging and inversion. The AcousticWaveSolver provides a more concise API for common wave propagation operators and caches the Devito Operator objects to avoid unnecessary recompilation. Operators introduced for the first time in this tutorial will be properly described. As before we initialize printing and import some utilities. We also raise the Devito log level to avoid excessive logging for repeated operator invocations. import numpy as np % matplotlib inline from devito import configuration configuration [ 'log-level' ] = 'WARNING'","title":"Imaging computational setup"},{"location":"tutorials/02_rtm/#computational-considerations","text":"Seismic inversion algorithms are generally very computationally demanding and require a large amount of memory to store the forward wavefield. In order to keep this tutorial as lightweight as possible we are using a very simple velocity model that requires low temporal and spatial resolution. For a more realistic model, a second set of preset parameters for a reduced version of the 2D Marmousi data set [1] is provided below in comments. This can be run to create some more realistic subsurface images. However, this second preset is more computationally demanding and requires a slightly more powerful workstation. # Configure model presets from seismic import demo_model # Enable model presets here: preset = 'layers-isotropic' # A simple but cheap model (recommended) # preset = 'marmousi2d-isotropic' # A larger more realistic model # Standard preset with a simple two-layer model if preset == 'layers-isotropic' : def create_model ( grid = None ): return demo_model ( 'layers-isotropic' , origin = ( 0. , 0. ), shape = ( 101 , 101 ), spacing = ( 10. , 10. ), nbl = 20 , grid = grid , nlayers = 4 ) filter_sigma = ( 1 , 1 ) nshots = 21 nreceivers = 101 t0 = 0. tn = 1000. # Simulation last 1 second (1000 ms) f0 = 0.010 # Source peak frequency is 10Hz (0.010 kHz) # A more computationally demanding preset based on the 2D Marmousi model if preset == 'marmousi2d-isotropic' : def create_model ( grid = None ): return demo_model ( 'marmousi2d-isotropic' , data_path = '../../../../data/' , grid = grid , nbl = 20 ) filter_sigma = ( 6 , 6 ) nshots = 301 # Need good covergae in shots, one every two grid points nreceivers = 601 # One recevier every grid point t0 = 0. tn = 3500. # Simulation last 3.5 second (3500 ms) f0 = 0.025 # Source peak frequency is 25Hz (0.025 kHz)","title":"Computational considerations"},{"location":"tutorials/02_rtm/#true-and-smooth-velocity-models","text":"First, we create the model data for the \"true\" model from a given demonstration preset. This model represents the subsurface topology for the purposes of this example and we will later use it to generate our synthetic data readings. We also generate a second model and apply a smoothing filter to it, which represents our initial model for the imaging algorithm. The perturbation between these two models can be thought of as the image we are trying to recover. #NBVAL_IGNORE_OUTPUT from seismic import plot_velocity , plot_perturbation from scipy import ndimage # Create true model from a preset model = create_model () # Create initial model and smooth the boundaries model0 = create_model ( grid = model . grid ) model0 . vp = ndimage . gaussian_filter ( model0 . vp . data , sigma = filter_sigma , order = 0 ) # Plot the true and initial model and the perturbation between them plot_velocity ( model ) plot_velocity ( model0 ) plot_perturbation ( model0 , model )","title":"True and smooth velocity models"},{"location":"tutorials/02_rtm/#acquisition-geometry","text":"Next we define the positioning and the wave signal of our source, as well as the location of our receivers. To generate the wavelet for our source we require the discretized values of time that we are going to use to model a single \"shot\", which again depends on the grid spacing used in our model. For consistency this initial setup will look exactly as in the previous modelling tutorial, although we will vary the position of our source later on during the actual imaging algorithm. #NBVAL_IGNORE_OUTPUT # Define acquisition geometry: source from seismic import AcquisitionGeometry # First, position source centrally in all dimensions, then set depth src_coordinates = np . empty (( 1 , 2 )) src_coordinates [ 0 , :] = np . array ( model . domain_size ) * . 5 src_coordinates [ 0 , - 1 ] = 20. # Depth is 20m # Define acquisition geometry: receivers # Initialize receivers for synthetic and imaging data rec_coordinates = np . empty (( nreceivers , 2 )) rec_coordinates [:, 0 ] = np . linspace ( 0 , model . domain_size [ 0 ], num = nreceivers ) rec_coordinates [:, 1 ] = 30. # Geometry geometry = AcquisitionGeometry ( model , rec_coordinates , src_coordinates , t0 , tn , f0 =. 015 , src_type = 'Ricker' ) # We can plot the time signature to see the wavelet geometry . src . show ()","title":"Acquisition geometry"},{"location":"tutorials/02_rtm/#true-and-smooth-data","text":"We can now generate the shot record (receiver readings) corresponding to our true and initial models. The difference between these two records will be the basis of the imaging procedure. For this purpose we will use the same forward modelling operator that was introduced in the previous tutorial, provided by the AcousticWaveSolver utility class. This object instantiates a set of pre-defined operators according to an initial definition of the acquisition geometry, consisting of source and receiver symbols. The solver objects caches the individual operators and provides a slightly more high-level API that allows us to invoke the modelling modelling operators from the initial tutorial in a single line. In the following cells we use this to generate shot data by only specifying the respective model symbol m to use, and the solver will create and return a new Receiver object the represents the readings at the previously defined receiver coordinates. # Compute synthetic data with forward operator from seismic.acoustic import AcousticWaveSolver solver = AcousticWaveSolver ( model , geometry , space_order = 4 ) true_d , _ , _ = solver . forward ( vp = model . vp ) # Compute initial data with forward operator smooth_d , _ , _ = solver . forward ( vp = model0 . vp ) #NBVAL_IGNORE_OUTPUT # Plot shot record for true and smooth velocity model and the difference from seismic import plot_shotrecord plot_shotrecord ( true_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data - true_d . data , model , t0 , tn )","title":"True and smooth data"},{"location":"tutorials/02_rtm/#imaging-with-back-propagation","text":"As explained in the introduction of this tutorial, this method is based on back-propagation.","title":"Imaging with back-propagation"},{"location":"tutorials/02_rtm/#adjoint-wave-equation","text":"If we go back to the modelling part, we can rewrite the simulation as a linear system solve: \\begin{equation} \\mathbf{A}(\\mathbf{m}) \\mathbf{u} = \\mathbf{q} \\end{equation} \\begin{equation} \\mathbf{A}(\\mathbf{m}) \\mathbf{u} = \\mathbf{q} \\end{equation} where \\mathbf{m} \\mathbf{m} is the discretized square slowness, \\mathbf{q} \\mathbf{q} is the discretized source and \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) is the discretized wave-equation. The discretized wave-equation matricial representation is a lower triangular matrix that can be solve with forward substitution. The pointwise writing or the forward substitution leads to the time-stepping stencil. On a small problem one could form the matrix explicitly and transpose it to obtain the adjoint discrete wave-equation: \\begin{equation} \\mathbf{A}(\\mathbf{m})^T \\mathbf{v} = \\delta \\mathbf{d} \\end{equation} \\begin{equation} \\mathbf{A}(\\mathbf{m})^T \\mathbf{v} = \\delta \\mathbf{d} \\end{equation} where \\mathbf{v} \\mathbf{v} is the discrete adjoint wavefield and \\delta \\mathbf{d} \\delta \\mathbf{d} is the data residual defined as the difference between the field/observed data and the synthetic data \\mathbf{d}_s = \\mathbf{P}_r \\mathbf{u} \\mathbf{d}_s = \\mathbf{P}_r \\mathbf{u} . In our case we derive the discrete adjoint wave-equation from the discrete forward wave-equation to get its stencil.","title":"Adjoint wave equation"},{"location":"tutorials/02_rtm/#imaging","text":"Wave-equation based imaging relies on one simple concept: If the background velocity model is cinematically correct, the forward wavefield \\mathbf{u} \\mathbf{u} and the adjoint wavefield \\mathbf{v} \\mathbf{v} meet at the reflectors position at zero time offset. The sum over time of the zero time-offset correlation of these two fields then creates an image of the subsurface. Mathematically this leads to the simple imaging condition: \\begin{equation} \\text{Image} = \\sum_{t=1}^{n_t} \\mathbf{u}[t] \\mathbf{v}[t] \\end{equation} \\begin{equation} \\text{Image} = \\sum_{t=1}^{n_t} \\mathbf{u}[t] \\mathbf{v}[t] \\end{equation} In the following tutorials we will describe a more advanced imaging condition that produces shaper and more accurate results.","title":"Imaging"},{"location":"tutorials/02_rtm/#operator","text":"We will now define the imaging operator that computes the adjoint wavefield \\mathbf{v} \\mathbf{v} and correlates it with the forward wavefield \\mathbf{u} \\mathbf{u} . This operator essentially consists of three components: * Stencil update of the adjoint wavefield v * Injection of the data residual at the adjoint source (forward receiver) location * Correlation of u and v to compute the image contribution at each timestep # Define gradient operator for imaging from devito import TimeFunction , Operator , Eq , solve from seismic import PointSource def ImagingOperator ( model , image ): # Define the wavefield with the size of the model and the time dimension v = TimeFunction ( name = 'v' , grid = model . grid , time_order = 2 , space_order = 4 ) u = TimeFunction ( name = 'u' , grid = model . grid , time_order = 2 , space_order = 4 , save = geometry . nt ) # Define the wave equation, but with a negated damping term eqn = model . m * v . dt2 - v . laplace + model . damp * v . dt . T # Use `solve` to rearrange the equation into a stencil expression stencil = Eq ( v . backward , solve ( eqn , v . backward )) # Define residual injection at the location of the forward receivers dt = model . critical_dt residual = PointSource ( name = 'residual' , grid = model . grid , time_range = geometry . time_axis , coordinates = geometry . rec_positions ) res_term = residual . inject ( field = v . backward , expr = residual * dt ** 2 / model . m ) # Correlate u and v for the current time step and add it to the image image_update = Eq ( image , image - u * v ) return Operator ([ stencil ] + res_term + [ image_update ], subs = model . spacing_map )","title":"Operator"},{"location":"tutorials/02_rtm/#implementation-of-the-imaging-loop","text":"As just explained, the forward wave-equation is solved forward in time while the adjoint wave-equation is solved in a reversed time order. Therefore, the correlation of these two fields over time requires to store one of the two fields. The computational procedure for imaging follows: Simulate the forward wave-equation with the background velocity model to get the synthetic data and save the full wavefield \\mathbf{u} \\mathbf{u} Compute the data residual Back-propagate the data residual and compute on the fly the image contribution at each time step. This procedure is applied to multiple source positions (shots) and summed to obtain the full image of the subsurface. We can first visualize the varying locations of the sources that we will use. #NBVAL_IGNORE_OUTPUT # Prepare the varying source locations source_locations = np . empty (( nshots , 2 ), dtype = np . float32 ) source_locations [:, 0 ] = np . linspace ( 0. , 1000 , num = nshots ) source_locations [:, 1 ] = 30. plot_velocity ( model , source = source_locations ) # Run imaging loop over shots from devito import Function # Create image symbol and instantiate the previously defined imaging operator image = Function ( name = 'image' , grid = model . grid ) op_imaging = ImagingOperator ( model , image ) for i in range ( nshots ): print ( 'Imaging source %d out of %d ' % ( i + 1 , nshots )) # Update source location geometry . src_positions [ 0 , :] = source_locations [ i , :] # Generate synthetic data from true model true_d , _ , _ = solver . forward ( vp = model . vp ) # Compute smooth data and full forward wavefield u0 smooth_d , u0 , _ = solver . forward ( vp = model0 . vp , save = True ) # Compute gradient from the data residual v = TimeFunction ( name = 'v' , grid = model . grid , time_order = 2 , space_order = 4 ) residual = smooth_d . data - true_d . data op_imaging ( u = u0 , v = v , vp = model0 . vp , dt = model0 . critical_dt , residual = residual ) Imaging source 1 out of 21 Imaging source 2 out of 21 Imaging source 3 out of 21 Imaging source 4 out of 21 Imaging source 5 out of 21 Imaging source 6 out of 21 Imaging source 7 out of 21 Imaging source 8 out of 21 Imaging source 9 out of 21 Imaging source 10 out of 21 Imaging source 11 out of 21 Imaging source 12 out of 21 Imaging source 13 out of 21 Imaging source 14 out of 21 Imaging source 15 out of 21 Imaging source 16 out of 21 Imaging source 17 out of 21 Imaging source 18 out of 21 Imaging source 19 out of 21 Imaging source 20 out of 21 Imaging source 21 out of 21 #NBVAL_IGNORE_OUTPUT from seismic import plot_image # Plot the inverted image plot_image ( image , diff = True , depth_scaling = True ) from devito import norm assert np . isclose ( norm ( image ), 1e7 , rtol = 1e1 ) And we have an image of the subsurface with a strong reflector at the original location.","title":"Implementation of the imaging loop"},{"location":"tutorials/02_rtm/#references","text":"[1] Versteeg, R.J. & Grau, G. (eds.) (1991): The Marmousi experience. Proc. EAGE workshop on Practical Aspects of Seismic Data Inversion (Copenhagen, 1990), Eur. Assoc. Explor. Geophysicists, Zeist.","title":"References"},{"location":"tutorials/03_fwi/","text":"03 - Full-Waveform Inversion (FWI) This notebook is the third in a series of tutorial highlighting various aspects of seismic inversion based on Devito operators. In this second example we aim to highlight the core ideas behind seismic inversion, where we create an image of the subsurface from field recorded data. This tutorial follows on the modelling tutorial and will reuse the modelling and velocity model. Inversion requirement Seismic inversion relies on two known parameters: Field data - or also called recorded data . This is a shot record corresponding to the true velocity model. In practice this data is acquired as described in the first tutorial. In order to simplify this tutorial we will fake field data by modelling it with the true velocity model. Initial velocity model . This is a velocity model that has been obtained by processing the field data. This model is a rough and very smooth estimate of the velocity as an initial estimate for the inversion. This is a necessary requirement for any optimization (method). Inversion computational setup In this tutorial, we will introduce the gradient operator. This operator corresponds to the imaging condition introduced in the previous tutorial with some minor modifications that are defined by the objective function (also referred to in the tutorial series as the functional , f ) and its gradient, g . We will define these two terms in the tutorial too. Notes on the operators As we have already described the creation of a forward modelling operator, we will only call a wrapper function here. This wrapper already contains all the necessary operators for seismic modeling, imaging and inversion. Operators introduced for the first time in this tutorial will be properly described. import numpy as np % matplotlib inline from devito import configuration configuration [ 'log-level' ] = 'WARNING' Computational considerations As we will see, FWI is computationally extremely demanding, even more than RTM. To keep this tutorial as lightwight as possible we therefore again use a very small demonstration model. We also define here a few parameters for the final example runs that can be changed to modify the overall runtime of the tutorial. nshots = 9 # Number of shots to create gradient from nreceivers = 101 # Number of receiver locations per shot fwi_iterations = 5 # Number of outer FWI iterations True and smooth velocity models We will use a very simple model domain, consisting of a circle within a 2D domain. We will again use the \"true\" model to generate our synthetic shot data and use a \"smooth\" model as our initial guess. In this case the smooth model is very smooth indeed - it is simply a constant background velocity without any features. #NBVAL_IGNORE_OUTPUT from seismic import demo_model , plot_velocity , plot_perturbation # Define true and initial model shape = ( 101 , 101 ) # Number of grid point (nx, nz) spacing = ( 10. , 10. ) # Grid spacing in m. The domain size is now 1km by 1km origin = ( 0. , 0. ) # Need origin to define relative source and receiver locations model = demo_model ( 'circle-isotropic' , vp_circle = 3.0 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = 40 ) model0 = demo_model ( 'circle-isotropic' , vp_circle = 2.5 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = 40 , grid = model . grid ) plot_velocity ( model ) plot_velocity ( model0 ) plot_perturbation ( model0 , model ) Acquisition geometry In this tutorial, we will use the easiest case for inversion, namely a transmission experiment. The sources are located on one side of the model and the receivers on the other side. This allows to record most of the information necessary for inversion, as reflections usually lead to poor inversion results. #NBVAL_IGNORE_OUTPUT # Define acquisition geometry: source from seismic import AcquisitionGeometry t0 = 0. tn = 1000. f0 = 0.010 # First, position source centrally in all dimensions, then set depth src_coordinates = np . empty (( 1 , 2 )) src_coordinates [ 0 , :] = np . array ( model . domain_size ) * . 5 src_coordinates [ 0 , 0 ] = 20. # Depth is 20m # Define acquisition geometry: receivers # Initialize receivers for synthetic and imaging data rec_coordinates = np . empty (( nreceivers , 2 )) rec_coordinates [:, 1 ] = np . linspace ( 0 , model . domain_size [ 0 ], num = nreceivers ) rec_coordinates [:, 0 ] = 980. # Geometry geometry = AcquisitionGeometry ( model , rec_coordinates , src_coordinates , t0 , tn , f0 = f0 , src_type = 'Ricker' ) # We can plot the time signature to see the wavelet geometry . src . show () # Plot acquisition geometry plot_velocity ( model , source = geometry . src_positions , receiver = geometry . rec_positions [:: 4 , :]) True and smooth data We can generate shot records for the true and smoothed initial velocity models, since the difference between them will again form the basis of our imaging procedure. # Compute synthetic data with forward operator from seismic.acoustic import AcousticWaveSolver solver = AcousticWaveSolver ( model , geometry , space_order = 4 ) true_d , _ , _ = solver . forward ( vp = model . vp ) # Compute initial data with forward operator smooth_d , _ , _ = solver . forward ( vp = model0 . vp ) #NBVAL_IGNORE_OUTPUT from seismic import plot_shotrecord # Plot shot record for true and smooth velocity model and the difference plot_shotrecord ( true_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data - true_d . data , model , t0 , tn ) Full-Waveform Inversion Full-waveform inversion (FWI) aims to invert an accurate model of the discrete wave velocity, \\mathbf{c} \\mathbf{c} , or equivalently the square slowness of the wave, \\mathbf{m} = \\frac{1}{\\mathbf{c}^2} \\mathbf{m} = \\frac{1}{\\mathbf{c}^2} , from a given set of measurements of the pressure wavefield \\mathbf{u} \\mathbf{u} . This can be expressed as the following optimization problem [1, 2]: \\begin{aligned} \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\Phi_s(\\mathbf{m})&=\\frac{1}{2}\\left\\lVert\\mathbf{P}_r \\mathbf{u} - \\mathbf{d}\\right\\rVert_2^2 \\\\ \\mathbf{u} &= \\mathbf{A}(\\mathbf{m})^{-1} \\mathbf{P}_s^T \\mathbf{q}_s, \\end{aligned} \\begin{aligned} \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\Phi_s(\\mathbf{m})&=\\frac{1}{2}\\left\\lVert\\mathbf{P}_r \\mathbf{u} - \\mathbf{d}\\right\\rVert_2^2 \\\\ \\mathbf{u} &= \\mathbf{A}(\\mathbf{m})^{-1} \\mathbf{P}_s^T \\mathbf{q}_s, \\end{aligned} where \\mathbf{P}_r \\mathbf{P}_r is the sampling operator at the receiver locations, \\mathbf{P}_s^T \\mathbf{P}_s^T is the injection operator at the source locations, \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) is the operator representing the discretized wave equation matrix, \\mathbf{u} \\mathbf{u} is the discrete synthetic pressure wavefield, \\mathbf{q}_s \\mathbf{q}_s is the corresponding pressure source and \\mathbf{d} \\mathbf{d} is the measured data. It is worth noting that \\mathbf{m} \\mathbf{m} is the unknown in this formulation and that multiple implementations of the wave equation operator \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) are possible. We have already defined a concrete solver scheme for \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) in the first tutorial, including appropriate implementations of the sampling operator \\mathbf{P}_r \\mathbf{P}_r and source term \\mathbf{q}_s \\mathbf{q}_s . To solve this optimization problem using a gradient-based method, we use the adjoint-state method to evaluate the gradient \\nabla\\Phi_s(\\mathbf{m}) \\nabla\\Phi_s(\\mathbf{m}) : \\begin{align} \\nabla\\Phi_s(\\mathbf{m})=\\sum_{\\mathbf{t} =1}^{n_t}\\mathbf{u}[\\mathbf{t}] \\mathbf{v}_{tt}[\\mathbf{t}] =\\mathbf{J}^T\\delta\\mathbf{d}_s, \\end{align} \\begin{align} \\nabla\\Phi_s(\\mathbf{m})=\\sum_{\\mathbf{t} =1}^{n_t}\\mathbf{u}[\\mathbf{t}] \\mathbf{v}_{tt}[\\mathbf{t}] =\\mathbf{J}^T\\delta\\mathbf{d}_s, \\end{align} where n_t n_t is the number of computational time steps, \\delta\\mathbf{d}_s = \\left(\\mathbf{P}_r \\mathbf{u} - \\mathbf{d} \\right) \\delta\\mathbf{d}_s = \\left(\\mathbf{P}_r \\mathbf{u} - \\mathbf{d} \\right) is the data residual (difference between the measured data and the modelled data), \\mathbf{J} \\mathbf{J} is the Jacobian operator and \\mathbf{v}_{tt} \\mathbf{v}_{tt} is the second-order time derivative of the adjoint wavefield solving: \\begin{align} \\mathbf{A}^T(\\mathbf{m}) \\mathbf{v} = \\mathbf{P}_r^T \\delta\\mathbf{d}. \\end{align} \\begin{align} \\mathbf{A}^T(\\mathbf{m}) \\mathbf{v} = \\mathbf{P}_r^T \\delta\\mathbf{d}. \\end{align} We see that the gradient of the FWI function is the previously defined imaging condition with an extra second-order time derivative. We will therefore reuse the operators defined previously inside a Devito wrapper. FWI gradient operator To compute a single gradient \\nabla\\Phi_s(\\mathbf{m}) \\nabla\\Phi_s(\\mathbf{m}) in our optimization workflow we again use solver.forward to compute the entire forward wavefield \\mathbf{u} \\mathbf{u} and a similar pre-defined gradient operator to compute the adjoint wavefield v . The gradient operator provided by our solver utility also computes the correlation between the wavefields, allowing us to encode a similar procedure to the previous imaging tutorial as our gradient calculation: Simulate the forward wavefield with the background velocity model to get the synthetic data and save the full wavefield \\mathbf{u} \\mathbf{u} Compute the data residual Back-propagate the data residual and compute on the fly the gradient contribution at each time step. This procedure is applied to multiple source positions and summed to obtain a gradient image of the subsurface. We again prepare the source locations for each shot and visualize them, before defining a single gradient computation over a number of shots as a single function. #NBVAL_IGNORE_OUTPUT # Prepare the varying source locations sources source_locations = np . empty (( nshots , 2 ), dtype = np . float32 ) source_locations [:, 0 ] = 30. source_locations [:, 1 ] = np . linspace ( 0. , 1000 , num = nshots ) plot_velocity ( model , source = source_locations ) # Create FWI gradient kernel from devito import Function , TimeFunction from seismic import Receiver import scipy def fwi_gradient ( vp_in ): # Create symbols to hold the gradient and residual grad = Function ( name = \"grad\" , grid = model . grid ) residual = Receiver ( name = 'rec' , grid = model . grid , time_range = geometry . time_axis , coordinates = geometry . rec_positions ) objective = 0. for i in range ( nshots ): # Update source location geometry . src_positions [ 0 , :] = source_locations [ i , :] # Generate synthetic data from true model true_d , _ , _ = solver . forward ( vp = model . vp ) # Compute smooth data and full forward wavefield u0 smooth_d , u0 , _ = solver . forward ( vp = vp_in , save = True ) # Compute gradient from data residual and update objective function residual . data [:] = smooth_d . data [:] - true_d . data [:] objective += . 5 * np . linalg . norm ( residual . data . flatten ()) ** 2 solver . gradient ( rec = residual , u = u0 , vp = vp_in , grad = grad ) return objective , - grad . data Having defined our FWI gradient procedure we can compute the initial iteration from our starting model. This allows us to visualize the gradient alongside the model perturbation and the effect of the gradient update on the model. # Compute gradient of initial model ff , update = fwi_gradient ( model0 . vp ) assert np . isclose ( ff , 57283 , rtol = 1e0 ) #NBVAL_IGNORE_OUTPUT from seismic import plot_image # Plot the FWI gradient plot_image ( update , cmap = \"jet\" ) # Plot the difference between the true and initial model. # This is not known in practice as only the initial model is provided. plot_image ( model0 . vp . data - model . vp . data , cmap = \"jet\" ) We see that the gradient and the true perturbation have the same sign, therefore, with an appropriate scaling factor, we will update the model in the correct direction. # Define bounding box constraints on the solution. def apply_box_constraint ( vp ): # Maximum possible 'realistic' velocity is 3.5 km/sec # Minimum possible 'realistic' velocity is 2 km/sec return np . clip ( vp , 2.0 , 3.5 ) #NBVAL_SKIP # Run FWI with gradient descent history = np . zeros (( fwi_iterations , 1 )) for i in range ( 0 , fwi_iterations ): # Compute the functional value and gradient for the current # model estimate phi , direction = fwi_gradient ( model0 . vp ) # Store the history of the functional values history [ i ] = phi # Artificial Step length for gradient descent # In practice this would be replaced by a Linesearch (Wolfe, ...) # that would guarantee functional decrease Phi(m-alpha g) <= epsilon Phi(m) # where epsilon is a minimum decrease constant alpha = . 05 / np . abs ( direction ) . max () # Update the model estimate and enforce minimum/maximum values model0 . vp = apply_box_constraint ( model0 . vp . data - alpha * direction ) # Log the progress made print ( 'Objective value is %f at iteration %d ' % ( phi , i + 1 )) Objective value is 57265.621845 at iteration 1 Objective value is 35755.544324 at iteration 2 Objective value is 20997.316985 at iteration 3 Objective value is 11545.768588 at iteration 4 Objective value is 5784.804134 at iteration 5 #NBVAL_IGNORE_OUTPUT # Plot inverted velocity model plot_velocity ( model0 ) #NBVAL_SKIP import matplotlib.pyplot as plt # Plot objective function decrease plt . figure () plt . loglog ( history ) plt . xlabel ( 'Iteration number' ) plt . ylabel ( 'Misift value Phi' ) plt . title ( 'Convergence' ) plt . show () References [1] Virieux, J. and Operto, S.: An overview of full-waveform inversion in exploration geophysics, GEOPHYSICS, 74, WCC1\u2013WCC26, doi:10.1190/1.3238367, http://library.seg.org/doi/abs/10.1190/1.3238367 , 2009. [2] Haber, E., Chung, M., and Herrmann, F. J.: An effective method for parameter estimation with PDE constraints with multiple right hand sides, SIAM Journal on Optimization, 22, http://dx.doi.org/10.1137/11081126X , 2012. This notebook is part of the tutorial \"Optimised Symbolic Finite Difference Computation with Devito\" presented at the Intel\u00ae HPC Developer Conference 2017.","title":"Acoustic FWI"},{"location":"tutorials/03_fwi/#03-full-waveform-inversion-fwi","text":"This notebook is the third in a series of tutorial highlighting various aspects of seismic inversion based on Devito operators. In this second example we aim to highlight the core ideas behind seismic inversion, where we create an image of the subsurface from field recorded data. This tutorial follows on the modelling tutorial and will reuse the modelling and velocity model.","title":"03 - Full-Waveform Inversion (FWI)"},{"location":"tutorials/03_fwi/#inversion-requirement","text":"Seismic inversion relies on two known parameters: Field data - or also called recorded data . This is a shot record corresponding to the true velocity model. In practice this data is acquired as described in the first tutorial. In order to simplify this tutorial we will fake field data by modelling it with the true velocity model. Initial velocity model . This is a velocity model that has been obtained by processing the field data. This model is a rough and very smooth estimate of the velocity as an initial estimate for the inversion. This is a necessary requirement for any optimization (method).","title":"Inversion requirement"},{"location":"tutorials/03_fwi/#inversion-computational-setup","text":"In this tutorial, we will introduce the gradient operator. This operator corresponds to the imaging condition introduced in the previous tutorial with some minor modifications that are defined by the objective function (also referred to in the tutorial series as the functional , f ) and its gradient, g . We will define these two terms in the tutorial too.","title":"Inversion computational setup"},{"location":"tutorials/03_fwi/#notes-on-the-operators","text":"As we have already described the creation of a forward modelling operator, we will only call a wrapper function here. This wrapper already contains all the necessary operators for seismic modeling, imaging and inversion. Operators introduced for the first time in this tutorial will be properly described. import numpy as np % matplotlib inline from devito import configuration configuration [ 'log-level' ] = 'WARNING'","title":"Notes on the operators"},{"location":"tutorials/03_fwi/#computational-considerations","text":"As we will see, FWI is computationally extremely demanding, even more than RTM. To keep this tutorial as lightwight as possible we therefore again use a very small demonstration model. We also define here a few parameters for the final example runs that can be changed to modify the overall runtime of the tutorial. nshots = 9 # Number of shots to create gradient from nreceivers = 101 # Number of receiver locations per shot fwi_iterations = 5 # Number of outer FWI iterations","title":"Computational considerations"},{"location":"tutorials/03_fwi/#true-and-smooth-velocity-models","text":"We will use a very simple model domain, consisting of a circle within a 2D domain. We will again use the \"true\" model to generate our synthetic shot data and use a \"smooth\" model as our initial guess. In this case the smooth model is very smooth indeed - it is simply a constant background velocity without any features. #NBVAL_IGNORE_OUTPUT from seismic import demo_model , plot_velocity , plot_perturbation # Define true and initial model shape = ( 101 , 101 ) # Number of grid point (nx, nz) spacing = ( 10. , 10. ) # Grid spacing in m. The domain size is now 1km by 1km origin = ( 0. , 0. ) # Need origin to define relative source and receiver locations model = demo_model ( 'circle-isotropic' , vp_circle = 3.0 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = 40 ) model0 = demo_model ( 'circle-isotropic' , vp_circle = 2.5 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = 40 , grid = model . grid ) plot_velocity ( model ) plot_velocity ( model0 ) plot_perturbation ( model0 , model )","title":"True and smooth velocity models"},{"location":"tutorials/03_fwi/#acquisition-geometry","text":"In this tutorial, we will use the easiest case for inversion, namely a transmission experiment. The sources are located on one side of the model and the receivers on the other side. This allows to record most of the information necessary for inversion, as reflections usually lead to poor inversion results. #NBVAL_IGNORE_OUTPUT # Define acquisition geometry: source from seismic import AcquisitionGeometry t0 = 0. tn = 1000. f0 = 0.010 # First, position source centrally in all dimensions, then set depth src_coordinates = np . empty (( 1 , 2 )) src_coordinates [ 0 , :] = np . array ( model . domain_size ) * . 5 src_coordinates [ 0 , 0 ] = 20. # Depth is 20m # Define acquisition geometry: receivers # Initialize receivers for synthetic and imaging data rec_coordinates = np . empty (( nreceivers , 2 )) rec_coordinates [:, 1 ] = np . linspace ( 0 , model . domain_size [ 0 ], num = nreceivers ) rec_coordinates [:, 0 ] = 980. # Geometry geometry = AcquisitionGeometry ( model , rec_coordinates , src_coordinates , t0 , tn , f0 = f0 , src_type = 'Ricker' ) # We can plot the time signature to see the wavelet geometry . src . show () # Plot acquisition geometry plot_velocity ( model , source = geometry . src_positions , receiver = geometry . rec_positions [:: 4 , :])","title":"Acquisition geometry"},{"location":"tutorials/03_fwi/#true-and-smooth-data","text":"We can generate shot records for the true and smoothed initial velocity models, since the difference between them will again form the basis of our imaging procedure. # Compute synthetic data with forward operator from seismic.acoustic import AcousticWaveSolver solver = AcousticWaveSolver ( model , geometry , space_order = 4 ) true_d , _ , _ = solver . forward ( vp = model . vp ) # Compute initial data with forward operator smooth_d , _ , _ = solver . forward ( vp = model0 . vp ) #NBVAL_IGNORE_OUTPUT from seismic import plot_shotrecord # Plot shot record for true and smooth velocity model and the difference plot_shotrecord ( true_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data , model , t0 , tn ) plot_shotrecord ( smooth_d . data - true_d . data , model , t0 , tn )","title":"True and smooth data"},{"location":"tutorials/03_fwi/#full-waveform-inversion","text":"Full-waveform inversion (FWI) aims to invert an accurate model of the discrete wave velocity, \\mathbf{c} \\mathbf{c} , or equivalently the square slowness of the wave, \\mathbf{m} = \\frac{1}{\\mathbf{c}^2} \\mathbf{m} = \\frac{1}{\\mathbf{c}^2} , from a given set of measurements of the pressure wavefield \\mathbf{u} \\mathbf{u} . This can be expressed as the following optimization problem [1, 2]: \\begin{aligned} \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\Phi_s(\\mathbf{m})&=\\frac{1}{2}\\left\\lVert\\mathbf{P}_r \\mathbf{u} - \\mathbf{d}\\right\\rVert_2^2 \\\\ \\mathbf{u} &= \\mathbf{A}(\\mathbf{m})^{-1} \\mathbf{P}_s^T \\mathbf{q}_s, \\end{aligned} \\begin{aligned} \\mathop{\\hbox{minimize}}_{\\mathbf{m}} \\Phi_s(\\mathbf{m})&=\\frac{1}{2}\\left\\lVert\\mathbf{P}_r \\mathbf{u} - \\mathbf{d}\\right\\rVert_2^2 \\\\ \\mathbf{u} &= \\mathbf{A}(\\mathbf{m})^{-1} \\mathbf{P}_s^T \\mathbf{q}_s, \\end{aligned} where \\mathbf{P}_r \\mathbf{P}_r is the sampling operator at the receiver locations, \\mathbf{P}_s^T \\mathbf{P}_s^T is the injection operator at the source locations, \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) is the operator representing the discretized wave equation matrix, \\mathbf{u} \\mathbf{u} is the discrete synthetic pressure wavefield, \\mathbf{q}_s \\mathbf{q}_s is the corresponding pressure source and \\mathbf{d} \\mathbf{d} is the measured data. It is worth noting that \\mathbf{m} \\mathbf{m} is the unknown in this formulation and that multiple implementations of the wave equation operator \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) are possible. We have already defined a concrete solver scheme for \\mathbf{A}(\\mathbf{m}) \\mathbf{A}(\\mathbf{m}) in the first tutorial, including appropriate implementations of the sampling operator \\mathbf{P}_r \\mathbf{P}_r and source term \\mathbf{q}_s \\mathbf{q}_s . To solve this optimization problem using a gradient-based method, we use the adjoint-state method to evaluate the gradient \\nabla\\Phi_s(\\mathbf{m}) \\nabla\\Phi_s(\\mathbf{m}) : \\begin{align} \\nabla\\Phi_s(\\mathbf{m})=\\sum_{\\mathbf{t} =1}^{n_t}\\mathbf{u}[\\mathbf{t}] \\mathbf{v}_{tt}[\\mathbf{t}] =\\mathbf{J}^T\\delta\\mathbf{d}_s, \\end{align} \\begin{align} \\nabla\\Phi_s(\\mathbf{m})=\\sum_{\\mathbf{t} =1}^{n_t}\\mathbf{u}[\\mathbf{t}] \\mathbf{v}_{tt}[\\mathbf{t}] =\\mathbf{J}^T\\delta\\mathbf{d}_s, \\end{align} where n_t n_t is the number of computational time steps, \\delta\\mathbf{d}_s = \\left(\\mathbf{P}_r \\mathbf{u} - \\mathbf{d} \\right) \\delta\\mathbf{d}_s = \\left(\\mathbf{P}_r \\mathbf{u} - \\mathbf{d} \\right) is the data residual (difference between the measured data and the modelled data), \\mathbf{J} \\mathbf{J} is the Jacobian operator and \\mathbf{v}_{tt} \\mathbf{v}_{tt} is the second-order time derivative of the adjoint wavefield solving: \\begin{align} \\mathbf{A}^T(\\mathbf{m}) \\mathbf{v} = \\mathbf{P}_r^T \\delta\\mathbf{d}. \\end{align} \\begin{align} \\mathbf{A}^T(\\mathbf{m}) \\mathbf{v} = \\mathbf{P}_r^T \\delta\\mathbf{d}. \\end{align} We see that the gradient of the FWI function is the previously defined imaging condition with an extra second-order time derivative. We will therefore reuse the operators defined previously inside a Devito wrapper.","title":"Full-Waveform Inversion"},{"location":"tutorials/03_fwi/#fwi-gradient-operator","text":"To compute a single gradient \\nabla\\Phi_s(\\mathbf{m}) \\nabla\\Phi_s(\\mathbf{m}) in our optimization workflow we again use solver.forward to compute the entire forward wavefield \\mathbf{u} \\mathbf{u} and a similar pre-defined gradient operator to compute the adjoint wavefield v . The gradient operator provided by our solver utility also computes the correlation between the wavefields, allowing us to encode a similar procedure to the previous imaging tutorial as our gradient calculation: Simulate the forward wavefield with the background velocity model to get the synthetic data and save the full wavefield \\mathbf{u} \\mathbf{u} Compute the data residual Back-propagate the data residual and compute on the fly the gradient contribution at each time step. This procedure is applied to multiple source positions and summed to obtain a gradient image of the subsurface. We again prepare the source locations for each shot and visualize them, before defining a single gradient computation over a number of shots as a single function. #NBVAL_IGNORE_OUTPUT # Prepare the varying source locations sources source_locations = np . empty (( nshots , 2 ), dtype = np . float32 ) source_locations [:, 0 ] = 30. source_locations [:, 1 ] = np . linspace ( 0. , 1000 , num = nshots ) plot_velocity ( model , source = source_locations ) # Create FWI gradient kernel from devito import Function , TimeFunction from seismic import Receiver import scipy def fwi_gradient ( vp_in ): # Create symbols to hold the gradient and residual grad = Function ( name = \"grad\" , grid = model . grid ) residual = Receiver ( name = 'rec' , grid = model . grid , time_range = geometry . time_axis , coordinates = geometry . rec_positions ) objective = 0. for i in range ( nshots ): # Update source location geometry . src_positions [ 0 , :] = source_locations [ i , :] # Generate synthetic data from true model true_d , _ , _ = solver . forward ( vp = model . vp ) # Compute smooth data and full forward wavefield u0 smooth_d , u0 , _ = solver . forward ( vp = vp_in , save = True ) # Compute gradient from data residual and update objective function residual . data [:] = smooth_d . data [:] - true_d . data [:] objective += . 5 * np . linalg . norm ( residual . data . flatten ()) ** 2 solver . gradient ( rec = residual , u = u0 , vp = vp_in , grad = grad ) return objective , - grad . data Having defined our FWI gradient procedure we can compute the initial iteration from our starting model. This allows us to visualize the gradient alongside the model perturbation and the effect of the gradient update on the model. # Compute gradient of initial model ff , update = fwi_gradient ( model0 . vp ) assert np . isclose ( ff , 57283 , rtol = 1e0 ) #NBVAL_IGNORE_OUTPUT from seismic import plot_image # Plot the FWI gradient plot_image ( update , cmap = \"jet\" ) # Plot the difference between the true and initial model. # This is not known in practice as only the initial model is provided. plot_image ( model0 . vp . data - model . vp . data , cmap = \"jet\" ) We see that the gradient and the true perturbation have the same sign, therefore, with an appropriate scaling factor, we will update the model in the correct direction. # Define bounding box constraints on the solution. def apply_box_constraint ( vp ): # Maximum possible 'realistic' velocity is 3.5 km/sec # Minimum possible 'realistic' velocity is 2 km/sec return np . clip ( vp , 2.0 , 3.5 ) #NBVAL_SKIP # Run FWI with gradient descent history = np . zeros (( fwi_iterations , 1 )) for i in range ( 0 , fwi_iterations ): # Compute the functional value and gradient for the current # model estimate phi , direction = fwi_gradient ( model0 . vp ) # Store the history of the functional values history [ i ] = phi # Artificial Step length for gradient descent # In practice this would be replaced by a Linesearch (Wolfe, ...) # that would guarantee functional decrease Phi(m-alpha g) <= epsilon Phi(m) # where epsilon is a minimum decrease constant alpha = . 05 / np . abs ( direction ) . max () # Update the model estimate and enforce minimum/maximum values model0 . vp = apply_box_constraint ( model0 . vp . data - alpha * direction ) # Log the progress made print ( 'Objective value is %f at iteration %d ' % ( phi , i + 1 )) Objective value is 57265.621845 at iteration 1 Objective value is 35755.544324 at iteration 2 Objective value is 20997.316985 at iteration 3 Objective value is 11545.768588 at iteration 4 Objective value is 5784.804134 at iteration 5 #NBVAL_IGNORE_OUTPUT # Plot inverted velocity model plot_velocity ( model0 ) #NBVAL_SKIP import matplotlib.pyplot as plt # Plot objective function decrease plt . figure () plt . loglog ( history ) plt . xlabel ( 'Iteration number' ) plt . ylabel ( 'Misift value Phi' ) plt . title ( 'Convergence' ) plt . show ()","title":"FWI gradient operator"},{"location":"tutorials/03_fwi/#references","text":"[1] Virieux, J. and Operto, S.: An overview of full-waveform inversion in exploration geophysics, GEOPHYSICS, 74, WCC1\u2013WCC26, doi:10.1190/1.3238367, http://library.seg.org/doi/abs/10.1190/1.3238367 , 2009. [2] Haber, E., Chung, M., and Herrmann, F. J.: An effective method for parameter estimation with PDE constraints with multiple right hand sides, SIAM Journal on Optimization, 22, http://dx.doi.org/10.1137/11081126X , 2012. This notebook is part of the tutorial \"Optimised Symbolic Finite Difference Computation with Devito\" presented at the Intel\u00ae HPC Developer Conference 2017.","title":"References"},{"location":"tutorials/04_dask/","text":"04 - Full Waveform Inversion with Devito and Dask Introduction In this tutorial, we will build on the previous FWI tutorial and implement parallel versions of both forward modeling and FWI objective functions. Furthermore, we will show how our parallel FWI function can be passed to black-box third party optimization libraries, such as SciPy's optimize package, to access sophisticated optimization algorithms without having to implement them from scratch! To implement parallel versions of forward modeling and FWI, we will use Dask , a Python library for distributed computing based on parallel data structures and task-based programming. As computing multiple seismic shot records or gradients for subsequent source locations is an embarassingly parallel process, we will use Dask to dynamically distribute our workload to a pool of available workers and afterwards collect the results. The first part of this tutorial closely follows tutorial 3 and consists of reading the velocity model and setting up the acquisition geometry. Subsequently, we will implement serial versions of forward modeling and FWI objective functions and then show how we can use Dask to implement parallel versions of these functions. Finally, we will show how to write a wrapper that lets us pass our objective function to scipy's optimize package and how to run a small 2D FWI example using a limited-memory Quasi-Newton method Set up velocity models As before, we start by reading the true (i.e. unknown) velocity model, as well as the starting model for FWI. For our example, we once again use the 2D Camembert model with a transmission acquisition set up, which involves having sources on one side of the model and receivers on the other side. In reality, we obvisouly cannot know what the true velocity is, but here we use the true model to generate our own data (inverse crime alert!) and to compare it to our FWI result. from examples.seismic import demo_model # Set up velocity model shape = ( 101 , 101 ) # Number of grid points (nx, nz). spacing = ( 10. , 10. ) # Grid spacing in m. The domain size is now 1km by 1km. origin = ( 0 , 0 ) # Need origin to define relative source and receiver locations. nbl = 40 # True model model1 = demo_model ( 'circle-isotropic' , vp_circle = 3.0 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = 40 ) # Initial model model0 = demo_model ( 'circle-isotropic' , vp_circle = 2.5 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = 40 , grid = model1 . grid ) Operator `initdamp` run in 0.05 s Operator `padfunc` run in 0.01 s Operator `initdamp` run in 0.01 s Operator `padfunc` run in 0.01 s Acquisition geometry For the acquisition geometry, we use the same setup as in tutorial 3 and position 5 source position on one side of the model, and an array of 101 receivers on the other side. Note that now our source coordinate array ( src_coordinates ) is a 5 x 2 array, containing the shot locations of all 5 source experiments. After defining the source/receiver coordinates, we set up individual geometry objects for both the observed data (using model ) and the predicted data (using model0 ). from examples.seismic import AcquisitionGeometry import numpy as np # Set up acquisiton geometry t0 = 0. tn = 1000. f0 = 0.010 # Set up source geometry, but define 5 sources instead of just one. nsources = 5 src_coordinates = np . empty (( nsources , 2 )) src_coordinates [:, 1 ] = np . linspace ( spacing [ 0 ], model1 . domain_size [ 0 ] - spacing [ 0 ], num = nsources ) src_coordinates [:, 0 ] = 20. # Source depth is 20m # Initialize receivers for synthetic and imaging data nreceivers = 101 rec_coordinates = np . empty (( nreceivers , 2 )) rec_coordinates [:, 1 ] = np . linspace ( spacing [ 1 ], model1 . domain_size [ 0 ] - spacing [ 1 ], num = nreceivers ) rec_coordinates [:, 0 ] = 980. # Receiver depth # Set up geometry objects for observed and predicted data geometry1 = AcquisitionGeometry ( model1 , rec_coordinates , src_coordinates , t0 , tn , f0 = f0 , src_type = 'Ricker' ) geometry0 = AcquisitionGeometry ( model0 , rec_coordinates , src_coordinates , t0 , tn , f0 = f0 , src_type = 'Ricker' ) Forward modeling Before diving into FWI, we will start with forward modeling and show how we can use Dask to implement a parallel wrapper around a serial modeling function to compute seismic shot records for multiple source locations in parallel. First, we implement a forward modeling function for a single shot, which takes a geometry data structure as the only mandatory input argument. This function assumes that the geometry structure only contains a single source location. To solve the wave equation for the current shot location and model as specified in geometry , we use the AcousticSolver from previous tutorials, which is an abstract layer built on top of (generic) Devito objects. AcousticSolver contains Devito implementations of forward and adjoint wave equations, as well as Jacobians as specified in tutorials 1 and 2, so we don't have to re-implement these PDEs here. from examples.seismic.acoustic import AcousticWaveSolver # Serial modeling function def forward_modeling_single_shot ( geometry , save = False , dt = 4.0 ): solver = AcousticWaveSolver ( geometry . model , geometry , space_order = 4 ) d_obs , u0 = solver . forward ( vp = geometry . model . vp , save = save )[ 0 : 2 ] return d_obs . resample ( dt ), u0 Parallelization with dask With our modeling function for a single shot record in place, we now implement our parallel version of our modeling function, which consists of a loop over all source locations. As the geometry object in forward_modeling_single_shot expects only a single source location, we set up a new geometry structure for the i-th source location to pass to our modeling function. However, rather than simpling calling the modeling function for single shots, we tell Dask to create a task for each source location and to distribute them to the available parallel workers. Dask returns a remote reference to the result on each worker called future . The wait statement tells our function to wait for all tasks to finish their computations, after which we collect the modeled shot records from the workers. # Parallel modeling function def forward_modeling_multi_shots ( geometry , save = False , dt = 4.0 ): futures = [] for i in range ( geometry . nsrc ): # Geometry for current shot geometry_i = AcquisitionGeometry ( geometry . model , geometry . rec_positions , geometry . src_positions [ i , :], geometry . t0 , geometry . tn , f0 = geometry . f0 , src_type = geometry . src_type ) # Call serial modeling function for each index futures . append ( client . submit ( forward_modeling_single_shot , geometry_i , save = save , dt = dt )) # Wait for all workers to finish and collect shots wait ( futures ) shots = [] for i in range ( geometry . nsrc ): shots . append ( futures [ i ] . result ()[ 0 ]) return shots We can use this parallel modeling function to generate our own observed data set, which we will subsequently use for our FWI example. In reality, we would instead read our observed data from a SEG-Y file. To compute the data in parallel, we launch a pool of workers on our local machine and then call the parallel modeling function: from distributed import Client , LocalCluster , wait # Start Dask cluster cluster = LocalCluster ( n_workers = nsources , death_timeout = 600 ) client = Client ( cluster ) # Compute observed data in parallel (inverse crime). In real life we would read the SEG-Y data here. d_obs = forward_modeling_multi_shots ( geometry1 , save = False ) The variable d_obs is a list of the 5 shots records and we can plot one of the shot records as follows: from examples.seismic import plot_shotrecord # Plot shot no. 3 of 5 plot_shotrecord ( d_obs [ 2 ] . data , model1 , t0 , tn ) Parallel Full-Waveform Inversion Now that we know how to use Dask to implement a parallel loop around a (serial) modeling function for a single shot, we can apply the same concept to an FWI objective function, which computes the FWI function value and gradient for a given geometry and observed shot record. This function follows largely the structure in tutorial 3 and involves computing the predicted data and backpropagating the residual to compute the gradient. As we do not want to update the velocity in the area of the absorbing boundaries, we only return the gradient on the (original) physical grid. from devito import Function from examples.seismic import Receiver # Serial FWI objective function def fwi_objective_single_shot ( geometry , d_obs ): # Devito objects for gradient and data residual grad = Function ( name = \"grad\" , grid = geometry . model . grid ) residual = Receiver ( name = 'rec' , grid = geometry . model . grid , time_range = geometry . time_axis , coordinates = geometry . rec_positions ) solver = AcousticWaveSolver ( geometry . model , geometry , space_order = 4 ) # Predicted data and residual d_pred , u0 = solver . forward ( vp = geometry . model . vp , save = True )[ 0 : 2 ] residual . data [:] = d_pred . data [:] - d_obs . resample ( geometry . dt ) . data [:][ 0 : d_pred . data . shape [ 0 ], :] # Function value and gradient fval = . 5 * np . linalg . norm ( residual . data . flatten ()) ** 2 solver . gradient ( rec = residual , u = u0 , vp = geometry . model . vp , grad = grad ) # Convert to numpy array and remove absorbing boundaries grad_crop = np . array ( grad . data [:])[ geometry . model . nbl : - geometry . model . nbl , geometry . model . nbl : - geometry . model . nbl ] return fval , grad_crop As for the serial modeling function, we can call fwi_objective_single_shot with a geometry structure containing a single source location and a single observed shot record. Since we are interested in evaluating this function for multiple sources in parallel, we follow the strategy from our forward modeling example and implement a parallel loop over all shots, in which we create a task for each shot location. As before, we use Dask to create one task per shot location and evaluate the single-shot FWI objective function for each source. We wait for all computations to finish via wait(futures) and then we sum the function values and gradients from all workers. # Parallel FWI objective function def fwi_objective_multi_shots ( geometry , d_obs ): futures = [] for i in range ( geometry . nsrc ): # Geometry for current shot geometry_i = AcquisitionGeometry ( geometry . model , geometry . rec_positions , geometry . src_positions [ i , :], geometry . t0 , geometry . tn , f0 = geometry . f0 , src_type = geometry . src_type ) # Call serial FWI objective function for each shot location futures . append ( client . submit ( fwi_objective_single_shot , geometry_i , d_obs [ i ])) # Wait for all workers to finish and collect function values and gradients wait ( futures ) fval = 0.0 grad = np . zeros ( geometry . model . shape ) for i in range ( geometry . nsrc ): fval += futures [ i ] . result ()[ 0 ] grad += futures [ i ] . result ()[ 1 ] return fval , grad We can compute a single gradient of the FWI objective function for all shots by passing the geometry structure with the initial model to the objective function, as well as the observed data we generated earlier. # Compute FWI gradient for 5 shots f , g = fwi_objective_multi_shots ( geometry0 , d_obs ) The physical units of the gradient are s^2/km^2 s^2/km^2 , which means our gradient is an update of the squared slowness, rather than of the velocity. from examples.seismic import plot_image # Plot g plot_image ( g . reshape ( model1 . shape ), vmin =- 6e3 , vmax = 6e3 , cmap = \"cividis\" ) FWI with SciPy's L-BFGS With our parallel FWI objective function in place, we can in principle implement a wide range of gradient-based optimization algorithms for FWI, such as (stochastic) gradient descent or the nonlinear conjugate gradient method. However, many optimization algorithms, especially second order methods or algorithms for constrained optimization, are far from trivial to implement correctly from scratch. Luckily, many optimization libraries exist that we can adapt for our purposes. Here, we demonstrate how we can interface the scipy optimize package to run FWI with a limited-memory Quasi-Newton method. The scipy optimize package was not specifically designed for FWI, but this does not matter, as the library accepts any Python function that can be evaluated for a current model iterate x and returns the function value and gradient: f, g = objective_function(x, args) where f is function value and g is a one-dimensional numpy array of type float64 . Our parallel FWI function does not take the current model as an input argument, but instead expects a geometry structure and the observed data. Therefore, we have to write a little wrapper function called loss , which provides the input argument structure that is expected by scipy.optimize . The function takes the current model iteratve x (in squared slowness) as the first input argument and overwrites the current velocity in geometry with x . The gradient that is returned to scipy.optimize is converted to a numpy array of the required type ( float64 ). # Wrapper for scipy optimizer: x is current model in squared slowness [s^2/km^2] def loss ( x , geometry , d_obs ): # Convert x to velocity v_curr = 1.0 / np . sqrt ( x . reshape ( geometry . model . shape )) # Overwrite current velocity in geometry (don't update boundary region) geometry . model . vp . data [ geometry . model . nbl : - geometry . model . nbl , geometry . model . nbl : - geometry . model . nbl ] = v_curr # Evaluate objective function fval , grad = fwi_objective_multi_shots ( geometry , d_obs ) return fval , grad . flatten () . astype ( np . float64 ) # scipy expects double precision vector The scipy.optimize function also takes an optional callback function as an input argument, which can be used to keep track of the model error as a function of the iteration number. The callback function takes the current model iterate xk as the only input argument and computes the \\ell_2 \\ell_2 -misfit with the true model m : # Callback to track model error model_error = [] def fwi_callback ( xk ): vp = model1 . vp . data [ model1 . nbl : - model1 . nbl , model1 . nbl : - model1 . nbl ] m = 1.0 / ( vp . reshape ( - 1 ) . astype ( np . float64 )) ** 2 model_error . append ( np . linalg . norm (( xk - m ) / m )) The final preparation step before we can run our example, is the definition of box constraints for the velocity. At each iteration, the optimizer will project the current model iterate onto a feasible set of velocites as defined by the lower and upper bounds vmin and vmax . Box contraints allow us to prevent velocities from taking negative values or values that are too small or large for the stability criteria of our modeling stepping scheme. We define the box constraints for the velocity in km/s km/s and then convert them to squared slownesses. Furthermore, we define our initial guess m0 : # Box contraints vmin = 1.4 # do not allow velocities slower than water vmax = 4.0 bounds = [( 1.0 / vmax ** 2 , 1.0 / vmin ** 2 ) for _ in range ( np . prod ( model0 . shape ))] # in [s^2/km^2] # Initial guess v0 = model0 . vp . data [ model0 . nbl : - model0 . nbl , model0 . nbl : - model0 . nbl ] m0 = 1.0 / ( v0 . reshape ( - 1 ) . astype ( np . float64 )) ** 2 Finally, we run our 2D FWI example by calling the optimize.minimize function. The first input argument is the function to be minimized, which is our loss function. The second input argument is the starting value, which in our case is our initial model in squared slowness. The third input argument ( args ) are the arguments that are passed to the loss function other than x . For this example we use the L-BFGS algorithm, a limited-memory Quasi-Newton algorithm which builds up an approximation of the (inverse) hessian as we iterate. As our loss function returns the analytically computed gradient (as opposed to a numerically approximated gradient), we set the argument jac=True . Furthermore, we pass our callback function, box constraints and the maximum number of iterations (in this case 5) to the optimizer. from scipy import optimize # FWI with L-BFGS ftol = 0.1 maxiter = 5 result = optimize . minimize ( loss , m0 , args = ( geometry0 , d_obs ), method = 'L-BFGS-B' , jac = True , callback = fwi_callback , bounds = bounds , options = { 'ftol' : ftol , 'maxiter' : maxiter , 'disp' : True }) # Check termination criteria assert np . isclose ( result [ 'fun' ], ftol ) or result [ 'nit' ] == maxiter After either the maximum iteration number is reached or we find the minimum of the objective function within some tolerance level ftol , the optimizer returns a dictionary with the results and some additional information. We convert the result back to the velocity in km/s km/s and compare it to the true model: # Plot FWI result vp = 1.0 / np . sqrt ( result [ 'x' ] . reshape ( model1 . shape )) plot_image ( model1 . vp . data [ model1 . nbl : - model1 . nbl , model1 . nbl : - model1 . nbl ], vmin = 2.4 , vmax = 2.8 , cmap = \"cividis\" ) plot_image ( vp , vmin = 2.4 , vmax = 2.8 , cmap = \"cividis\" ) Looking at the model error as a function of the iteration number, we find that the error decays monotonically, as we would expect. Fullimport matplotlib . pyplot as plt # Plot model error plt . plot ( range ( 1 , maxiter + 1 ), model_error ); plt . xlabel ( 'Iteration number' ); plt . ylabel ( 'L2-model error' ) plt . show () File \"<ipython-input-17-1278525b6cdd>\", line 1 Fullimport matplotlib.pyplot as plt ^ SyntaxError: invalid syntax Next steps In our current example, the master process keeps all shot records in memory and distributes the data to the workers in the parallel pool. This works perfectly fine for 2D and even small 3D examples, but quickly becomes infeasible for large-scale data sets. Therefore, an extension of our current code should include the following steps if we want to scale things up in the future: Write shot records directly to disk on each worker and return a file pointer back to the master process. Avoid sending the velocity model to the workers and read the model directly onto each worker. Include optimal checkpointing or domain-decomposition to address the memory bottleneck in the gradient computations. For scaling Devito to industry-scale problems and being able to work on data sets in the range of multiple terabytes, it is furthermore necessary to have a fast SEG-Y reader that is able to scan through large data volumes and efficiently access blocks of data such as single shot records. Furthermore, we need the SEG-Y reader to be able to interact with Devito and automatically set up geometry objects from the SEG-Y headers. For this purpose, please check out the Julia Devito Inversion framework (JUDI) , an extension built on top of Devito in the Julia programming language. JUDI consists on an abstract linear algebra framework and an interface to a fast and parallel SEG-Y reader called SEGYIO.jl , making it possible to: Scan large-scale data sets and create look-up tables from which shot records can be directly accessed through their byte locations (no need to loop over traces or read full files). Use look-up tables to automatically set up Devito objects with source and receiver coordinates. Work with out-of-core data containers that only read the data into memory when it is used for computations. You can find a full FWI example of the 3D Overthrust model using a 1.1 TB large data set on JUDI's Github page .","title":"Parallel acoustic FWI with Dask"},{"location":"tutorials/04_dask/#04-full-waveform-inversion-with-devito-and-dask","text":"","title":"04 - Full Waveform Inversion with Devito and Dask"},{"location":"tutorials/04_dask/#introduction","text":"In this tutorial, we will build on the previous FWI tutorial and implement parallel versions of both forward modeling and FWI objective functions. Furthermore, we will show how our parallel FWI function can be passed to black-box third party optimization libraries, such as SciPy's optimize package, to access sophisticated optimization algorithms without having to implement them from scratch! To implement parallel versions of forward modeling and FWI, we will use Dask , a Python library for distributed computing based on parallel data structures and task-based programming. As computing multiple seismic shot records or gradients for subsequent source locations is an embarassingly parallel process, we will use Dask to dynamically distribute our workload to a pool of available workers and afterwards collect the results. The first part of this tutorial closely follows tutorial 3 and consists of reading the velocity model and setting up the acquisition geometry. Subsequently, we will implement serial versions of forward modeling and FWI objective functions and then show how we can use Dask to implement parallel versions of these functions. Finally, we will show how to write a wrapper that lets us pass our objective function to scipy's optimize package and how to run a small 2D FWI example using a limited-memory Quasi-Newton method","title":"Introduction"},{"location":"tutorials/04_dask/#set-up-velocity-models","text":"As before, we start by reading the true (i.e. unknown) velocity model, as well as the starting model for FWI. For our example, we once again use the 2D Camembert model with a transmission acquisition set up, which involves having sources on one side of the model and receivers on the other side. In reality, we obvisouly cannot know what the true velocity is, but here we use the true model to generate our own data (inverse crime alert!) and to compare it to our FWI result. from examples.seismic import demo_model # Set up velocity model shape = ( 101 , 101 ) # Number of grid points (nx, nz). spacing = ( 10. , 10. ) # Grid spacing in m. The domain size is now 1km by 1km. origin = ( 0 , 0 ) # Need origin to define relative source and receiver locations. nbl = 40 # True model model1 = demo_model ( 'circle-isotropic' , vp_circle = 3.0 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = 40 ) # Initial model model0 = demo_model ( 'circle-isotropic' , vp_circle = 2.5 , vp_background = 2.5 , origin = origin , shape = shape , spacing = spacing , nbl = 40 , grid = model1 . grid ) Operator `initdamp` run in 0.05 s Operator `padfunc` run in 0.01 s Operator `initdamp` run in 0.01 s Operator `padfunc` run in 0.01 s","title":"Set up velocity models"},{"location":"tutorials/04_dask/#acquisition-geometry","text":"For the acquisition geometry, we use the same setup as in tutorial 3 and position 5 source position on one side of the model, and an array of 101 receivers on the other side. Note that now our source coordinate array ( src_coordinates ) is a 5 x 2 array, containing the shot locations of all 5 source experiments. After defining the source/receiver coordinates, we set up individual geometry objects for both the observed data (using model ) and the predicted data (using model0 ). from examples.seismic import AcquisitionGeometry import numpy as np # Set up acquisiton geometry t0 = 0. tn = 1000. f0 = 0.010 # Set up source geometry, but define 5 sources instead of just one. nsources = 5 src_coordinates = np . empty (( nsources , 2 )) src_coordinates [:, 1 ] = np . linspace ( spacing [ 0 ], model1 . domain_size [ 0 ] - spacing [ 0 ], num = nsources ) src_coordinates [:, 0 ] = 20. # Source depth is 20m # Initialize receivers for synthetic and imaging data nreceivers = 101 rec_coordinates = np . empty (( nreceivers , 2 )) rec_coordinates [:, 1 ] = np . linspace ( spacing [ 1 ], model1 . domain_size [ 0 ] - spacing [ 1 ], num = nreceivers ) rec_coordinates [:, 0 ] = 980. # Receiver depth # Set up geometry objects for observed and predicted data geometry1 = AcquisitionGeometry ( model1 , rec_coordinates , src_coordinates , t0 , tn , f0 = f0 , src_type = 'Ricker' ) geometry0 = AcquisitionGeometry ( model0 , rec_coordinates , src_coordinates , t0 , tn , f0 = f0 , src_type = 'Ricker' )","title":"Acquisition geometry"},{"location":"tutorials/04_dask/#forward-modeling","text":"Before diving into FWI, we will start with forward modeling and show how we can use Dask to implement a parallel wrapper around a serial modeling function to compute seismic shot records for multiple source locations in parallel. First, we implement a forward modeling function for a single shot, which takes a geometry data structure as the only mandatory input argument. This function assumes that the geometry structure only contains a single source location. To solve the wave equation for the current shot location and model as specified in geometry , we use the AcousticSolver from previous tutorials, which is an abstract layer built on top of (generic) Devito objects. AcousticSolver contains Devito implementations of forward and adjoint wave equations, as well as Jacobians as specified in tutorials 1 and 2, so we don't have to re-implement these PDEs here. from examples.seismic.acoustic import AcousticWaveSolver # Serial modeling function def forward_modeling_single_shot ( geometry , save = False , dt = 4.0 ): solver = AcousticWaveSolver ( geometry . model , geometry , space_order = 4 ) d_obs , u0 = solver . forward ( vp = geometry . model . vp , save = save )[ 0 : 2 ] return d_obs . resample ( dt ), u0","title":"Forward modeling"},{"location":"tutorials/04_dask/#parallelization-with-dask","text":"With our modeling function for a single shot record in place, we now implement our parallel version of our modeling function, which consists of a loop over all source locations. As the geometry object in forward_modeling_single_shot expects only a single source location, we set up a new geometry structure for the i-th source location to pass to our modeling function. However, rather than simpling calling the modeling function for single shots, we tell Dask to create a task for each source location and to distribute them to the available parallel workers. Dask returns a remote reference to the result on each worker called future . The wait statement tells our function to wait for all tasks to finish their computations, after which we collect the modeled shot records from the workers. # Parallel modeling function def forward_modeling_multi_shots ( geometry , save = False , dt = 4.0 ): futures = [] for i in range ( geometry . nsrc ): # Geometry for current shot geometry_i = AcquisitionGeometry ( geometry . model , geometry . rec_positions , geometry . src_positions [ i , :], geometry . t0 , geometry . tn , f0 = geometry . f0 , src_type = geometry . src_type ) # Call serial modeling function for each index futures . append ( client . submit ( forward_modeling_single_shot , geometry_i , save = save , dt = dt )) # Wait for all workers to finish and collect shots wait ( futures ) shots = [] for i in range ( geometry . nsrc ): shots . append ( futures [ i ] . result ()[ 0 ]) return shots We can use this parallel modeling function to generate our own observed data set, which we will subsequently use for our FWI example. In reality, we would instead read our observed data from a SEG-Y file. To compute the data in parallel, we launch a pool of workers on our local machine and then call the parallel modeling function: from distributed import Client , LocalCluster , wait # Start Dask cluster cluster = LocalCluster ( n_workers = nsources , death_timeout = 600 ) client = Client ( cluster ) # Compute observed data in parallel (inverse crime). In real life we would read the SEG-Y data here. d_obs = forward_modeling_multi_shots ( geometry1 , save = False ) The variable d_obs is a list of the 5 shots records and we can plot one of the shot records as follows: from examples.seismic import plot_shotrecord # Plot shot no. 3 of 5 plot_shotrecord ( d_obs [ 2 ] . data , model1 , t0 , tn )","title":"Parallelization with dask"},{"location":"tutorials/04_dask/#parallel-full-waveform-inversion","text":"Now that we know how to use Dask to implement a parallel loop around a (serial) modeling function for a single shot, we can apply the same concept to an FWI objective function, which computes the FWI function value and gradient for a given geometry and observed shot record. This function follows largely the structure in tutorial 3 and involves computing the predicted data and backpropagating the residual to compute the gradient. As we do not want to update the velocity in the area of the absorbing boundaries, we only return the gradient on the (original) physical grid. from devito import Function from examples.seismic import Receiver # Serial FWI objective function def fwi_objective_single_shot ( geometry , d_obs ): # Devito objects for gradient and data residual grad = Function ( name = \"grad\" , grid = geometry . model . grid ) residual = Receiver ( name = 'rec' , grid = geometry . model . grid , time_range = geometry . time_axis , coordinates = geometry . rec_positions ) solver = AcousticWaveSolver ( geometry . model , geometry , space_order = 4 ) # Predicted data and residual d_pred , u0 = solver . forward ( vp = geometry . model . vp , save = True )[ 0 : 2 ] residual . data [:] = d_pred . data [:] - d_obs . resample ( geometry . dt ) . data [:][ 0 : d_pred . data . shape [ 0 ], :] # Function value and gradient fval = . 5 * np . linalg . norm ( residual . data . flatten ()) ** 2 solver . gradient ( rec = residual , u = u0 , vp = geometry . model . vp , grad = grad ) # Convert to numpy array and remove absorbing boundaries grad_crop = np . array ( grad . data [:])[ geometry . model . nbl : - geometry . model . nbl , geometry . model . nbl : - geometry . model . nbl ] return fval , grad_crop As for the serial modeling function, we can call fwi_objective_single_shot with a geometry structure containing a single source location and a single observed shot record. Since we are interested in evaluating this function for multiple sources in parallel, we follow the strategy from our forward modeling example and implement a parallel loop over all shots, in which we create a task for each shot location. As before, we use Dask to create one task per shot location and evaluate the single-shot FWI objective function for each source. We wait for all computations to finish via wait(futures) and then we sum the function values and gradients from all workers. # Parallel FWI objective function def fwi_objective_multi_shots ( geometry , d_obs ): futures = [] for i in range ( geometry . nsrc ): # Geometry for current shot geometry_i = AcquisitionGeometry ( geometry . model , geometry . rec_positions , geometry . src_positions [ i , :], geometry . t0 , geometry . tn , f0 = geometry . f0 , src_type = geometry . src_type ) # Call serial FWI objective function for each shot location futures . append ( client . submit ( fwi_objective_single_shot , geometry_i , d_obs [ i ])) # Wait for all workers to finish and collect function values and gradients wait ( futures ) fval = 0.0 grad = np . zeros ( geometry . model . shape ) for i in range ( geometry . nsrc ): fval += futures [ i ] . result ()[ 0 ] grad += futures [ i ] . result ()[ 1 ] return fval , grad We can compute a single gradient of the FWI objective function for all shots by passing the geometry structure with the initial model to the objective function, as well as the observed data we generated earlier. # Compute FWI gradient for 5 shots f , g = fwi_objective_multi_shots ( geometry0 , d_obs ) The physical units of the gradient are s^2/km^2 s^2/km^2 , which means our gradient is an update of the squared slowness, rather than of the velocity. from examples.seismic import plot_image # Plot g plot_image ( g . reshape ( model1 . shape ), vmin =- 6e3 , vmax = 6e3 , cmap = \"cividis\" )","title":"Parallel Full-Waveform Inversion"},{"location":"tutorials/04_dask/#fwi-with-scipys-l-bfgs","text":"With our parallel FWI objective function in place, we can in principle implement a wide range of gradient-based optimization algorithms for FWI, such as (stochastic) gradient descent or the nonlinear conjugate gradient method. However, many optimization algorithms, especially second order methods or algorithms for constrained optimization, are far from trivial to implement correctly from scratch. Luckily, many optimization libraries exist that we can adapt for our purposes. Here, we demonstrate how we can interface the scipy optimize package to run FWI with a limited-memory Quasi-Newton method. The scipy optimize package was not specifically designed for FWI, but this does not matter, as the library accepts any Python function that can be evaluated for a current model iterate x and returns the function value and gradient: f, g = objective_function(x, args) where f is function value and g is a one-dimensional numpy array of type float64 . Our parallel FWI function does not take the current model as an input argument, but instead expects a geometry structure and the observed data. Therefore, we have to write a little wrapper function called loss , which provides the input argument structure that is expected by scipy.optimize . The function takes the current model iteratve x (in squared slowness) as the first input argument and overwrites the current velocity in geometry with x . The gradient that is returned to scipy.optimize is converted to a numpy array of the required type ( float64 ). # Wrapper for scipy optimizer: x is current model in squared slowness [s^2/km^2] def loss ( x , geometry , d_obs ): # Convert x to velocity v_curr = 1.0 / np . sqrt ( x . reshape ( geometry . model . shape )) # Overwrite current velocity in geometry (don't update boundary region) geometry . model . vp . data [ geometry . model . nbl : - geometry . model . nbl , geometry . model . nbl : - geometry . model . nbl ] = v_curr # Evaluate objective function fval , grad = fwi_objective_multi_shots ( geometry , d_obs ) return fval , grad . flatten () . astype ( np . float64 ) # scipy expects double precision vector The scipy.optimize function also takes an optional callback function as an input argument, which can be used to keep track of the model error as a function of the iteration number. The callback function takes the current model iterate xk as the only input argument and computes the \\ell_2 \\ell_2 -misfit with the true model m : # Callback to track model error model_error = [] def fwi_callback ( xk ): vp = model1 . vp . data [ model1 . nbl : - model1 . nbl , model1 . nbl : - model1 . nbl ] m = 1.0 / ( vp . reshape ( - 1 ) . astype ( np . float64 )) ** 2 model_error . append ( np . linalg . norm (( xk - m ) / m )) The final preparation step before we can run our example, is the definition of box constraints for the velocity. At each iteration, the optimizer will project the current model iterate onto a feasible set of velocites as defined by the lower and upper bounds vmin and vmax . Box contraints allow us to prevent velocities from taking negative values or values that are too small or large for the stability criteria of our modeling stepping scheme. We define the box constraints for the velocity in km/s km/s and then convert them to squared slownesses. Furthermore, we define our initial guess m0 : # Box contraints vmin = 1.4 # do not allow velocities slower than water vmax = 4.0 bounds = [( 1.0 / vmax ** 2 , 1.0 / vmin ** 2 ) for _ in range ( np . prod ( model0 . shape ))] # in [s^2/km^2] # Initial guess v0 = model0 . vp . data [ model0 . nbl : - model0 . nbl , model0 . nbl : - model0 . nbl ] m0 = 1.0 / ( v0 . reshape ( - 1 ) . astype ( np . float64 )) ** 2 Finally, we run our 2D FWI example by calling the optimize.minimize function. The first input argument is the function to be minimized, which is our loss function. The second input argument is the starting value, which in our case is our initial model in squared slowness. The third input argument ( args ) are the arguments that are passed to the loss function other than x . For this example we use the L-BFGS algorithm, a limited-memory Quasi-Newton algorithm which builds up an approximation of the (inverse) hessian as we iterate. As our loss function returns the analytically computed gradient (as opposed to a numerically approximated gradient), we set the argument jac=True . Furthermore, we pass our callback function, box constraints and the maximum number of iterations (in this case 5) to the optimizer. from scipy import optimize # FWI with L-BFGS ftol = 0.1 maxiter = 5 result = optimize . minimize ( loss , m0 , args = ( geometry0 , d_obs ), method = 'L-BFGS-B' , jac = True , callback = fwi_callback , bounds = bounds , options = { 'ftol' : ftol , 'maxiter' : maxiter , 'disp' : True }) # Check termination criteria assert np . isclose ( result [ 'fun' ], ftol ) or result [ 'nit' ] == maxiter After either the maximum iteration number is reached or we find the minimum of the objective function within some tolerance level ftol , the optimizer returns a dictionary with the results and some additional information. We convert the result back to the velocity in km/s km/s and compare it to the true model: # Plot FWI result vp = 1.0 / np . sqrt ( result [ 'x' ] . reshape ( model1 . shape )) plot_image ( model1 . vp . data [ model1 . nbl : - model1 . nbl , model1 . nbl : - model1 . nbl ], vmin = 2.4 , vmax = 2.8 , cmap = \"cividis\" ) plot_image ( vp , vmin = 2.4 , vmax = 2.8 , cmap = \"cividis\" ) Looking at the model error as a function of the iteration number, we find that the error decays monotonically, as we would expect. Fullimport matplotlib . pyplot as plt # Plot model error plt . plot ( range ( 1 , maxiter + 1 ), model_error ); plt . xlabel ( 'Iteration number' ); plt . ylabel ( 'L2-model error' ) plt . show () File \"<ipython-input-17-1278525b6cdd>\", line 1 Fullimport matplotlib.pyplot as plt ^ SyntaxError: invalid syntax","title":"FWI with SciPy's L-BFGS"},{"location":"tutorials/04_dask/#next-steps","text":"In our current example, the master process keeps all shot records in memory and distributes the data to the workers in the parallel pool. This works perfectly fine for 2D and even small 3D examples, but quickly becomes infeasible for large-scale data sets. Therefore, an extension of our current code should include the following steps if we want to scale things up in the future: Write shot records directly to disk on each worker and return a file pointer back to the master process. Avoid sending the velocity model to the workers and read the model directly onto each worker. Include optimal checkpointing or domain-decomposition to address the memory bottleneck in the gradient computations. For scaling Devito to industry-scale problems and being able to work on data sets in the range of multiple terabytes, it is furthermore necessary to have a fast SEG-Y reader that is able to scan through large data volumes and efficiently access blocks of data such as single shot records. Furthermore, we need the SEG-Y reader to be able to interact with Devito and automatically set up geometry objects from the SEG-Y headers. For this purpose, please check out the Julia Devito Inversion framework (JUDI) , an extension built on top of Devito in the Julia programming language. JUDI consists on an abstract linear algebra framework and an interface to a fast and parallel SEG-Y reader called SEGYIO.jl , making it possible to: Scan large-scale data sets and create look-up tables from which shot records can be directly accessed through their byte locations (no need to loop over traces or read full files). Use look-up tables to automatically set up Devito objects with source and receiver coordinates. Work with out-of-core data containers that only read the data into memory when it is used for computations. You can find a full FWI example of the 3D Overthrust model using a 1.1 TB large data set on JUDI's Github page .","title":"Next steps"},{"location":"tutorials/05_staggered_acoustic/","text":"05- Acoustic modeling with the first order velocity formulation In this tutorial, we introduce the use of staggered grid to solve the first order acoustic wave equation that couples a vectorial particle velocity and a scalar Pressure. Model We start, as in the previous tutorials, by setting up a Grid . from devito import * from seismic.source import WaveletSource , TimeAxis from seismic import plot_image import numpy as np from sympy import init_printing , latex init_printing ( use_latex = 'mathjax' ) # Initial grid: 1km x 1km, with spacing 100m extent = ( 2000. , 2000. ) shape = ( 81 , 81 ) x = SpaceDimension ( name = 'x' , spacing = Constant ( name = 'h_x' , value = extent [ 0 ] / ( shape [ 0 ] - 1 ))) z = SpaceDimension ( name = 'z' , spacing = Constant ( name = 'h_z' , value = extent [ 1 ] / ( shape [ 1 ] - 1 ))) grid = Grid ( extent = extent , shape = shape , dimensions = ( x , z )) First order acoustic wave equation The first order acoustic wave equation is defined as: \\begin{cases} & \\frac{d p(t, x, y)}{dt} = \\lambda \\nabla . v(t, x, y) \\\\ & \\frac{d v(t, x, y)}{dt} = \\frac{1}{\\rho} p(t, x, y) \\end{cases} \\begin{cases} & \\frac{d p(t, x, y)}{dt} = \\lambda \\nabla . v(t, x, y) \\\\ & \\frac{d v(t, x, y)}{dt} = \\frac{1}{\\rho} p(t, x, y) \\end{cases} where $ p(t, x)$ is the pressure, v(t, x, y) = (v_x(t, x, y), v_y(t, x, y) v(t, x, y) = (v_x(t, x, y), v_y(t, x, y) is the vector valued particle velocity and \\lambda, \\rho \\lambda, \\rho are the first Lame parameter ( \\lambda = \\rho * v_p^2 \\lambda = \\rho * v_p^2 with v_p v_p the sound velocity) and the density. class DGaussSource ( WaveletSource ): def wavelet ( self , f0 , t ): a = 0.004 return - 2. * a * ( t - 1. / f0 ) * np . exp ( - a * ( t - 1. / f0 ) ** 2 ) # Timestep size from Eq. 7 with V_p=6000. and dx=100 t0 , tn = 0. , 200. dt = 1e2 * ( 1. / np . sqrt ( 2. )) / 60. time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) src = DGaussSource ( name = 'src' , grid = grid , f0 = 0.01 , time_range = time_range ) src . coordinates . data [:] = [ 1000. , 1000. ] #NBVAL_SKIP src . show () # Now we create the velocity and pressure fields p = TimeFunction ( name = 'p' , grid = grid , staggered = NODE , space_order = 2 , time_order = 1 ) v = VectorTimeFunction ( name = 'v' , grid = grid , space_order = 2 , time_order = 1 ) from devito.finite_differences.operators import div , grad t = grid . stepping_dim time = grid . time_dim # We need some initial conditions V_p = 4.0 density = 1. ro = 1 / density * dt l2m = V_p * V_p * density * dt # The source injection term src_p = src . inject ( field = p . forward , expr = src ) # 2nd order acoustic according to fdelmoc u_v_2 = Eq ( v . forward , v + ro * grad ( p )) u_p_2 = Eq ( p . forward , p + l2m * div ( v . forward )) u_v_2 \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)}\\\\\\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},z \\right)} + 1.17851130197758 \\frac{\\partial}{\\partial x} p{\\left(t,x,z \\right)}\\\\\\operatorname{v_{z}}{\\left(t,x,z + \\frac{h_{z}}{2} \\right)} + 1.17851130197758 \\frac{\\partial}{\\partial z} p{\\left(t,x,z \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)}\\\\\\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},z \\right)} + 1.17851130197758 \\frac{\\partial}{\\partial x} p{\\left(t,x,z \\right)}\\\\\\operatorname{v_{z}}{\\left(t,x,z + \\frac{h_{z}}{2} \\right)} + 1.17851130197758 \\frac{\\partial}{\\partial z} p{\\left(t,x,z \\right)}\\end{matrix}\\right] u_p_2 \\displaystyle p{\\left(t + dt,x,z \\right)} = p{\\left(t,x,z \\right)} + 18.8561808316413 \\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)} + 18.8561808316413 \\frac{\\partial}{\\partial z} \\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)} \\displaystyle p{\\left(t + dt,x,z \\right)} = p{\\left(t,x,z \\right)} + 18.8561808316413 \\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)} + 18.8561808316413 \\frac{\\partial}{\\partial z} \\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)} op_2 = Operator ([ u_v_2 , u_p_2 ] + src_p ) #NBVAL_IGNORE_OUTPUT # Propagate the source op_2 ( time = src . time_range . num - 1 ) Operator `Kernel` run in 0.07 s #NBVAL_SKIP # Let's see what we got.... plot_image ( v [ 0 ] . data [ 0 ]) plot_image ( v [ 1 ] . data [ 0 ]) plot_image ( p . data [ 0 ]) norm_p = norm ( p ) assert np . isclose ( norm_p , . 35098 , atol = 1e-4 , rtol = 0 ) High order FD Similarly to the acoustic and scalar case, Devito handles any spatial discretization order trivially with a simple change at the Function definitio. We now compute the acoustic fields with a fourth order finite-difference scheme that will be less dispersive. # # 4th order acoustic according to fdelmoc # # Now we create the velocity and pressure fields p4 = TimeFunction ( name = 'p' , grid = grid , staggered = NODE , space_order = 4 , time_order = 1 ) v4 = VectorTimeFunction ( name = 'v' , grid = grid , space_order = 4 , time_order = 1 ) u_v_4 = Eq ( v4 . forward , v4 + ro * grad ( p4 )) u_p_4 = Eq ( p4 . forward , p4 + l2m * div ( v4 . forward )) #NBVAL_IGNORE_OUTPUT op_4 = Operator ([ u_v_4 , u_p_4 ] + src_p ) # Propagate the source op_4 ( time = src . time_range . num - 1 ) Operator `Kernel` run in 0.01 s #NBVAL_SKIP # Let's see what we got.... plot_image ( v4 [ 0 ] . data [ - 1 ]) plot_image ( v4 [ 1 ] . data [ - 1 ]) plot_image ( p4 . data [ - 1 ]) norm_p = norm ( p ) assert np . isclose ( norm_p , . 35098 , atol = 1e-4 , rtol = 0 )","title":"First order acoustic modeling"},{"location":"tutorials/05_staggered_acoustic/#05-acoustic-modeling-with-the-first-order-velocity-formulation","text":"In this tutorial, we introduce the use of staggered grid to solve the first order acoustic wave equation that couples a vectorial particle velocity and a scalar Pressure.","title":"05- Acoustic modeling with the first order velocity formulation"},{"location":"tutorials/05_staggered_acoustic/#model","text":"We start, as in the previous tutorials, by setting up a Grid . from devito import * from seismic.source import WaveletSource , TimeAxis from seismic import plot_image import numpy as np from sympy import init_printing , latex init_printing ( use_latex = 'mathjax' ) # Initial grid: 1km x 1km, with spacing 100m extent = ( 2000. , 2000. ) shape = ( 81 , 81 ) x = SpaceDimension ( name = 'x' , spacing = Constant ( name = 'h_x' , value = extent [ 0 ] / ( shape [ 0 ] - 1 ))) z = SpaceDimension ( name = 'z' , spacing = Constant ( name = 'h_z' , value = extent [ 1 ] / ( shape [ 1 ] - 1 ))) grid = Grid ( extent = extent , shape = shape , dimensions = ( x , z ))","title":"Model"},{"location":"tutorials/05_staggered_acoustic/#first-order-acoustic-wave-equation","text":"The first order acoustic wave equation is defined as: \\begin{cases} & \\frac{d p(t, x, y)}{dt} = \\lambda \\nabla . v(t, x, y) \\\\ & \\frac{d v(t, x, y)}{dt} = \\frac{1}{\\rho} p(t, x, y) \\end{cases} \\begin{cases} & \\frac{d p(t, x, y)}{dt} = \\lambda \\nabla . v(t, x, y) \\\\ & \\frac{d v(t, x, y)}{dt} = \\frac{1}{\\rho} p(t, x, y) \\end{cases} where $ p(t, x)$ is the pressure, v(t, x, y) = (v_x(t, x, y), v_y(t, x, y) v(t, x, y) = (v_x(t, x, y), v_y(t, x, y) is the vector valued particle velocity and \\lambda, \\rho \\lambda, \\rho are the first Lame parameter ( \\lambda = \\rho * v_p^2 \\lambda = \\rho * v_p^2 with v_p v_p the sound velocity) and the density. class DGaussSource ( WaveletSource ): def wavelet ( self , f0 , t ): a = 0.004 return - 2. * a * ( t - 1. / f0 ) * np . exp ( - a * ( t - 1. / f0 ) ** 2 ) # Timestep size from Eq. 7 with V_p=6000. and dx=100 t0 , tn = 0. , 200. dt = 1e2 * ( 1. / np . sqrt ( 2. )) / 60. time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) src = DGaussSource ( name = 'src' , grid = grid , f0 = 0.01 , time_range = time_range ) src . coordinates . data [:] = [ 1000. , 1000. ] #NBVAL_SKIP src . show () # Now we create the velocity and pressure fields p = TimeFunction ( name = 'p' , grid = grid , staggered = NODE , space_order = 2 , time_order = 1 ) v = VectorTimeFunction ( name = 'v' , grid = grid , space_order = 2 , time_order = 1 ) from devito.finite_differences.operators import div , grad t = grid . stepping_dim time = grid . time_dim # We need some initial conditions V_p = 4.0 density = 1. ro = 1 / density * dt l2m = V_p * V_p * density * dt # The source injection term src_p = src . inject ( field = p . forward , expr = src ) # 2nd order acoustic according to fdelmoc u_v_2 = Eq ( v . forward , v + ro * grad ( p )) u_p_2 = Eq ( p . forward , p + l2m * div ( v . forward )) u_v_2 \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)}\\\\\\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},z \\right)} + 1.17851130197758 \\frac{\\partial}{\\partial x} p{\\left(t,x,z \\right)}\\\\\\operatorname{v_{z}}{\\left(t,x,z + \\frac{h_{z}}{2} \\right)} + 1.17851130197758 \\frac{\\partial}{\\partial z} p{\\left(t,x,z \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)}\\\\\\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},z \\right)} + 1.17851130197758 \\frac{\\partial}{\\partial x} p{\\left(t,x,z \\right)}\\\\\\operatorname{v_{z}}{\\left(t,x,z + \\frac{h_{z}}{2} \\right)} + 1.17851130197758 \\frac{\\partial}{\\partial z} p{\\left(t,x,z \\right)}\\end{matrix}\\right] u_p_2 \\displaystyle p{\\left(t + dt,x,z \\right)} = p{\\left(t,x,z \\right)} + 18.8561808316413 \\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)} + 18.8561808316413 \\frac{\\partial}{\\partial z} \\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)} \\displaystyle p{\\left(t + dt,x,z \\right)} = p{\\left(t,x,z \\right)} + 18.8561808316413 \\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)} + 18.8561808316413 \\frac{\\partial}{\\partial z} \\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)} op_2 = Operator ([ u_v_2 , u_p_2 ] + src_p ) #NBVAL_IGNORE_OUTPUT # Propagate the source op_2 ( time = src . time_range . num - 1 ) Operator `Kernel` run in 0.07 s #NBVAL_SKIP # Let's see what we got.... plot_image ( v [ 0 ] . data [ 0 ]) plot_image ( v [ 1 ] . data [ 0 ]) plot_image ( p . data [ 0 ]) norm_p = norm ( p ) assert np . isclose ( norm_p , . 35098 , atol = 1e-4 , rtol = 0 )","title":"First order acoustic wave equation"},{"location":"tutorials/05_staggered_acoustic/#high-order-fd","text":"Similarly to the acoustic and scalar case, Devito handles any spatial discretization order trivially with a simple change at the Function definitio. We now compute the acoustic fields with a fourth order finite-difference scheme that will be less dispersive. # # 4th order acoustic according to fdelmoc # # Now we create the velocity and pressure fields p4 = TimeFunction ( name = 'p' , grid = grid , staggered = NODE , space_order = 4 , time_order = 1 ) v4 = VectorTimeFunction ( name = 'v' , grid = grid , space_order = 4 , time_order = 1 ) u_v_4 = Eq ( v4 . forward , v4 + ro * grad ( p4 )) u_p_4 = Eq ( p4 . forward , p4 + l2m * div ( v4 . forward )) #NBVAL_IGNORE_OUTPUT op_4 = Operator ([ u_v_4 , u_p_4 ] + src_p ) # Propagate the source op_4 ( time = src . time_range . num - 1 ) Operator `Kernel` run in 0.01 s #NBVAL_SKIP # Let's see what we got.... plot_image ( v4 [ 0 ] . data [ - 1 ]) plot_image ( v4 [ 1 ] . data [ - 1 ]) plot_image ( p4 . data [ - 1 ]) norm_p = norm ( p ) assert np . isclose ( norm_p , . 35098 , atol = 1e-4 , rtol = 0 )","title":"High order FD"},{"location":"tutorials/06_elastic/","text":"Elastic wave equation implementation on a staggered grid This is a first attempt at implemenenting the elastic wave equation as described in: [1] Jean Virieux (1986). \u201dP-SV wave propagation in heterogeneous media: Velocity\u2010stress finite\u2010difference method.\u201d GEOPHYSICS, 51(4), 889-901. https://doi.org/10.1190/1.1442147 The current version actually attempts to mirror the FDELMODC implementation by Jan Thorbecke: [2] https://janth.home.xs4all.nl/Software/fdelmodcManual.pdf Explosive source We will first attempt to replicate the explosive source test case described in [1], Figure 4. We start by defining the source signature g(t) g(t) , the derivative of a Gaussian pulse, given by Eq 4: g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} from devito import * from seismic.source import WaveletSource , RickerSource , GaborSource , TimeAxis from seismic import plot_image import numpy as np from sympy import init_printing , latex init_printing ( use_latex = 'mathjax' ) # Initial grid: 1km x 1km, with spacing 100m extent = ( 1500. , 1500. ) shape = ( 201 , 201 ) x = SpaceDimension ( name = 'x' , spacing = Constant ( name = 'h_x' , value = extent [ 0 ] / ( shape [ 0 ] - 1 ))) z = SpaceDimension ( name = 'z' , spacing = Constant ( name = 'h_z' , value = extent [ 1 ] / ( shape [ 1 ] - 1 ))) grid = Grid ( extent = extent , shape = shape , dimensions = ( x , z )) class DGaussSource ( WaveletSource ): def wavelet ( self , f0 , t ): a = 0.004 return - 2. * a * ( t - 1 / f0 ) * np . exp ( - a * ( t - 1 / f0 ) ** 2 ) # Timestep size from Eq. 7 with V_p=6000. and dx=100 t0 , tn = 0. , 300. dt = ( 10. / np . sqrt ( 2. )) / 6. time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) src = RickerSource ( name = 'src' , grid = grid , f0 = 0.01 , time_range = time_range ) src . coordinates . data [:] = [ 750. , 750. ] #NBVAL_SKIP src . show () # Now we create the velocity and pressure fields so = 2 v = VectorTimeFunction ( name = 'v' , grid = grid , space_order = so , time_order = 1 ) tau = TensorTimeFunction ( name = 't' , grid = grid , space_order = so , time_order = 1 ) # Now let's try and create the staggered updates t = grid . stepping_dim time = grid . time_dim # We need some initial conditions V_p = 2.0 V_s = 1.0 density = 1.8 # The source injection term src_xx = src . inject ( field = tau . forward [ 0 , 0 ], expr = src ) src_zz = src . inject ( field = tau . forward [ 1 , 1 ], expr = src ) # Thorbecke's parameter notation cp2 = V_p * V_p cs2 = V_s * V_s ro = 1 / density mu = cs2 * density l = ( cp2 * density - 2 * mu ) # fdelmodc reference implementation u_v = Eq ( v . forward , v + dt * ro * div ( tau )) u_t = Eq ( tau . forward , tau + dt * l * diag ( div ( v . forward )) + dt * mu * ( grad ( v . forward ) + grad ( v . forward ) . T )) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz ) u_v \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)}\\\\\\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)}\\\\\\operatorname{v_{z}}{\\left(t,x,z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{zz}}{\\left(t,x,z \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)}\\\\\\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)}\\\\\\operatorname{v_{z}}{\\left(t,x,z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{zz}}{\\left(t,x,z \\right)}\\end{matrix}\\right] #NBVAL_IGNORE_OUTPUT op () Operator `Kernel` run in 0.02 s #NBVAL_SKIP # Let's see what we got.... plot_image ( v [ 0 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( v [ 1 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 0 , 0 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 1 , 1 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 0 , 1 ] . data [ 0 ], cmap = \"seismic\" ) #NBVAL_IGNORE_OUTPUT assert np . isclose ( norm ( v [ 0 ]), 0.6285093 , atol = 1e-4 , rtol = 0 ) # Now that looks pretty! But let's do it again with a higher order... so = 12 v = VectorTimeFunction ( name = 'v' , grid = grid , space_order = so , time_order = 1 ) tau = TensorTimeFunction ( name = 't' , grid = grid , space_order = so , time_order = 1 ) # The source injection term src_xx = src . inject ( field = tau . forward [ 0 , 0 ], expr = src ) src_zz = src . inject ( field = tau . forward [ 1 , 1 ], expr = src ) # fdelmodc reference implementation u_v = Eq ( v . forward , v + dt * ro * div ( tau )) u_t = Eq ( tau . forward , tau + l * diag ( div ( v . forward )) + mu * ( grad ( v . forward ) + grad ( v . forward ) . T )) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz ) #NBVAL_IGNORE_OUTPUT v [ 0 ] . data . fill ( 0. ) v [ 1 ] . data . fill ( 0. ) tau [ 0 , 0 ] . data . fill ( 0. ) tau [ 0 , 1 ] . data . fill ( 0. ) tau [ 1 , 1 ] . data . fill ( 0. ) op () Operator `Kernel` run in 0.02 s #NBVAL_SKIP # Let's see what we got.... plot_image ( v [ 0 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( v [ 1 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 0 , 0 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 1 , 1 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 0 , 1 ] . data [ 0 ], cmap = \"seismic\" ) #NBVAL_IGNORE_OUTPUT assert np . isclose ( norm ( v [ 0 ]), 0.736816932 , atol = 1e-4 , rtol = 0 )","title":"Elastic modeling with constant parameters"},{"location":"tutorials/06_elastic/#elastic-wave-equation-implementation-on-a-staggered-grid","text":"This is a first attempt at implemenenting the elastic wave equation as described in: [1] Jean Virieux (1986). \u201dP-SV wave propagation in heterogeneous media: Velocity\u2010stress finite\u2010difference method.\u201d GEOPHYSICS, 51(4), 889-901. https://doi.org/10.1190/1.1442147 The current version actually attempts to mirror the FDELMODC implementation by Jan Thorbecke: [2] https://janth.home.xs4all.nl/Software/fdelmodcManual.pdf Explosive source We will first attempt to replicate the explosive source test case described in [1], Figure 4. We start by defining the source signature g(t) g(t) , the derivative of a Gaussian pulse, given by Eq 4: g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} from devito import * from seismic.source import WaveletSource , RickerSource , GaborSource , TimeAxis from seismic import plot_image import numpy as np from sympy import init_printing , latex init_printing ( use_latex = 'mathjax' ) # Initial grid: 1km x 1km, with spacing 100m extent = ( 1500. , 1500. ) shape = ( 201 , 201 ) x = SpaceDimension ( name = 'x' , spacing = Constant ( name = 'h_x' , value = extent [ 0 ] / ( shape [ 0 ] - 1 ))) z = SpaceDimension ( name = 'z' , spacing = Constant ( name = 'h_z' , value = extent [ 1 ] / ( shape [ 1 ] - 1 ))) grid = Grid ( extent = extent , shape = shape , dimensions = ( x , z )) class DGaussSource ( WaveletSource ): def wavelet ( self , f0 , t ): a = 0.004 return - 2. * a * ( t - 1 / f0 ) * np . exp ( - a * ( t - 1 / f0 ) ** 2 ) # Timestep size from Eq. 7 with V_p=6000. and dx=100 t0 , tn = 0. , 300. dt = ( 10. / np . sqrt ( 2. )) / 6. time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) src = RickerSource ( name = 'src' , grid = grid , f0 = 0.01 , time_range = time_range ) src . coordinates . data [:] = [ 750. , 750. ] #NBVAL_SKIP src . show () # Now we create the velocity and pressure fields so = 2 v = VectorTimeFunction ( name = 'v' , grid = grid , space_order = so , time_order = 1 ) tau = TensorTimeFunction ( name = 't' , grid = grid , space_order = so , time_order = 1 ) # Now let's try and create the staggered updates t = grid . stepping_dim time = grid . time_dim # We need some initial conditions V_p = 2.0 V_s = 1.0 density = 1.8 # The source injection term src_xx = src . inject ( field = tau . forward [ 0 , 0 ], expr = src ) src_zz = src . inject ( field = tau . forward [ 1 , 1 ], expr = src ) # Thorbecke's parameter notation cp2 = V_p * V_p cs2 = V_s * V_s ro = 1 / density mu = cs2 * density l = ( cp2 * density - 2 * mu ) # fdelmodc reference implementation u_v = Eq ( v . forward , v + dt * ro * div ( tau )) u_t = Eq ( tau . forward , tau + dt * l * diag ( div ( v . forward )) + dt * mu * ( grad ( v . forward ) + grad ( v . forward ) . T )) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz ) u_v \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)}\\\\\\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)}\\\\\\operatorname{v_{z}}{\\left(t,x,z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{zz}}{\\left(t,x,z \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},z \\right)}\\\\\\operatorname{v_{z}}{\\left(t + dt,x,z + \\frac{h_{z}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,z \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)}\\\\\\operatorname{v_{z}}{\\left(t,x,z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial x} \\operatorname{t_{xz}}{\\left(t,x + \\frac{h_{x}}{2},z + \\frac{h_{z}}{2} \\right)} + 0.654728501098655 \\frac{\\partial}{\\partial z} \\operatorname{t_{zz}}{\\left(t,x,z \\right)}\\end{matrix}\\right] #NBVAL_IGNORE_OUTPUT op () Operator `Kernel` run in 0.02 s #NBVAL_SKIP # Let's see what we got.... plot_image ( v [ 0 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( v [ 1 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 0 , 0 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 1 , 1 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 0 , 1 ] . data [ 0 ], cmap = \"seismic\" ) #NBVAL_IGNORE_OUTPUT assert np . isclose ( norm ( v [ 0 ]), 0.6285093 , atol = 1e-4 , rtol = 0 ) # Now that looks pretty! But let's do it again with a higher order... so = 12 v = VectorTimeFunction ( name = 'v' , grid = grid , space_order = so , time_order = 1 ) tau = TensorTimeFunction ( name = 't' , grid = grid , space_order = so , time_order = 1 ) # The source injection term src_xx = src . inject ( field = tau . forward [ 0 , 0 ], expr = src ) src_zz = src . inject ( field = tau . forward [ 1 , 1 ], expr = src ) # fdelmodc reference implementation u_v = Eq ( v . forward , v + dt * ro * div ( tau )) u_t = Eq ( tau . forward , tau + l * diag ( div ( v . forward )) + mu * ( grad ( v . forward ) + grad ( v . forward ) . T )) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz ) #NBVAL_IGNORE_OUTPUT v [ 0 ] . data . fill ( 0. ) v [ 1 ] . data . fill ( 0. ) tau [ 0 , 0 ] . data . fill ( 0. ) tau [ 0 , 1 ] . data . fill ( 0. ) tau [ 1 , 1 ] . data . fill ( 0. ) op () Operator `Kernel` run in 0.02 s #NBVAL_SKIP # Let's see what we got.... plot_image ( v [ 0 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( v [ 1 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 0 , 0 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 1 , 1 ] . data [ 0 ], cmap = \"seismic\" ) plot_image ( tau [ 0 , 1 ] . data [ 0 ], cmap = \"seismic\" ) #NBVAL_IGNORE_OUTPUT assert np . isclose ( norm ( v [ 0 ]), 0.736816932 , atol = 1e-4 , rtol = 0 )","title":"Elastic wave equation implementation on a staggered grid"},{"location":"tutorials/07_elastic_varying_parameters/","text":"Elastic wave equation implementation on a staggered grid This second elastic tutorial extends the previous constant parameter implementation to varying parameters (Lame parameters) and takes advantage of the Tensorial capabilities of Devito to write the elastic wave equation following its mathematical definition. The staggering is automated via the TensorFunction API. Explosive source We will first attempt to replicate the explosive source test case described in [1], Figure 4. We start by defining the source signature g(t) g(t) , the derivative of a Gaussian pulse, given by Eq 4: g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} from devito import * from seismic.source import RickerSource , Receiver , TimeAxis from seismic import plot_image , demo_model import numpy as np import matplotlib.pyplot as plt from sympy import init_printing , latex init_printing ( use_latex = 'mathjax' ) # Some ploting setup plt . rc ( 'font' , family = 'serif' ) plt . rc ( 'xtick' , labelsize = 20 ) plt . rc ( 'ytick' , labelsize = 20 ) #NBVAL_IGNORE_OUTPUT # Initial grid: 3km x 3km, with spacing 10m nlayers = 5 model = demo_model ( preset = 'layers-elastic' , nlayers = nlayers , shape = ( 301 , 301 ), spacing = ( 10. , 10. )) Operator `initdamp` run in 0.06 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s #NBVAL_SKIP aspect_ratio = model . shape [ 0 ] / model . shape [ 1 ] plt_options_model = { 'cmap' : 'jet' , 'extent' : [ model . origin [ 0 ], model . origin [ 0 ] + model . domain_size [ 0 ], model . origin [ 1 ] + model . domain_size [ 1 ], model . origin [ 1 ]]} fig , ax = plt . subplots ( nrows = 3 , ncols = 1 , figsize = ( 15 , 15 )) slices = [ slice ( model . nbl , - model . nbl ), slice ( model . nbl , - model . nbl )] img1 = ax [ 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 1.5 ** 2 , vmax = 4.0 ** 2 , ** plt_options_model ) fig . colorbar ( img1 , ax = ax [ 0 ]) ax [ 0 ] . set_title ( r \"First Lam\\'e parameter $\\lambda$\" , fontsize = 20 ) ax [ 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 0 ] . set_aspect ( 'auto' ) img2 = ax [ 1 ] . imshow ( np . transpose ( model . mu . data [ slices ]), vmin = 0 , vmax = 15 , ** plt_options_model ) fig . colorbar ( img2 , ax = ax [ 1 ]) ax [ 1 ] . set_title ( r \"Shear modulus $\\mu$\" , fontsize = 20 ) ax [ 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 ] . set_aspect ( 'auto' ) img3 = ax [ 2 ] . imshow ( 1 / np . transpose ( model . irho . data [ slices ]), vmin = 1.0 , vmax = 3.0 , ** plt_options_model ) fig . colorbar ( img3 , ax = ax [ 2 ]) ax [ 2 ] . set_title ( r \"Density $\\rho$\" , fontsize = 20 ) ax [ 2 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 2 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 2 ] . set_aspect ( 'auto' ) plt . tight_layout () # Timestep size from Eq. 7 with V_p=6000. and dx=100 t0 , tn = 0. , 2000. dt = model . critical_dt time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) src = RickerSource ( name = 'src' , grid = model . grid , f0 = 0.015 , time_range = time_range ) src . coordinates . data [:] = [ 1500. , 10. ] #NBVAL_SKIP src . show () Vectorial form While conventional litterature writes the elastic wave-equation as a set of scalar PDEs, the higher level representation comes from Hooke's law and the equation of motion and writes as: \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda tr(\\nabla v) \\mathbf{I} + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda tr(\\nabla v) \\mathbf{I} + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} and as tr(\\nabla v) tr(\\nabla v) is the divergence of v v we can rewrite it as \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda \\text{diag}(\\nabla . v) + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda \\text{diag}(\\nabla . v) + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} where v v is a vector valued function: v(t, x, y) = (v_x(t, x, y), v_y(t, x, y) v(t, x, y) = (v_x(t, x, y), v_y(t, x, y) and the stress \\tau \\tau is a symmetric tensor valued function: \\tau(t, x, y) = \\begin{bmatrix}\\tau_{xx}(t, x, y) & \\tau_{xy}(t, x, y)\\\\\\tau_{xy}t, x, y) & \\tau_{yy}(t, x, y)\\end{bmatrix} \\tau(t, x, y) = \\begin{bmatrix}\\tau_{xx}(t, x, y) & \\tau_{xy}(t, x, y)\\\\\\tau_{xy}t, x, y) & \\tau_{yy}(t, x, y)\\end{bmatrix} We show in the following how to setup the elastic wave-equation form Devito's high-level tensorial types. # Now we create the velocity and pressure fields so = 8 x , z = model . grid . dimensions t = model . grid . stepping_dim time = model . grid . time_dim s = time . spacing v = VectorTimeFunction ( name = 'v' , grid = model . grid , space_order = so , time_order = 1 ) tau = TensorTimeFunction ( name = 't' , grid = model . grid , space_order = so , time_order = 1 ) # The source injection term src_xx = src . inject ( field = tau . forward [ 0 , 0 ], expr = s * src ) src_zz = src . inject ( field = tau . forward [ 1 , 1 ], expr = s * src ) # The receiver nrec = 301 rec = Receiver ( name = \"rec\" , grid = model . grid , npoint = nrec , time_range = time_range ) rec . coordinates . data [:, 0 ] = np . linspace ( 0. , model . domain_size [ 0 ], num = nrec ) rec . coordinates . data [:, - 1 ] = 5. rec2 = Receiver ( name = \"rec2\" , grid = model . grid , npoint = nrec , time_range = time_range ) rec2 . coordinates . data [:, 0 ] = np . linspace ( 0. , model . domain_size [ 0 ], num = nrec ) rec2 . coordinates . data [:, - 1 ] = 3000.0 / nlayers rec3 = Receiver ( name = \"rec3\" , grid = model . grid , npoint = nrec , time_range = time_range ) rec3 . coordinates . data [:, 0 ] = np . linspace ( 0. , model . domain_size [ 0 ], num = nrec ) rec3 . coordinates . data [:, - 1 ] = 3000.0 / nlayers rec_term = rec . interpolate ( expr = tau [ 0 , 0 ] + tau [ 1 , 1 ]) rec_term += rec2 . interpolate ( expr = v [ 1 ]) rec_term += rec3 . interpolate ( expr = v [ 0 ]) #NBVAL_SKIP from seismic import plot_velocity plot_velocity ( model , source = src . coordinates . data , receiver = rec . coordinates . data [:: 10 , :]) plot_velocity ( model , source = src . coordinates . data , receiver = rec2 . coordinates . data [:: 10 , :]) Devito implementation We now implement the vectorial formulation directly with Devito using it's vectorial and matricial symbolic objects # Now let's try and create the staggered updates # Lame parameters l , mu , ro = model . lam , model . mu , model . irho # fdelmodc reference implementation u_v = Eq ( v . forward , model . damp * ( v + s * ro * div ( tau ))) u_t = Eq ( tau . forward , model . damp * ( tau + s * ( l * diag ( div ( v . forward )) + mu * ( grad ( v . forward ) + grad ( v . forward ) . T )))) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz + rec_term ) We can now see that both the particle velocities and stress equations are vectorial and tensorial equations. Devito takes care of the discretization and staggered grids automatically for these types of object. u_v \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\\\\\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{irho}{\\left(x,y \\right)} + \\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) \\operatorname{irho}{\\left(x,y \\right)} + \\operatorname{v_{y}}{\\left(t,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\\\\\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{irho}{\\left(x,y \\right)} + \\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) \\operatorname{irho}{\\left(x,y \\right)} + \\operatorname{v_{y}}{\\left(t,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] u_t \\displaystyle \\left[\\begin{matrix}\\operatorname{t_{xx}}{\\left(t + dt,x,y \\right)} & \\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\\\\\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} & \\operatorname{t_{yy}}{\\left(t + dt,x,y \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\right) + \\operatorname{t_{xx}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) + \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{t_{xx}}{\\left(t + dt,x,y \\right)} & \\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\\\\\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} & \\operatorname{t_{yy}}{\\left(t + dt,x,y \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\right) + \\operatorname{t_{xx}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) + \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] #NBVAL_IGNORE_OUTPUT # Partial ru for 1.2sec to plot the wavefield op ( dt = model . critical_dt , time_M = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.23 s #NBVAL_SKIP scale = . 5 * 1e-3 plt_options_model = { 'extent' : [ model . origin [ 0 ] , model . origin [ 0 ] + model . domain_size [ 0 ], model . origin [ 1 ] + model . domain_size [ 1 ], model . origin [ 1 ]]} fig , ax = plt . subplots ( nrows = 2 , ncols = 2 , figsize = ( 15 , 15 )) ax [ 0 , 0 ] . imshow ( np . transpose ( v [ 0 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 0 ] . set_aspect ( 'auto' ) ax [ 0 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_title ( r \"$v_ {x} $\" , fontsize = 20 ) ax [ 0 , 1 ] . imshow ( np . transpose ( v [ 1 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 1 ] . set_aspect ( 'auto' ) ax [ 0 , 1 ] . set_title ( r \"$v_ {z} $\" , fontsize = 20 ) ax [ 0 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 0 ] . imshow ( np . transpose ( tau [ 0 , 0 ] . data [ 0 ][ slices ] + tau [ 1 , 1 ] . data [ 0 ][ slices ]), vmin =- 10 * scale , vmax = 10 * scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 0 ] . set_aspect ( 'auto' ) ax [ 1 , 0 ] . set_title ( r \"$\\tau_ {xx} + \\tau_ {zz} $\" , fontsize = 20 ) ax [ 1 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 1 ] . imshow ( np . transpose ( tau [ 0 , 1 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 1 ] . set_aspect ( 'auto' ) ax [ 1 , 1 ] . set_title ( r \"$\\tau_ {xy} $\" , fontsize = 20 ) ax [ 1 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) plt . tight_layout () #NBVAL_IGNORE_OUTPUT # Full run for the data op ( dt = model . critical_dt , time_m = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.25 s # Data on a standard 2ms tim axis rec_plot = rec . resample ( num = 1001 ) rec2_plot = rec2 . resample ( num = 1001 ) rec3_plot = rec3 . resample ( num = 1001 ) scale_for_plot = np . diag ( np . linspace ( 1.0 , 2.5 , 1001 ) ** 2.0 ) #NBVAL_SKIP # Pressure (txx + tzz) data at sea surface extent = [ rec_plot . coordinates . data [ 0 , 0 ], rec_plot . coordinates . data [ - 1 , 0 ], 1e-3 * tn , t0 ] aspect = rec_plot . coordinates . data [ - 1 , 0 ] / ( 1e-3 * tn ) /. 5 plt . figure ( figsize = ( 15 , 15 )) plt . imshow ( np . dot ( scale_for_plot , rec_plot . data ), vmin =-. 01 , vmax =. 01 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) Text(0.5, 0, 'Receiver position (m)') #NBVAL_SKIP # OBC data of vx/vz plt . figure ( figsize = ( 15 , 15 )) plt . subplot ( 121 ) plt . imshow ( rec2_plot . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) plt . subplot ( 122 ) plt . imshow ( rec3_plot . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) Text(0.5, 0, 'Receiver position (m)') Second order formulation The elastic wave-equation can be formulated in a second-order in time way as well as: \\begin{cases} &\\frac{d^2v}{dt^2} = \\nabla . \\tau \\\\ & \\tau = \\lambda \\text{diag}(\\nabla . v) + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} \\begin{cases} &\\frac{d^2v}{dt^2} = \\nabla . \\tau \\\\ & \\tau = \\lambda \\text{diag}(\\nabla . v) + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} where once again v v is the vector valued particle velocity, and \\tau \\tau is now time independent. This formulation is straightforward to implement as well and only requires minor update to the declaration of the symbolic objects and PDE. # Now that looks pretty! But let's do it again with a 2nd order in time so = 8 v2 = VectorTimeFunction ( name = 'v2' , grid = model . grid , space_order = so , time_order = 2 ) tau0 = TensorFunction ( name = 't0' , grid = model . grid , space_order = so ) # The source injection term src_xx = src . inject ( field = tau0 [ 0 , 0 ], expr = src . dt ) src_zz = src . inject ( field = tau0 [ 1 , 1 ], expr = src . dt ) s = model . grid . time_dim . spacing # fdelmodc reference implementation u_v = Eq ( v2 . forward , model . damp * ( 2 * v2 - model . damp * v2 . backward + s ** 2 * ro * div ( tau0 ))) u_t = Eq ( tau0 , model . damp * ( l * diag ( div ( v2 . forward )) + mu * ( grad ( v2 . forward ) + grad ( v2 . forward ) . T ))) # rec_term = rec.interpolate(expr=tau[0, 0] + tau[1, 1]) rec_term = rec2 . interpolate ( expr = v2 [ 0 ]) rec_term += rec3 . interpolate ( expr = v2 [ 1 ]) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz + rec_term ) #NBVAL_IGNORE_OUTPUT # Partial ru for 1.2sec to plot the wavefield op ( dt = model . critical_dt , time_M = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.20 s #NBVAL_SKIP scale = 1e-4 plt_options_model = { 'extent' : [ model . origin [ 0 ] , model . origin [ 0 ] + model . domain_size [ 0 ], model . origin [ 1 ] + model . domain_size [ 1 ], model . origin [ 1 ]]} fig , ax = plt . subplots ( nrows = 2 , ncols = 2 , figsize = ( 15 , 15 )) ax [ 0 , 0 ] . imshow ( np . transpose ( v2 [ 0 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 0 ] . set_aspect ( 'auto' ) ax [ 0 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_title ( r \"$v_ {x} $\" , fontsize = 20 ) ax [ 0 , 1 ] . imshow ( np . transpose ( v2 [ 1 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 1 ] . set_aspect ( 'auto' ) ax [ 0 , 1 ] . set_title ( r \"$v_ {z} $\" , fontsize = 20 ) ax [ 0 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 0 ] . imshow ( np . transpose ( tau0 [ 0 , 0 ] . data [ slices ] + tau0 [ 1 , 1 ] . data [ slices ]), vmin =- 10 * scale , vmax = 10 * scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 0 ] . set_aspect ( 'auto' ) ax [ 1 , 0 ] . set_title ( r \"$\\tau_ {xx} + \\tau_ {zz} $\" , fontsize = 20 ) ax [ 1 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 1 ] . imshow ( np . transpose ( tau0 [ 0 , 1 ] . data [ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 1 ] . set_aspect ( 'auto' ) ax [ 1 , 1 ] . set_title ( r \"$\\tau_ {xy} $\" , fontsize = 20 ) ax [ 1 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) plt . tight_layout () #NBVAL_IGNORE_OUTPUT op ( dt = model . critical_dt , time_m = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.20 s rec2_plot2 = rec2 . resample ( num = 1001 ) rec3_plot2 = rec3 . resample ( num = 1001 ) #NBVAL_SKIP # OBC data of vx/vz plt . figure ( figsize = ( 15 , 15 )) plt . subplot ( 121 ) plt . imshow ( rec2_plot2 . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) plt . subplot ( 122 ) plt . imshow ( rec3_plot2 . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) Text(0.5, 0, 'Receiver position (m)')","title":"Elastic modeling with varying parameters"},{"location":"tutorials/07_elastic_varying_parameters/#elastic-wave-equation-implementation-on-a-staggered-grid","text":"This second elastic tutorial extends the previous constant parameter implementation to varying parameters (Lame parameters) and takes advantage of the Tensorial capabilities of Devito to write the elastic wave equation following its mathematical definition. The staggering is automated via the TensorFunction API. Explosive source We will first attempt to replicate the explosive source test case described in [1], Figure 4. We start by defining the source signature g(t) g(t) , the derivative of a Gaussian pulse, given by Eq 4: g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} g(t) = -2 \\alpha(t - t_0)e^{-\\alpha(t-t_0)^2} from devito import * from seismic.source import RickerSource , Receiver , TimeAxis from seismic import plot_image , demo_model import numpy as np import matplotlib.pyplot as plt from sympy import init_printing , latex init_printing ( use_latex = 'mathjax' ) # Some ploting setup plt . rc ( 'font' , family = 'serif' ) plt . rc ( 'xtick' , labelsize = 20 ) plt . rc ( 'ytick' , labelsize = 20 ) #NBVAL_IGNORE_OUTPUT # Initial grid: 3km x 3km, with spacing 10m nlayers = 5 model = demo_model ( preset = 'layers-elastic' , nlayers = nlayers , shape = ( 301 , 301 ), spacing = ( 10. , 10. )) Operator `initdamp` run in 0.06 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s Operator `padfunc` run in 0.01 s #NBVAL_SKIP aspect_ratio = model . shape [ 0 ] / model . shape [ 1 ] plt_options_model = { 'cmap' : 'jet' , 'extent' : [ model . origin [ 0 ], model . origin [ 0 ] + model . domain_size [ 0 ], model . origin [ 1 ] + model . domain_size [ 1 ], model . origin [ 1 ]]} fig , ax = plt . subplots ( nrows = 3 , ncols = 1 , figsize = ( 15 , 15 )) slices = [ slice ( model . nbl , - model . nbl ), slice ( model . nbl , - model . nbl )] img1 = ax [ 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 1.5 ** 2 , vmax = 4.0 ** 2 , ** plt_options_model ) fig . colorbar ( img1 , ax = ax [ 0 ]) ax [ 0 ] . set_title ( r \"First Lam\\'e parameter $\\lambda$\" , fontsize = 20 ) ax [ 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 0 ] . set_aspect ( 'auto' ) img2 = ax [ 1 ] . imshow ( np . transpose ( model . mu . data [ slices ]), vmin = 0 , vmax = 15 , ** plt_options_model ) fig . colorbar ( img2 , ax = ax [ 1 ]) ax [ 1 ] . set_title ( r \"Shear modulus $\\mu$\" , fontsize = 20 ) ax [ 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 ] . set_aspect ( 'auto' ) img3 = ax [ 2 ] . imshow ( 1 / np . transpose ( model . irho . data [ slices ]), vmin = 1.0 , vmax = 3.0 , ** plt_options_model ) fig . colorbar ( img3 , ax = ax [ 2 ]) ax [ 2 ] . set_title ( r \"Density $\\rho$\" , fontsize = 20 ) ax [ 2 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 2 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 2 ] . set_aspect ( 'auto' ) plt . tight_layout () # Timestep size from Eq. 7 with V_p=6000. and dx=100 t0 , tn = 0. , 2000. dt = model . critical_dt time_range = TimeAxis ( start = t0 , stop = tn , step = dt ) src = RickerSource ( name = 'src' , grid = model . grid , f0 = 0.015 , time_range = time_range ) src . coordinates . data [:] = [ 1500. , 10. ] #NBVAL_SKIP src . show ()","title":"Elastic wave equation implementation on a staggered grid"},{"location":"tutorials/07_elastic_varying_parameters/#vectorial-form","text":"While conventional litterature writes the elastic wave-equation as a set of scalar PDEs, the higher level representation comes from Hooke's law and the equation of motion and writes as: \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda tr(\\nabla v) \\mathbf{I} + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda tr(\\nabla v) \\mathbf{I} + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} and as tr(\\nabla v) tr(\\nabla v) is the divergence of v v we can rewrite it as \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda \\text{diag}(\\nabla . v) + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} \\begin{cases} &\\frac{dv}{dt} = \\nabla . \\tau \\\\ &\\frac{d \\tau}{dt} = \\lambda \\text{diag}(\\nabla . v) + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} where v v is a vector valued function: v(t, x, y) = (v_x(t, x, y), v_y(t, x, y) v(t, x, y) = (v_x(t, x, y), v_y(t, x, y) and the stress \\tau \\tau is a symmetric tensor valued function: \\tau(t, x, y) = \\begin{bmatrix}\\tau_{xx}(t, x, y) & \\tau_{xy}(t, x, y)\\\\\\tau_{xy}t, x, y) & \\tau_{yy}(t, x, y)\\end{bmatrix} \\tau(t, x, y) = \\begin{bmatrix}\\tau_{xx}(t, x, y) & \\tau_{xy}(t, x, y)\\\\\\tau_{xy}t, x, y) & \\tau_{yy}(t, x, y)\\end{bmatrix} We show in the following how to setup the elastic wave-equation form Devito's high-level tensorial types. # Now we create the velocity and pressure fields so = 8 x , z = model . grid . dimensions t = model . grid . stepping_dim time = model . grid . time_dim s = time . spacing v = VectorTimeFunction ( name = 'v' , grid = model . grid , space_order = so , time_order = 1 ) tau = TensorTimeFunction ( name = 't' , grid = model . grid , space_order = so , time_order = 1 ) # The source injection term src_xx = src . inject ( field = tau . forward [ 0 , 0 ], expr = s * src ) src_zz = src . inject ( field = tau . forward [ 1 , 1 ], expr = s * src ) # The receiver nrec = 301 rec = Receiver ( name = \"rec\" , grid = model . grid , npoint = nrec , time_range = time_range ) rec . coordinates . data [:, 0 ] = np . linspace ( 0. , model . domain_size [ 0 ], num = nrec ) rec . coordinates . data [:, - 1 ] = 5. rec2 = Receiver ( name = \"rec2\" , grid = model . grid , npoint = nrec , time_range = time_range ) rec2 . coordinates . data [:, 0 ] = np . linspace ( 0. , model . domain_size [ 0 ], num = nrec ) rec2 . coordinates . data [:, - 1 ] = 3000.0 / nlayers rec3 = Receiver ( name = \"rec3\" , grid = model . grid , npoint = nrec , time_range = time_range ) rec3 . coordinates . data [:, 0 ] = np . linspace ( 0. , model . domain_size [ 0 ], num = nrec ) rec3 . coordinates . data [:, - 1 ] = 3000.0 / nlayers rec_term = rec . interpolate ( expr = tau [ 0 , 0 ] + tau [ 1 , 1 ]) rec_term += rec2 . interpolate ( expr = v [ 1 ]) rec_term += rec3 . interpolate ( expr = v [ 0 ]) #NBVAL_SKIP from seismic import plot_velocity plot_velocity ( model , source = src . coordinates . data , receiver = rec . coordinates . data [:: 10 , :]) plot_velocity ( model , source = src . coordinates . data , receiver = rec2 . coordinates . data [:: 10 , :])","title":"Vectorial form"},{"location":"tutorials/07_elastic_varying_parameters/#devito-implementation","text":"We now implement the vectorial formulation directly with Devito using it's vectorial and matricial symbolic objects # Now let's try and create the staggered updates # Lame parameters l , mu , ro = model . lam , model . mu , model . irho # fdelmodc reference implementation u_v = Eq ( v . forward , model . damp * ( v + s * ro * div ( tau ))) u_t = Eq ( tau . forward , model . damp * ( tau + s * ( l * diag ( div ( v . forward )) + mu * ( grad ( v . forward ) + grad ( v . forward ) . T )))) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz + rec_term ) We can now see that both the particle velocities and stress equations are vectorial and tensorial equations. Devito takes care of the discretization and staggered grids automatically for these types of object. u_v \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\\\\\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{irho}{\\left(x,y \\right)} + \\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) \\operatorname{irho}{\\left(x,y \\right)} + \\operatorname{v_{y}}{\\left(t,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\\\\\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xx}}{\\left(t,x,y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{irho}{\\left(x,y \\right)} + \\operatorname{v_{x}}{\\left(t,x + \\frac{h_{x}}{2},y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial x} \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) \\operatorname{irho}{\\left(x,y \\right)} + \\operatorname{v_{y}}{\\left(t,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] u_t \\displaystyle \\left[\\begin{matrix}\\operatorname{t_{xx}}{\\left(t + dt,x,y \\right)} & \\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\\\\\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} & \\operatorname{t_{yy}}{\\left(t + dt,x,y \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\right) + \\operatorname{t_{xx}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) + \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] \\displaystyle \\left[\\begin{matrix}\\operatorname{t_{xx}}{\\left(t + dt,x,y \\right)} & \\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\\\\\operatorname{t_{xy}}{\\left(t + dt,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)} & \\operatorname{t_{yy}}{\\left(t + dt,x,y \\right)}\\end{matrix}\\right] = \\left[\\begin{matrix}\\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)}\\right) + \\operatorname{t_{xx}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\\\\\left(dt \\left(\\frac{\\partial}{\\partial y} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial x} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\mu{\\left(x,y \\right)} + \\operatorname{t_{xy}}{\\left(t,x + \\frac{h_{x}}{2},y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)} & \\left(dt \\left(\\left(\\frac{\\partial}{\\partial x} \\operatorname{v_{x}}{\\left(t + dt,x + \\frac{h_{x}}{2},y \\right)} + \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) \\operatorname{lam}{\\left(x,y \\right)} + 2 \\mu{\\left(x,y \\right)} \\frac{\\partial}{\\partial y} \\operatorname{v_{y}}{\\left(t + dt,x,y + \\frac{h_{y}}{2} \\right)}\\right) + \\operatorname{t_{yy}}{\\left(t,x,y \\right)}\\right) \\operatorname{damp}{\\left(x,y \\right)}\\end{matrix}\\right] #NBVAL_IGNORE_OUTPUT # Partial ru for 1.2sec to plot the wavefield op ( dt = model . critical_dt , time_M = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.23 s #NBVAL_SKIP scale = . 5 * 1e-3 plt_options_model = { 'extent' : [ model . origin [ 0 ] , model . origin [ 0 ] + model . domain_size [ 0 ], model . origin [ 1 ] + model . domain_size [ 1 ], model . origin [ 1 ]]} fig , ax = plt . subplots ( nrows = 2 , ncols = 2 , figsize = ( 15 , 15 )) ax [ 0 , 0 ] . imshow ( np . transpose ( v [ 0 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 0 ] . set_aspect ( 'auto' ) ax [ 0 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_title ( r \"$v_ {x} $\" , fontsize = 20 ) ax [ 0 , 1 ] . imshow ( np . transpose ( v [ 1 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 1 ] . set_aspect ( 'auto' ) ax [ 0 , 1 ] . set_title ( r \"$v_ {z} $\" , fontsize = 20 ) ax [ 0 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 0 ] . imshow ( np . transpose ( tau [ 0 , 0 ] . data [ 0 ][ slices ] + tau [ 1 , 1 ] . data [ 0 ][ slices ]), vmin =- 10 * scale , vmax = 10 * scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 0 ] . set_aspect ( 'auto' ) ax [ 1 , 0 ] . set_title ( r \"$\\tau_ {xx} + \\tau_ {zz} $\" , fontsize = 20 ) ax [ 1 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 1 ] . imshow ( np . transpose ( tau [ 0 , 1 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 1 ] . set_aspect ( 'auto' ) ax [ 1 , 1 ] . set_title ( r \"$\\tau_ {xy} $\" , fontsize = 20 ) ax [ 1 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) plt . tight_layout () #NBVAL_IGNORE_OUTPUT # Full run for the data op ( dt = model . critical_dt , time_m = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.25 s # Data on a standard 2ms tim axis rec_plot = rec . resample ( num = 1001 ) rec2_plot = rec2 . resample ( num = 1001 ) rec3_plot = rec3 . resample ( num = 1001 ) scale_for_plot = np . diag ( np . linspace ( 1.0 , 2.5 , 1001 ) ** 2.0 ) #NBVAL_SKIP # Pressure (txx + tzz) data at sea surface extent = [ rec_plot . coordinates . data [ 0 , 0 ], rec_plot . coordinates . data [ - 1 , 0 ], 1e-3 * tn , t0 ] aspect = rec_plot . coordinates . data [ - 1 , 0 ] / ( 1e-3 * tn ) /. 5 plt . figure ( figsize = ( 15 , 15 )) plt . imshow ( np . dot ( scale_for_plot , rec_plot . data ), vmin =-. 01 , vmax =. 01 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) Text(0.5, 0, 'Receiver position (m)') #NBVAL_SKIP # OBC data of vx/vz plt . figure ( figsize = ( 15 , 15 )) plt . subplot ( 121 ) plt . imshow ( rec2_plot . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) plt . subplot ( 122 ) plt . imshow ( rec3_plot . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) Text(0.5, 0, 'Receiver position (m)')","title":"Devito implementation"},{"location":"tutorials/07_elastic_varying_parameters/#second-order-formulation","text":"The elastic wave-equation can be formulated in a second-order in time way as well as: \\begin{cases} &\\frac{d^2v}{dt^2} = \\nabla . \\tau \\\\ & \\tau = \\lambda \\text{diag}(\\nabla . v) + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} \\begin{cases} &\\frac{d^2v}{dt^2} = \\nabla . \\tau \\\\ & \\tau = \\lambda \\text{diag}(\\nabla . v) + \\mu (\\nabla v + (\\nabla v)^T) \\end{cases} where once again v v is the vector valued particle velocity, and \\tau \\tau is now time independent. This formulation is straightforward to implement as well and only requires minor update to the declaration of the symbolic objects and PDE. # Now that looks pretty! But let's do it again with a 2nd order in time so = 8 v2 = VectorTimeFunction ( name = 'v2' , grid = model . grid , space_order = so , time_order = 2 ) tau0 = TensorFunction ( name = 't0' , grid = model . grid , space_order = so ) # The source injection term src_xx = src . inject ( field = tau0 [ 0 , 0 ], expr = src . dt ) src_zz = src . inject ( field = tau0 [ 1 , 1 ], expr = src . dt ) s = model . grid . time_dim . spacing # fdelmodc reference implementation u_v = Eq ( v2 . forward , model . damp * ( 2 * v2 - model . damp * v2 . backward + s ** 2 * ro * div ( tau0 ))) u_t = Eq ( tau0 , model . damp * ( l * diag ( div ( v2 . forward )) + mu * ( grad ( v2 . forward ) + grad ( v2 . forward ) . T ))) # rec_term = rec.interpolate(expr=tau[0, 0] + tau[1, 1]) rec_term = rec2 . interpolate ( expr = v2 [ 0 ]) rec_term += rec3 . interpolate ( expr = v2 [ 1 ]) op = Operator ([ u_v ] + [ u_t ] + src_xx + src_zz + rec_term ) #NBVAL_IGNORE_OUTPUT # Partial ru for 1.2sec to plot the wavefield op ( dt = model . critical_dt , time_M = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.20 s #NBVAL_SKIP scale = 1e-4 plt_options_model = { 'extent' : [ model . origin [ 0 ] , model . origin [ 0 ] + model . domain_size [ 0 ], model . origin [ 1 ] + model . domain_size [ 1 ], model . origin [ 1 ]]} fig , ax = plt . subplots ( nrows = 2 , ncols = 2 , figsize = ( 15 , 15 )) ax [ 0 , 0 ] . imshow ( np . transpose ( v2 [ 0 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 0 ] . set_aspect ( 'auto' ) ax [ 0 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 0 , 0 ] . set_title ( r \"$v_ {x} $\" , fontsize = 20 ) ax [ 0 , 1 ] . imshow ( np . transpose ( v2 [ 1 ] . data [ 0 ][ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 0 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 0 , 1 ] . set_aspect ( 'auto' ) ax [ 0 , 1 ] . set_title ( r \"$v_ {z} $\" , fontsize = 20 ) ax [ 0 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 0 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 0 ] . imshow ( np . transpose ( tau0 [ 0 , 0 ] . data [ slices ] + tau0 [ 1 , 1 ] . data [ slices ]), vmin =- 10 * scale , vmax = 10 * scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 0 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 0 ] . set_aspect ( 'auto' ) ax [ 1 , 0 ] . set_title ( r \"$\\tau_ {xx} + \\tau_ {zz} $\" , fontsize = 20 ) ax [ 1 , 0 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 0 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) ax [ 1 , 1 ] . imshow ( np . transpose ( tau0 [ 0 , 1 ] . data [ slices ]), vmin =- scale , vmax = scale , cmap = \"RdGy\" , ** plt_options_model ) ax [ 1 , 1 ] . imshow ( np . transpose ( model . lam . data [ slices ]), vmin = 2.5 , vmax = 15.0 , cmap = \"jet\" , alpha =. 5 , ** plt_options_model ) ax [ 1 , 1 ] . set_aspect ( 'auto' ) ax [ 1 , 1 ] . set_title ( r \"$\\tau_ {xy} $\" , fontsize = 20 ) ax [ 1 , 1 ] . set_xlabel ( 'X (m)' , fontsize = 20 ) ax [ 1 , 1 ] . set_ylabel ( 'Depth (m)' , fontsize = 20 ) plt . tight_layout () #NBVAL_IGNORE_OUTPUT op ( dt = model . critical_dt , time_m = int ( 1000 / model . critical_dt )) Operator `Kernel` run in 0.20 s rec2_plot2 = rec2 . resample ( num = 1001 ) rec3_plot2 = rec3 . resample ( num = 1001 ) #NBVAL_SKIP # OBC data of vx/vz plt . figure ( figsize = ( 15 , 15 )) plt . subplot ( 121 ) plt . imshow ( rec2_plot2 . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) plt . subplot ( 122 ) plt . imshow ( rec3_plot2 . data , vmin =- 1e-3 , vmax = 1e-3 , cmap = \"seismic\" , interpolation = 'lanczos' , extent = extent , aspect = aspect ) plt . ylabel ( \"Time (s)\" , fontsize = 20 ) plt . xlabel ( \"Receiver position (m)\" , fontsize = 20 ) Text(0.5, 0, 'Receiver position (m)')","title":"Second order formulation"}]}